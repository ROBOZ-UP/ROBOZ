<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://roboz-up.github.io</id>
    <title>ROBOZ</title>
    <updated>2020-10-18T08:06:32.707Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://roboz-up.github.io"/>
    <link rel="self" href="https://roboz-up.github.io/atom.xml"/>
    <subtitle>阿俊的平行空间 </subtitle>
    <logo>https://roboz-up.github.io/images/avatar.png</logo>
    <icon>https://roboz-up.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, ROBOZ</rights>
    <entry>
        <title type="html"><![CDATA[小芽舵机技术资料]]></title>
        <id>https://roboz-up.github.io/post/xiao-ya-duo-ji-ji-zhu-zi-liao/</id>
        <link href="https://roboz-up.github.io/post/xiao-ya-duo-ji-ji-zhu-zi-liao/">
        </link>
        <updated>2020-10-17T07:21:02.000Z</updated>
        <content type="html"><![CDATA[<p>⏰最后更新时间：2020.10.18</p>
<p>资料参考<br>
<a href="http://xiaoyatec.com/2016/07/11/ax-12-ax-12-ax-12a-robotis%e8%88%b5%e6%9c%ba%e6%8a%80%e6%9c%af%e8%b5%84%e6%96%99%ef%bc%88%e4%b8%ad%e6%96%87%e7%89%88%ef%bc%89/">AX-12/ AX-12+/ AX-12A ROBOTIS舵机技术资料（中文版）</a> | 北京小芽科技</p>
<p><img src="http://xiaoyatec.com/wp-content/uploads/2016/07/20160711113031_13079.png" alt="" loading="lazy"><br>
※ AX-12+是AX-12的升级版，在电路设计、制作材料、齿轮组等都做了升级；<br>
※ AX-12A是AX-12+的升级版本，现在这个系列中只有AX-12A在售，其他的已经停产。</p>
<p>AX-12A舵机是半双工的TTL通信方式，全双工转半双工的原理图如下：<br>
<img src="http://xiaoyatec.com/wp-content/uploads/2016/07/20160711115702_42385.png" alt="" loading="lazy"></p>
<p>普通用户可以用USB2Dynamixel串口转换器进行舵机控制，管脚说明如下图所示：<br>
<img src="http://xiaoyatec.com/wp-content/uploads/2016/07/20160711115848_63993.png" alt="" loading="lazy"></p>
<h1 id="技术参数">技术参数：</h1>
<table>
<thead>
<tr>
<th style="text-align:center">品名</th>
<th style="text-align:center">Dynamixel AX-12 / AX-12+ /AX-12A</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">重量</td>
<td style="text-align:center">53.5g(AX-12/AX-12+), 54.6g(AX-12A)</td>
</tr>
<tr>
<td style="text-align:center">尺寸</td>
<td style="text-align:center">32mm x 50mm x 40mm</td>
</tr>
<tr>
<td style="text-align:center">精度</td>
<td style="text-align:center">0.29°</td>
</tr>
<tr>
<td style="text-align:center">齿轮减速比</td>
<td style="text-align:center">254:1</td>
</tr>
<tr>
<td style="text-align:center">静止扭矩 (N.m)</td>
<td style="text-align:center">1.5N.m(12.0V, 1.5A)</td>
</tr>
<tr>
<td style="text-align:center">空载速度 (RPM)</td>
<td style="text-align:center">59rpm(12V)</td>
</tr>
<tr>
<td style="text-align:center">操作范围</td>
<td style="text-align:center">舵机模式 :  300 °    <br/>轮式模式 : 无限旋转</td>
</tr>
<tr>
<td style="text-align:center">操作电压</td>
<td style="text-align:center">9~12V (推荐电压 : 11.1V)</td>
</tr>
<tr>
<td style="text-align:center">操作温度</td>
<td style="text-align:center">-5°C ~ 70°C</td>
</tr>
<tr>
<td style="text-align:center">指令信号</td>
<td style="text-align:center">数据信号</td>
</tr>
<tr>
<td style="text-align:center">通讯协议</td>
<td style="text-align:center">半双工异步串口通讯(8bit,1stop, No Parity)</td>
</tr>
<tr>
<td style="text-align:center">物理连接</td>
<td style="text-align:center">TTL 多点总线(菊花链型连接)</td>
</tr>
<tr>
<td style="text-align:center">ID</td>
<td style="text-align:center">254 ID (0~253)</td>
</tr>
<tr>
<td style="text-align:center">波特率</td>
<td style="text-align:center">7343bps ~ 1Mbps</td>
</tr>
<tr>
<td style="text-align:center">反馈功能</td>
<td style="text-align:center">位置、温度、负载、输入电压、电流等</td>
</tr>
<tr>
<td style="text-align:center">材质</td>
<td style="text-align:center">外壳 : 工程塑料<br/>齿轮 : 工程塑料</td>
</tr>
</tbody>
</table>
<p>※ 堵转扭矩指的是瞬间禁止最大扭矩<br>
※ 稳定动作的扭矩一般设计为堵转扭矩的1/5或者更少</p>
<h1 id="舵机尺寸">舵机尺寸：</h1>
<figure data-type="image" tabindex="1"><img src="http://xiaoyatec.com/wp-content/uploads/2016/07/20160711120711_42144.png" alt="舵机尺寸图" loading="lazy"></figure>
<h1 id="控制列表">控制列表：</h1>
<p>控制表包含了舵机的状态和操作信息。用户可以通过修改指令包数据来控制舵机。</p>
<h3 id="eeprom-和-ram-存储">EEPROM 和 RAM 存储</h3>
<p>RAM 区域中的数据在断电时不会被保存, 而保存在 EEPROM 区域的数据即使在断电时仍然会保存在 EEPROM內。</p>
<h3 id="address-位址">Address ( 位址)</h3>
<p>表示数据储存的位址,为了从控制列表中读取或者烧写数据，用户需要把数据分配到正确的指令包位置中。</p>
<h3 id="access-存取">Access ( 存取)</h3>
<p>Dynamixel 拥有两类数据：只读数据，这类数据一般用于传感器；可读写数据，这类数据主要作为驱动数据使用，多作为控制用途。</p>
<h3 id="initial-value-初始值">Initial Value ( 初始值)</h3>
<p>在EEPROM存储区域中, 在下面控制列表右边的初始值，为出厂设置的初始值；而在RAM区域，在控制列表的右边的初始值，为舵机上电启动时的初始值。</p>
<h3 id="highestlowest-byte-高低位字节">Highest/Lowest Byte ( 高/低位字节)</h3>
<p>在列表中, 有一些数据共享同一名称, 但会在名称末尾加上一个(L)或(H)来区分不同的地址,这类数据需要16比特的存储区域，并且这个区域会按照8比特的宽度来区分高（high）低（low）位。这两个位址必须由一个指令包同时读取或写入。</p>
<h2 id="eeprom">EEPROM</h2>
<table>
<thead>
<tr>
<th style="text-align:center">地址（16进制）</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">存取</th>
<th style="text-align:center">初始值（16进制）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0 (0X00)</td>
<td style="text-align:center">Model Number(L)<br/>舵机型号</td>
<td style="text-align:center">Lowest byte of model number<br/>型号的低字节</td>
<td style="text-align:center">R</td>
<td style="text-align:center">12 (0X0C)</td>
</tr>
<tr>
<td style="text-align:center">1 (0X01)</td>
<td style="text-align:center">Model Number(H)<br/>舵机型号</td>
<td style="text-align:center">Highest byte of model number<br/>型号的高字节</td>
<td style="text-align:center">R</td>
<td style="text-align:center">0 (0X00)</td>
</tr>
<tr>
<td style="text-align:center">2 (0X02)</td>
<td style="text-align:center">Version of Firmware<br/>固件的版本</td>
<td style="text-align:center">Information on the version of firmware<br/>有关固件版本的信息</td>
<td style="text-align:center">R</td>
<td style="text-align:center">–</td>
</tr>
<tr>
<td style="text-align:center">3 (0X03)</td>
<td style="text-align:center">ID<br/></td>
<td style="text-align:center">ID of Dynamixel<br/>Dynamixel的ID</td>
<td style="text-align:center">RW</td>
<td style="text-align:center">1 (0X01)</td>
</tr>
<tr>
<td style="text-align:center">4 (0X04)</td>
<td style="text-align:center">Baud Rate<br/>波特率</td>
<td style="text-align:center">Baud Rate of Dynamixel<br/>Dynamixel的波特率</td>
<td style="text-align:center">RW</td>
<td style="text-align:center">1 (0X01)</td>
</tr>
<tr>
<td style="text-align:center">5 (0X05)</td>
<td style="text-align:center">Return Delay Time<br/>回应延迟时间</td>
<td style="text-align:center">Return Delay Time<br/>回应延迟时间</td>
<td style="text-align:center">RW</td>
<td style="text-align:center">250 (0XFA)</td>
</tr>
<tr>
<td style="text-align:center">6 (0X06)</td>
<td style="text-align:center">CW Angle Limit(L)<br/>顺时针角度限制</td>
<td style="text-align:center">Lowest byte of clockwise Angle Limit<br/>顺时针角度限制的低字节</td>
<td style="text-align:center">RW</td>
<td style="text-align:center">0 (0X00)</td>
</tr>
<tr>
<td style="text-align:center">7 (0X07)</td>
<td style="text-align:center">CW Angle Limit(H)<br/>顺时针角度限制</td>
<td style="text-align:center">Highest byte of clockwise Angle Limit<br/>顺时针角度限制的高字节</td>
<td style="text-align:center">RW</td>
<td style="text-align:center">0 (0X00)</td>
</tr>
<tr>
<td style="text-align:center">8 (0X08)</td>
<td style="text-align:center">CCW Angle Limit(L)<br/>逆时针角度限制</td>
<td style="text-align:center">Lowest byte of counterclockwise Angle Limit<br/>逆时针角度限制的低字节</td>
<td style="text-align:center">RW</td>
<td style="text-align:center">255 (0XFF)</td>
</tr>
<tr>
<td style="text-align:center">9 (0X09)</td>
<td style="text-align:center">CCW Angle Limit(H)<br/>逆时针角度限制</td>
<td style="text-align:center">Highest byte of counterclockwise Angle Limit<br/>逆时针角度限制的高字节</td>
<td style="text-align:center">RW</td>
<td style="text-align:center">3 (0X03)</td>
</tr>
<tr>
<td style="text-align:center">11 (0X0B)</td>
<td style="text-align:center">the Highest Limit Temperature<br/>最高温度限制</td>
<td style="text-align:center">Internal Limit Temperature<br/>内部极限温度</td>
<td style="text-align:center">RW</td>
<td style="text-align:center">70 (0X46)</td>
</tr>
<tr>
<td style="text-align:center">12 (0X0C)</td>
<td style="text-align:center">the Lowest Limit Voltage<br/>最低电压限制</td>
<td style="text-align:center">Lowest Limit Voltage<br/>最低极限电压</td>
<td style="text-align:center">RW</td>
<td style="text-align:center">60 (0X3C)</td>
</tr>
<tr>
<td style="text-align:center">13 (0X0D)</td>
<td style="text-align:center">the Highest Limit Voltage<br/>最高电压限制</td>
<td style="text-align:center">Highest Limit Voltage<br/>最高极限电压</td>
<td style="text-align:center">RW</td>
<td style="text-align:center">140 (0XBE)</td>
</tr>
<tr>
<td style="text-align:center">14 (0X0E)</td>
<td style="text-align:center">Max Torque(L)<br/>最大扭矩</td>
<td style="text-align:center">Lowest byte of Max. Torque<br/>最大扭矩的低字节</td>
<td style="text-align:center">RW</td>
<td style="text-align:center">255 (0XFF)</td>
</tr>
<tr>
<td style="text-align:center">15 (0X0F)</td>
<td style="text-align:center">Max Torque(H)<br/>最大扭矩</td>
<td style="text-align:center">Highest byte of Max. Torque<br/>最大扭矩的高字节</td>
<td style="text-align:center">RW</td>
<td style="text-align:center">3 (0X03)</td>
</tr>
<tr>
<td style="text-align:center">16 (0X10)</td>
<td style="text-align:center">Status Return Level<br/>状态回传</td>
<td style="text-align:center">Status Return Level<br/>状态回传</td>
<td style="text-align:center">RW</td>
<td style="text-align:center">2 (0X02)</td>
</tr>
<tr>
<td style="text-align:center">17 (0X11)</td>
<td style="text-align:center">Alarm LED<br/>警示LED</td>
<td style="text-align:center">LED for Alarm<br/>警示LED</td>
<td style="text-align:center">RW</td>
<td style="text-align:center">36(0x24)</td>
</tr>
<tr>
<td style="text-align:center">18 (0X12)</td>
<td style="text-align:center">Alarm Shutdown<br/>关闭警示</td>
<td style="text-align:center">Shutdown for Alarm<br/>关闭警示</td>
<td style="text-align:center">RW</td>
<td style="text-align:center">36(0x24)</td>
</tr>
</tbody>
</table>
<h3 id="model-number">Model Number</h3>
<p>舵机型号，比如AX-12A，型号为12；</p>
<h3 id="firmware-version">Firmware Version</h3>
<p>固件版本</p>
<h3 id="id">ID</h3>
<p>这是一个唯一数值，用于标识Dynamixel舵机。<br>
可以使用的值范围为0到252（0xFC），254（0xFE）作为广播ID使用。<br>
如果ID 254（0xFE）作为指令包使用，将会对所有Dynamixel舵机起作用。<br>
注意：不要在同一控制系统中使用重复的舵机ID（将会导致控制器无法检测到舵机的情况出现）</p>
<h3 id="baud-rate">Baud Rate</h3>
<p>这个值代表了协议的传输速度，可以用0到254（0xFE）的值来代替，分别代表的波特率值如下表所示。<br>
速度值可以用以下公式进行计算：<br>
Speed(BPS) = 2000000/(Data+1)</p>
<table>
<thead>
<tr>
<th style="text-align:center">Data<br/>数值</th>
<th style="text-align:center">Set BPS<br/>设置波特率</th>
<th style="text-align:center">Target BPS<br/>目标波特率</th>
<th style="text-align:center">Tolerance<br/>容许误差</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1000000.0</td>
<td style="text-align:center">1000000.0</td>
<td style="text-align:center">0.000 %</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">500000.0</td>
<td style="text-align:center">500000.0</td>
<td style="text-align:center">0.000 %</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">400000.0</td>
<td style="text-align:center">400000.0</td>
<td style="text-align:center">0.000 %</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">250000.0</td>
<td style="text-align:center">250000.0</td>
<td style="text-align:center">0.000 %</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">200000.0</td>
<td style="text-align:center">200000.0</td>
<td style="text-align:center">0.000 %</td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center">117647.1</td>
<td style="text-align:center">115200.0</td>
<td style="text-align:center">-2.124 %</td>
</tr>
<tr>
<td style="text-align:center">34</td>
<td style="text-align:center">57142.9</td>
<td style="text-align:center">57600.0</td>
<td style="text-align:center">0.794 %</td>
</tr>
<tr>
<td style="text-align:center">103</td>
<td style="text-align:center">19230.8</td>
<td style="text-align:center">19200.0</td>
<td style="text-align:center">-0.160 %</td>
</tr>
<tr>
<td style="text-align:center">207</td>
<td style="text-align:center">9615.4</td>
<td style="text-align:center">9600.0</td>
<td style="text-align:center">-0.160 %</td>
</tr>
</tbody>
</table>
<p>注意：UART串口通信能接受最大3%左右的错误率。</p>
<h3 id="return-delay-time-回应延迟时间">Return Delay Time （回应延迟时间）</h3>
<p>回应延迟时间是指在数据发出时，到数据返回直接的时间间隔。<br>
可用数值范围为0到254（0xFE），而每个数值代表2微秒。<br>
这就是说，如果数值为10，那么就是延迟20微秒，而默认的初始值是250（0xFA），也就是0.5毫秒。</p>
<h3 id="cwccw-angle-limit-顺时针逆时针角度限制">CW/CCW Angle Limit （顺时针/逆时针角度限制）</h3>
<p>控制舵机的极限角度。<br>
可设置的范围和单位跟目标位置的相同（地址：30（0X1E），31（0X1F））<br>
顺时针方向角度限制：目标位置的最小值（地址：30（0X1E），31（0X1F））<br>
逆时针方向角度限制：目标位置的最大值（地址：30（0X1E），31（0X1F））<br>
可以依据顺时针或者逆时针方向来设定以下两种模式的值</p>
<table>
<thead>
<tr>
<th style="text-align:center">Operation Type<br/>运行方式</th>
<th style="text-align:center">CW / CCW<br/>顺时针/逆时针</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Wheel Mode<br/>轮子模式</td>
<td style="text-align:center">both are 0<br/>都是0</td>
</tr>
<tr>
<td style="text-align:center">Joint Mode<br/>关节模式</td>
<td style="text-align:center">neither at 0<br/>都不是0</td>
</tr>
</tbody>
</table>
<p>轮子模式可以使舵机处于无极限地旋转状态，此时机器人可以把舵机当做车轮来使用。<br>
关节模式可以控制舵机的转动角度，此时可以把舵机当做机器人的关节来使用。</p>
<h3 id="the-highest-limit-temperature最高温度限制">The Highest Limit Temperature（最高温度限制）</h3>
<p>警告：设置温度时不要低于/高于默认值。<br>
当温度警示灯停止之后，要等待至少20分钟之后才重新使用舵机。<br>
如果舵机在高温下使用，可能会损坏舵机。</p>
<h3 id="the-lowest-highest-limit-voltage-最低最高电压限制">The Lowest (Highest) Limit Voltage （最低（最高）电压限制）</h3>
<p>可以设置的范围为：50到250（0x32~0x96），单位为0.1V。<br>
例如，如果设置为80，则电压值为8V。<br>
如果“当前电压值”（地址42（0x2A）的值）超出设定值，电压状态错误位（Bit0）会被置为‘1’并返回，同时也会导致警报地址（地址17（0x11）和18（0x12））被设置。</p>
<h3 id="max-torque-最大扭矩">Max Torque （最大扭矩）</h3>
<p>最大输出扭矩，可设置范围为0到1023（0x03ff），单位为最大扭矩的0.1%。<br>
比如，数值1023（0x3ff）代表的是Dynamixel舵机的最大扭矩，而数值512（0x200）代表的是舵机最大扭矩的50%。但舵机上电时，地址34（0x22）和35（0x23）里的数值代表的是舵机初始扭矩。</p>
<h3 id="status-return-level-状态回传">Status Return Level （状态回传）</h3>
<p>状态回传取决于怎样回传状态包，这里有三种回传方式可选择：</p>
<table>
<thead>
<tr>
<th style="text-align:center">数值</th>
<th style="text-align:center">状态回传</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">对所有指令不作回传 (除了 PING 指令)</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">只对“READ”指令做回传</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">对所有指令做回传</td>
</tr>
</tbody>
</table>
<p>当指令为广播ID时，不管回传状态为什么方式都不作回传。</p>
<h3 id="alarm-led-警示led">Alarm LED （警示LED）</h3>
<h3 id="alarm-shutdown-关闭警示">Alarm Shutdown （关闭警示）</h3>
<p>Dynamixel舵机在操作期间如果监测到错误发生，会做出自我保护。<br>
错误位可以设置为以下情况：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Bit</th>
<th style="text-align:center">Name</th>
<th style="text-align:center">Contents</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Bit 7</td>
<td style="text-align:center">0</td>
<td style="text-align:center">—</td>
</tr>
<tr>
<td style="text-align:center">Bit 6</td>
<td style="text-align:center">指令错误</td>
<td style="text-align:center">当传送了不符合规格的指令，或者传送的动作指令里没有reg_write指令。</td>
</tr>
<tr>
<td style="text-align:center">Bit 5</td>
<td style="text-align:center">过载错误</td>
<td style="text-align:center">当前承载超过了最大扭矩的承受范围</td>
</tr>
<tr>
<td style="text-align:center">Bit 4</td>
<td style="text-align:center">校验位错误</td>
<td style="text-align:center">发送的协议出现校验位的校验码错误</td>
</tr>
<tr>
<td style="text-align:center">Bit 3</td>
<td style="text-align:center">范围错误</td>
<td style="text-align:center">所传送的指令超出设定范围</td>
</tr>
<tr>
<td style="text-align:center">Bit 2</td>
<td style="text-align:center">过热错误</td>
<td style="text-align:center">舵机内在温度超出了设定的温度范围</td>
</tr>
<tr>
<td style="text-align:center">Bit 1</td>
<td style="text-align:center">角度限制错误</td>
<td style="text-align:center">传送指令中的角度超出设定的角度范围</td>
</tr>
<tr>
<td style="text-align:center">Bit 0</td>
<td style="text-align:center">输入电压错误</td>
<td style="text-align:center">使用电压超出设定的电压范围</td>
</tr>
</tbody>
</table>
<p>由于错误码是以逻辑或“OR”进行运算的，所以可以叠加回传。例如，0X05（二进制为：00000101）集合，表示检测到输入电压错误和过热错误。如果错误产生，就报警LED来说，LED会闪烁，假如报警LED关闭，舵机将会通过控制扭矩限制Torque Limit（地址34,35）变为0，而致使输出扭矩变成0%。</p>
<h2 id="ram">RAM</h2>
<table>
<thead>
<tr>
<th style="text-align:center">地址（16进制）</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">存取</th>
<th style="text-align:center">初始值（16进制）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">24 (0X18)</td>
<td style="text-align:center">Torque Enable<br/>扭矩使能</td>
<td style="text-align:center">Torque On/Off<br/></td>
<td style="text-align:center">RW</td>
<td style="text-align:center">0 (0X00)</td>
</tr>
<tr>
<td style="text-align:center">25 (0X19)</td>
<td style="text-align:center">LED</td>
<td style="text-align:center">LED On/Off</td>
<td style="text-align:center">RW</td>
<td style="text-align:center">0 (0X00)</td>
</tr>
<tr>
<td style="text-align:center">26 (0X1A)</td>
<td style="text-align:center">CW Compliance Margin</td>
<td style="text-align:center">CW Compliance margin</td>
<td style="text-align:center">RW</td>
<td style="text-align:center">1 (0X01)</td>
</tr>
<tr>
<td style="text-align:center">27 (0X1B)</td>
<td style="text-align:center">CCW Compliance Margin</td>
<td style="text-align:center">CCW Compliance margin</td>
<td style="text-align:center">RW</td>
<td style="text-align:center">1 (0X01)</td>
</tr>
<tr>
<td style="text-align:center">28 (0X1C)</td>
<td style="text-align:center">CW Compliance Slope</td>
<td style="text-align:center">CW Compliance slope</td>
<td style="text-align:center">RW</td>
<td style="text-align:center">32 (0X20)</td>
</tr>
<tr>
<td style="text-align:center">29 (0X1D)</td>
<td style="text-align:center">CCW Compliance Slope</td>
<td style="text-align:center">CCW Compliance slope</td>
<td style="text-align:center">RW</td>
<td style="text-align:center">32 (0X20)</td>
</tr>
<tr>
<td style="text-align:center">30 (0X1E)</td>
<td style="text-align:center">Goal Position(L)<br/>目标位置</td>
<td style="text-align:center">Lowest byte of Goal Position<br/>目标位置低字节</td>
<td style="text-align:center">RW</td>
<td style="text-align:center">–</td>
</tr>
<tr>
<td style="text-align:center">31 (0X1F)</td>
<td style="text-align:center">Goal Position(H)<br/>目标位置</td>
<td style="text-align:center">Highest byte of Goal Position<br/>目标位置高字节</td>
<td style="text-align:center">RW</td>
<td style="text-align:center">–</td>
</tr>
<tr>
<td style="text-align:center">32 (0X20)</td>
<td style="text-align:center">Moving Speed(L)<br/>转动速度</td>
<td style="text-align:center">Lowest byte of Moving Speed (Moving Velocity)转动速度低字节</td>
<td style="text-align:center">RW</td>
<td style="text-align:center">–</td>
</tr>
<tr>
<td style="text-align:center">33 (0X21)</td>
<td style="text-align:center">Moving Speed(H)<br/>转动速度</td>
<td style="text-align:center">Highest byte of Moving Speed (Moving Velocity)转动速度高字节</td>
<td style="text-align:center">RW</td>
<td style="text-align:center">–</td>
</tr>
<tr>
<td style="text-align:center">34 (0X22)</td>
<td style="text-align:center">Torque Limit(L)<br/>扭矩限制</td>
<td style="text-align:center">Lowest byte of Torque Limit (Goal Torque)<br/>扭矩限制低字节</td>
<td style="text-align:center">RW</td>
<td style="text-align:center">ADD14</td>
</tr>
<tr>
<td style="text-align:center">35 (0X23)</td>
<td style="text-align:center">Torque Limit(H)<br/>扭矩限制</td>
<td style="text-align:center">Highest byte of Torque Limit (Goal Torque)<br/>扭矩限制高字节</td>
<td style="text-align:center">RW</td>
<td style="text-align:center">ADD15</td>
</tr>
<tr>
<td style="text-align:center">36 (0X24)</td>
<td style="text-align:center">Present Position(L)<br/>当前位置</td>
<td style="text-align:center">Lowest byte of Current Position (Present Velocity)<br/>当前位置低字节</td>
<td style="text-align:center">R</td>
<td style="text-align:center">–</td>
</tr>
<tr>
<td style="text-align:center">37 (0X25)</td>
<td style="text-align:center">Present Position(H)<br/>当前位置</td>
<td style="text-align:center">Highest byte of Current Position (Present Velocity)<br/>当前位置高字节</td>
<td style="text-align:center">R</td>
<td style="text-align:center">–</td>
</tr>
<tr>
<td style="text-align:center">38 (0X26)</td>
<td style="text-align:center">Present Speed(L)<br/>当前速度</td>
<td style="text-align:center">Lowest byte of Current Speed<br/>当前速度低字节</td>
<td style="text-align:center">R</td>
<td style="text-align:center">–</td>
</tr>
<tr>
<td style="text-align:center">39 (0X27)</td>
<td style="text-align:center">Present Speed(H)<br/>当前速度</td>
<td style="text-align:center">Highest byte of Current Speed<br/>当前速度高字节</td>
<td style="text-align:center">R</td>
<td style="text-align:center">–</td>
</tr>
<tr>
<td style="text-align:center">40 (0X28)</td>
<td style="text-align:center">Present Load(L)<br/>当前负载</td>
<td style="text-align:center">Lowest byte of Current Load<br/>当前负载低字节</td>
<td style="text-align:center">R</td>
<td style="text-align:center">–</td>
</tr>
<tr>
<td style="text-align:center">41 (0X29)</td>
<td style="text-align:center">Present Load(H)<br/>当前负载</td>
<td style="text-align:center">Highest byte of Current Load<br/>当前负载高字节</td>
<td style="text-align:center">R</td>
<td style="text-align:center">–</td>
</tr>
<tr>
<td style="text-align:center">42 (0X2A)</td>
<td style="text-align:center">Present Voltage<br/>当前电压</td>
<td style="text-align:center">Current Voltage<br/>当前电压</td>
<td style="text-align:center">R</td>
<td style="text-align:center">–</td>
</tr>
<tr>
<td style="text-align:center">43 (0X2B)</td>
<td style="text-align:center">Present Temperature<br/>当前温度</td>
<td style="text-align:center">Current Temperature<br/>当前温度</td>
<td style="text-align:center">R</td>
<td style="text-align:center">–</td>
</tr>
<tr>
<td style="text-align:center">44 (0X2C)</td>
<td style="text-align:center">Registered<br/>指令登记</td>
<td style="text-align:center">Means if Instruction is registered<br/>表示指令是否被执行</td>
<td style="text-align:center">R</td>
<td style="text-align:center">0 (0X00)</td>
</tr>
<tr>
<td style="text-align:center">46 (0X2E)</td>
<td style="text-align:center">Moving<br/>运动</td>
<td style="text-align:center">Means if there is any movement<br/>表示是否运动</td>
<td style="text-align:center">R</td>
<td style="text-align:center">0 (0X00)</td>
</tr>
<tr>
<td style="text-align:center">47 (0X2F)</td>
<td style="text-align:center">Lock<br/>锁定</td>
<td style="text-align:center">Locking EEPROM<br/>EEPROM锁定</td>
<td style="text-align:center">RW</td>
<td style="text-align:center">0 (0X00)</td>
</tr>
<tr>
<td style="text-align:center">48 (0X30)</td>
<td style="text-align:center">Punch(L)<br/>载流</td>
<td style="text-align:center">Lowest byte of Punch<br/>载流低字节</td>
<td style="text-align:center">RW</td>
<td style="text-align:center">32 (0X20)</td>
</tr>
<tr>
<td style="text-align:center">49 (0X31)</td>
<td style="text-align:center">Punch(H)<br/>载流</td>
<td style="text-align:center">Highest byte of Punch<br/>载流高字节</td>
<td style="text-align:center">RW</td>
<td style="text-align:center">0 (0X00)</td>
</tr>
</tbody>
</table>
<h3 id="扭矩生效">扭矩生效</h3>
<table>
<thead>
<tr>
<th style="text-align:center">数值</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">通过中断电机供电保持舵机转矩不变</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">通过对电机供电使舵机产生转矩</td>
</tr>
</tbody>
</table>
<h3 id="led">LED</h3>
<table>
<thead>
<tr>
<th style="text-align:center">数值</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">关闭LED</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">开启LED</td>
</tr>
</tbody>
</table>
<h3 id="goal-position-目标位置">Goal Position (目标位置)</h3>
<p>这个值代表目标位置。<br>
值的范围为：0到1023。单位精度为0.29度。<br>
如果目标位置超出范围值，状态数据包的角度限制错误位（Bit 1）将会返回“1”，并且将会根据警告LED的设置发出警报。<br>
<img src="http://xiaoyatec.com/wp-content/uploads/2016/07/20160711114841_86161.png" alt="" loading="lazy"><br>
以上图片信息只用于关节模式，在轮子模式下不可用！</p>
<h3 id="moving-speed-转动速度">Moving Speed （转动速度）</h3>
<p>这个值代表的是到达目标位置的转动速度。<br>
根据不同的模式选择，会有不同的范围值和单位值。</p>
<ul>
<li>
<h4 id="关节模式br范围值为0到10230x3ff-单位值为0111rpm-br当设置为0时舵机将不受速度控制以最大速度运动-br如果设置为最大值1023时速度为114rpm-br例如如果值设置为300代表的是333rpm-br注意确保是在关节模式时设置的最大值即使设置的范围超出了最大值转动的速度也将不会超出最大的范围值">关节模式：<br/>范围值为：0到1023（0X3FF）。单位值为0.111rpm。<br/>当设置为0时，舵机将不受速度控制，以最大速度运动。<br/>如果设置为最大值1023时，速度为114rpm。<br/>例如，如果值设置为300，代表的是33.3rpm。<br/>注意：确保是在关节模式时设置的最大值，即使设置的范围超出了最大值，转动的速度也将不会超出最大的范围值。</h4>
</li>
<li>
<h4 id="轮子模式br范围值为0到20470x7ff单位为01-br当逆时针方向旋转时范围值为0到10230值为停止br当顺时针方向旋转时范围值为1024到20471024值为停止-br这就是说第10个bit是用于控制方向的-br在轮子模式对于扭矩可以控制输出的大小而不可以控制速度-br例如如果设置为512代表为最大输出的50">轮子模式：<br/>范围值为：0到2047（0X7FF），单位为0.1%。<br/>当逆时针方向旋转时，范围值为0到1023，0值为停止；<br/>当顺时针方向旋转时，范围值为1024到2047，1024值为停止。<br/>这就是说第10个bit是用于控制方向的。<br/>在轮子模式，对于扭矩可以控制输出的大小，而不可以控制速度。<br/>例如，如果设置为512，代表为最大输出的50%。</h4>
</li>
</ul>
<h3 id="torque-limit-扭矩限制">Torque Limit (扭矩限制)</h3>
<p>最大扭矩输出控制<br>
范围为0到1023（0X3FF），单位为0.1%。<br>
例如，如果设置为512，代表为50%，意思就是最大输出扭矩的50%。<br>
当控制器上电时，将会以Max Torque（地址14，15）里的值为初始值。<br>
注意：当触发关机警告时，舵机将会失去扭矩，此时舵机扭矩为0。在这个时候，如果更改舵机扭矩的值，不为0，舵机将可重新启用。</p>
<h3 id="present-position-当前位置值">Present Position （当前位置值）</h3>
<p>代表舵机的当前位置。<br>
范围为0到1023（0X3FF），单位为0.29度。<br>
<img src="http://xiaoyatec.com/wp-content/uploads/2016/07/20160711115150_41253.png" alt="舵机位置表示" loading="lazy"><br>
警告：在轮子模式下，这个值不能代表移动距离和转动频率。</p>
<h3 id="present-speed-当前速度">Present Speed （当前速度）</h3>
<p>代表当前的运动速度。<br>
范围值为0到2047（0X7FF）。<br>
如果此值为0到1023时，代表此时是逆时针旋转；<br>
如果此值为1024到2047时，代表顺时针旋转。<br>
这就是说，第10个bit的值代表了运动方向，0和1024是等效的。<br>
这个值的单位得视转动模式而定。</p>
<ul>
<li>
<h4 id="关节模式br单位为011rpm-br例如如果值为300代表了逆时针运动的速度为333rpm">关节模式：<br/>单位为0.11rpm。<br/>例如，如果值为300，代表了逆时针运动的速度为33.3rpm。</h4>
</li>
<li>
<h4 id="轮子模式br单位为01-br例如如果值为512代表着逆时针输出扭矩为最大扭矩的50">轮子模式：<br/>单位为0.1%。<br/>例如，如果值为512，代表着逆时针输出扭矩为最大扭矩的50%。</h4>
</li>
</ul>
<h3 id="present-load-即时负载">Present Load （即时负载）</h3>
<p>代表现在负载情况。<br>
范围为0到2047，单位为0.1%。<br>
如果范围为0到1023，逆时针方向负载；<br>
如果范围为1024到2047，顺时针方向负载。<br>
这就是说，第10个bit的值代表了运动方向，0和1024是等效的。<br>
例如，如果值为512，代表着逆时针方向以50%的扭矩负载。<br>
<img src="http://xiaoyatec.com/wp-content/uploads/2016/07/20160711115253_58068.png" alt="" loading="lazy"><br>
注意：即时负载是根据输出进行内部推测的值，而不是来自力矩传感器。由于这个原因，这个值不可用于测量重量或者力矩，但可以用于判断受压方向。</p>
<h3 id="present-voltage-当前电压">Present Voltage （当前电压）</h3>
<p>代表当前供应的电压。<br>
这个值是当前实际电压的10倍，例如，输入电压为10V，这个值为100（0X64）。</p>
<h3 id="present-temperature-当前温度">Present Temperature （当前温度）</h3>
<p>这个值代表了舵机的摄氏温度。<br>
这个值跟实际摄氏温度值一致，例如，数值为85（0X55），代表当前温度为85℃。</p>
<h3 id="指令登记">指令登记：</h3>
<table>
<thead>
<tr>
<th style="text-align:center">值</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">没有指令通过REG_WRITE传输</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">有指令通过REG_WRITE传输</td>
</tr>
</tbody>
</table>
<p>注意：如果ACTION指令被执行，这个值将会变成0。</p>
<h3 id="旋转运动">旋转运动</h3>
<table>
<thead>
<tr>
<th style="text-align:center">值</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">目标位置运动指令执行完毕</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">目标位置运动指令正在执行中</td>
</tr>
</tbody>
</table>
<h3 id="锁定">锁定</h3>
<table>
<thead>
<tr>
<th style="text-align:center">值</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">EEPROM 区域可被修改</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">EEPROM 区域不可被修改</td>
</tr>
</tbody>
</table>
<p>警示：如果Lock设置为1，必须断电，重新上电，该数值变为0。</p>
<h3 id="载流">载流</h3>
<p>驱动电机的电流已经设为最小。<br>
可设置的范围为0x20到0x3ff。</p>
<h1 id="a-target_blank-hrefhttpmailqqcomcgi-binqm_sharetqm_mailmeemailk_h88fzp0_livfd8-g-styletext-decorationnone-意见反馈a"><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=k_H88fzp0_LivfD8-g" style="text-decoration:none;">✉ 意见反馈</a></h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[API集]]></title>
        <id>https://roboz-up.github.io/post/api-ji/</id>
        <link href="https://roboz-up.github.io/post/api-ji/">
        </link>
        <updated>2020-05-16T13:50:51.000Z</updated>
        <content type="html"><![CDATA[<p>⏰最后更新时间：2020.5.16</p>
<p>IP 地址查询</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/114.html">http://apistore.baidu.com/apiworks/servicedetail/114.html</a></p>
<p>频道新闻 API_易源</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/688.html">http://apistore.baidu.com/apiworks/servicedetail/688.html</a></p>
<p>微信热门精选 ：</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/632.html">http://apistore.baidu.com/apiworks/servicedetail/632.html</a></p>
<p>天气查询</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/112.html">http://apistore.baidu.com/apiworks/servicedetail/112.html</a></p>
<p>中国和世界天气预报</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/478.html">http://apistore.baidu.com/apiworks/servicedetail/478.html</a></p>
<p>股票查询</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/115.html">http://apistore.baidu.com/apiworks/servicedetail/115.html</a></p>
<p>身份证查询：</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/113.html">http://apistore.baidu.com/apiworks/servicedetail/113.html</a></p>
<p>音乐搜索</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/1020.html">http://apistore.baidu.com/apiworks/servicedetail/1020.html</a></p>
<p>图灵机器人</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/736.html">http://apistore.baidu.com/apiworks/servicedetail/736.html</a></p>
<p>汇率转换</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/119.html">http://apistore.baidu.com/apiworks/servicedetail/119.html</a></p>
<p>节假日</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/1116.html">http://apistore.baidu.com/apiworks/servicedetail/1116.html</a></p>
<p>pullword 在线分词服务</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/143.html">http://apistore.baidu.com/apiworks/servicedetail/143.html</a></p>
<p>去哪儿网火车票</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/697.html">http://apistore.baidu.com/apiworks/servicedetail/697.html</a></p>
<p>笑话大全</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/864.html">http://apistore.baidu.com/apiworks/servicedetail/864.html</a></p>
<p>银行卡查询服务</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/735.html">http://apistore.baidu.com/apiworks/servicedetail/735.html</a></p>
<p>语音合成</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/867.html">http://apistore.baidu.com/apiworks/servicedetail/867.html</a></p>
<p>宅言 API - 动漫台词接口</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/446.html">http://apistore.baidu.com/apiworks/servicedetail/446.html</a></p>
<p>去哪儿景点门票查询</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/140.html">http://apistore.baidu.com/apiworks/servicedetail/140.html</a></p>
<p>手机号码归属地</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/794.html">http://apistore.baidu.com/apiworks/servicedetail/794.html</a></p>
<p>体育新闻</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/711.html">http://apistore.baidu.com/apiworks/servicedetail/711.html</a></p>
<p>手机归属地查询</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/709.html">http://apistore.baidu.com/apiworks/servicedetail/709.html</a></p>
<p>科技新闻</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/1061.html">http://apistore.baidu.com/apiworks/servicedetail/1061.html</a></p>
<p>空气质量指数</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/116.html">http://apistore.baidu.com/apiworks/servicedetail/116.html</a></p>
<p>天狗健康菜谱</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/987.html">http://apistore.baidu.com/apiworks/servicedetail/987.html</a></p>
<p>热门游记列表</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/520.html">http://apistore.baidu.com/apiworks/servicedetail/520.html</a></p>
<p>天狗药品查询</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/916.html">http://apistore.baidu.com/apiworks/servicedetail/916.html</a></p>
<p>汉字转拼音</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/1124.html">http://apistore.baidu.com/apiworks/servicedetail/1124.html</a></p>
<p>国际新闻</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/823.html">http://apistore.baidu.com/apiworks/servicedetail/823.html</a></p>
<p>彩票</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/164.html">http://apistore.baidu.com/apiworks/servicedetail/164.html</a></p>
<p>微信精选</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/863.html">http://apistore.baidu.com/apiworks/servicedetail/863.html</a></p>
<p>天狗健康资讯</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/888.html">http://apistore.baidu.com/apiworks/servicedetail/888.html</a></p>
<p>兴趣点检索</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/182.html">http://apistore.baidu.com/apiworks/servicedetail/182.html</a></p>
<p>用药参考</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/754.html">http://apistore.baidu.com/apiworks/servicedetail/754.html</a></p>
<p>天狗健康知识</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/899.html">http://apistore.baidu.com/apiworks/servicedetail/899.html</a></p>
<p>奇闻趣事</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/633.html">http://apistore.baidu.com/apiworks/servicedetail/633.html</a></p>
<p>花边新闻</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/768.html">http://apistore.baidu.com/apiworks/servicedetail/768.html</a></p>
<p>天狗医院大全</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/988.html">http://apistore.baidu.com/apiworks/servicedetail/988.html</a></p>
<p>生活健康</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/989.html">http://apistore.baidu.com/apiworks/servicedetail/989.html</a></p>
<p>手机号码归属地 API 接口：</p>
<p><a href="https://www.juhe.cn/docs/api/id/11">https://www.juhe.cn/docs/api/id/11</a></p>
<p>历史上的今天 API 接口：</p>
<p><a href="https://www.juhe.cn/docs/api/id/63">https://www.juhe.cn/docs/api/id/63</a></p>
<p>股票数据 API 接口：</p>
<p><a href="https://www.juhe.cn/docs/api/id/21">https://www.juhe.cn/docs/api/id/21</a></p>
<p>全国 WIFI 接口：</p>
<p><a href="https://www.juhe.cn/docs/api/id/18">https://www.juhe.cn/docs/api/id/18</a></p>
<p>星座运势接口：</p>
<p><a href="https://www.juhe.cn/docs/api/id/58">https://www.juhe.cn/docs/api/id/58</a></p>
<p>黄金数据接口：</p>
<p><a href="https://www.juhe.cn/docs/api/id/29">https://www.juhe.cn/docs/api/id/29</a></p>
<p>语音识别接口：</p>
<p><a href="https://www.juhe.cn/docs/api/id/134">https://www.juhe.cn/docs/api/id/134</a></p>
<p>周公解梦接口：</p>
<p><a href="https://www.juhe.cn/docs/api/id/64">https://www.juhe.cn/docs/api/id/64</a></p>
<p>天气预报 API 接口：</p>
<p><a href="https://www.juhe.cn/docs/api/id/73">https://www.juhe.cn/docs/api/id/73</a></p>
<p>身份证查询 API 接口：</p>
<p><a href="https://www.juhe.cn/docs/api/id/38">https://www.juhe.cn/docs/api/id/38</a></p>
<p>笑话大全 API 接口：</p>
<p><a href="https://www.juhe.cn/docs/api/id/95">https://www.juhe.cn/docs/api/id/95</a></p>
<p>邮编查询接口：</p>
<p><a href="https://www.juhe.cn/docs/api/id/66">https://www.juhe.cn/docs/api/id/66</a></p>
<p>老黄历接口：</p>
<p><a href="https://www.juhe.cn/docs/api/id/65">https://www.juhe.cn/docs/api/id/65</a></p>
<p>网站安全检测接口：</p>
<p><a href="https://www.juhe.cn/docs/api/id/19">https://www.juhe.cn/docs/api/id/19</a></p>
<p>手机固话来电显示接口：</p>
<p><a href="https://www.juhe.cn/docs/api/id/72">https://www.juhe.cn/docs/api/id/72</a></p>
<p>基金财务数据接口：</p>
<p><a href="https://www.juhe.cn/docs/api/id/28">https://www.juhe.cn/docs/api/id/28</a></p>
<p>成语词典接口：</p>
<p><a href="https://www.juhe.cn/docs/api/id/157">https://www.juhe.cn/docs/api/id/157</a></p>
<p>新闻头条接口：</p>
<p><a href="https://www.juhe.cn/docs/api/id/235">https://www.juhe.cn/docs/api/id/235</a></p>
<p>IP 地址接口：</p>
<p><a href="https://www.juhe.cn/docs/api/id/1">https://www.juhe.cn/docs/api/id/1</a></p>
<p>问答机器人接口：</p>
<p><a href="https://www.juhe.cn/docs/api/id/112">https://www.juhe.cn/docs/api/id/112</a></p>
<p>汇率 API 接口：</p>
<p><a href="https://www.juhe.cn/docs/api/id/80">https://www.juhe.cn/docs/api/id/80</a></p>
<p>电影票房接口：</p>
<p><a href="https://www.juhe.cn/docs/api/id/44">https://www.juhe.cn/docs/api/id/44</a></p>
<p>万年历 API 接口：</p>
<p><a href="https://www.juhe.cn/docs/api/id/177">https://www.juhe.cn/docs/api/id/177</a></p>
<p>NBA 赛事接口：</p>
<p><a href="https://www.juhe.cn/docs/api/id/92">https://www.juhe.cn/docs/api/id/92</a></p>
<p>豆瓣开放</p>
<p><a href="https://developers.douban.com/wiki/">https://developers.douban.com/wiki/</a></p>
<p>淘宝开放平台</p>
<p><a href="http://open.taobao.com/">http://open.taobao.com/</a></p>
<p>图灵语音</p>
<p><a href="http://www.tuling123.com/help/h_cent_andriodsdk.jhtml">http://www.tuling123.com/help/h_cent_andriodsdk.jhtml</a></p>
<p>讯飞语音</p>
<p><a href="http://www.xfyun.cn/robots/solution">http://www.xfyun.cn/robots/solution</a></p>
<p>马化腾的微信开放平台（对应的还有腾讯开放平台）</p>
<p><a href="https://open.weixin.qq.com/">https://open.weixin.qq.com/</a></p>
<p>融云 IM</p>
<p><a href="https://developer.rongcloud.cn/signin">https://developer.rongcloud.cn/signin</a></p>
<p>百度开发者中心</p>
<p><a href="http://developer.baidu.com/">http://developer.baidu.com/</a></p>
<p>人脸识别</p>
<p><a href="http://www.faceplusplus.com.cn/">http://www.faceplusplus.com.cn/</a></p>
<p>高德地图:</p>
<p><a href="http://lbs.amap.com/">http://lbs.amap.com/</a></p>
<p>蜻蜓 FM:</p>
<p><a href="http://open.qingting.fm">http://open.qingting.fm</a></p>
<h1 id="a-target_blank-hrefhttpmailqqcomcgi-binqm_sharetqm_mailmeemailk_h88fzp0_livfd8-g-styletext-decorationnone-意见反馈a"><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=k_H88fzp0_LivfD8-g" style="text-decoration:none;">✉ 意见反馈</a></h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日一句]]></title>
        <id>https://roboz-up.github.io/post/mei-ri-yi-ju/</id>
        <link href="https://roboz-up.github.io/post/mei-ri-yi-ju/">
        </link>
        <updated>2020-05-04T06:59:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="20200504">2020.05.04</h1>
<p>生命的长度我是拓展不了了，但是我可以试着把它拉宽一点，这样子就能印出彩虹了。</p>
<h1 id="20200505">2020.05.05</h1>
<p>心若不动，风又奈何。</p>
<h1 id="20200506">2020.05.06</h1>
<p>松花酿酒，春水煎茶。</p>
<h1 id="20200507">2020.05.07</h1>
<p>我以为我和别人不一样,其实我只是另外一种形式的奴隶。</p>
<h1 id="20200508">2020.05.08</h1>
<p>我讨厌一会充满希望一会变成绝望，我们已经受够了期待落空了。</p>
<h1 id="20200509">2020.05.09</h1>
<p>春去夏又来，而某些人和事，不再回来。留下记忆终将随风飘散，陪着一同逝去的青春。</p>
<h1 id="20200510">2020.05.10</h1>
<p>我相信所有被我遗忘的美好，一定还在这世上的某个角落，也相信总有一天，走过很长的生命，遇见美好，春暖花开！</p>
<h1 id="20200511">2020.05.11</h1>
<p>征服可能会受挫，但好奇从未停息。</p>
<h1 id="20200512">2020.05.12</h1>
<p>要是有些事我没说，你别以为是忘了，我什么也没忘，但是有些事只适合收藏。</p>
<h1 id="20200513">2020.05.13</h1>
<p>生活越来越压抑，你变得越来越不像自己，玫瑰你在哪里，你总是喜欢抓不住的东西。</p>
<h1 id="20200514">2020.05.14</h1>
<p>黎明之前总有一段时间特别黑。</p>
<h1 id="20200515">2020.05.15</h1>
<p>相思一夜梅花发，忽到窗前疑是君。</p>
<h1 id="20200516">2020.05.16</h1>
<p>心中是寂然的轰鸣，像是某种巨大的坍塌。</p>
<h1 id="20200517">2020.05.17</h1>
<p>人总是害怕死亡，却殊不知有出生之时必有死亡之日。</p>
<h1 id="20200518">2020.05.18</h1>
<p>要对得起你的苦难。</p>
<h1 id="20200519">2020.05.19</h1>
<p>人生，一半是现实，一半是梦想。一念花开，一念花落。 ​​​​</p>
<h1 id="20200520">2020.05.20</h1>
<p>即便如此我也会前进的，哪怕是这令人头昏眼花的夜… ​​​​</p>
<h1 id="20200521">2020.05.21</h1>
<p>最怕一生碌碌无为，还安慰自己平凡可贵。 ​​​​</p>
<h1 id="a-target_blank-hrefhttpmailqqcomcgi-binqm_sharetqm_mailmeemailk_h88fzp0_livfd8-g-styletext-decorationnone-意见反馈a"><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=k_H88fzp0_LivfD8-g" style="text-decoration:none;">✉ 意见反馈</a></h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[笔记：仿真程序设计]]></title>
        <id>https://roboz-up.github.io/post/bi-ji-fang-zhen-cheng-xu-she-ji/</id>
        <link href="https://roboz-up.github.io/post/bi-ji-fang-zhen-cheng-xu-she-ji/">
        </link>
        <updated>2020-03-25T08:46:00.000Z</updated>
        <content type="html"><![CDATA[<p>⏰最后更新时间：2020.5.1</p>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2020/05/01/Ht5CPFWogxbkGTE.png" alt="" loading="lazy"></figure>
<h1 id="第一章-matlab基础知识">第一章 MATLAB基础知识</h1>
<h2 id="帮助命令">帮助命令</h2>
<h3 id="help命令">help命令</h3>
<p><strong>help</strong>   <strong>函数名</strong></p>
<p>可以通过help加函数名来显示该函数的帮助说明。</p>
<p>help命令是查询函数语法的最基本方法，查询信息直接显示在命令窗口。在命令窗口中直接输入help命令将会显示当前帮助系统中所包含的所有项目，即搜索路径中所有的目录名称。</p>
<h3 id="lookfor命令">lookfor命令</h3>
<p><strong>lookfor</strong>   <strong>关键词</strong></p>
<p>lookfor命令可以帮助用户查找关键词。</p>
<h3 id="其他帮助命令">其他帮助命令</h3>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">命令功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">demo</td>
<td style="text-align:center">运行演示程序</td>
</tr>
<tr>
<td style="text-align:center">tour</td>
<td style="text-align:center">运行漫游程序</td>
</tr>
<tr>
<td style="text-align:center">doc</td>
<td style="text-align:center">在帮助浏览器中显示指定函数的参考信息</td>
</tr>
<tr>
<td style="text-align:center">what</td>
<td style="text-align:center">列出当前目录下的M文件、MEX文件、MET文件</td>
</tr>
<tr>
<td style="text-align:center">which</td>
<td style="text-align:center">显示指定函数或文件的路径</td>
</tr>
<tr>
<td style="text-align:center">helpbrowser</td>
<td style="text-align:center">打开帮助内的浏览器</td>
</tr>
<tr>
<td style="text-align:center">helpdesk</td>
<td style="text-align:center">运行HTML格式的帮助面板(Help Desk)</td>
</tr>
<tr>
<td style="text-align:center">helpwin</td>
<td style="text-align:center">打开帮助内的浏览器</td>
</tr>
<tr>
<td style="text-align:center">exist</td>
<td style="text-align:center">查找指定变量或函数的存在性</td>
</tr>
<tr>
<td style="text-align:center">web</td>
<td style="text-align:center">显示指定的网络页面</td>
</tr>
</tbody>
</table>
<h2 id="matlab的变量和数据操作">MATLAB的变量和数据操作</h2>
<h3 id="变量与赋值">变量与赋值</h3>
<h4 id="变量命名">变量命名</h4>
<p>在MATLAB中，变量名是以字母开头，后接字母、数字或下画线的字符序列，最多63个字符。<br>
在MATLAB中，变量名区分字母的大小写。</p>
<h4 id="赋值语句">赋值语句</h4>
<p>MATLAB赋值语句有两种格式：<br>
（1）变量=表达式；<br>
（2）表达式<br>
在第1种语句形式下，MATLAB将右边表达式的值赋给左边的变量；<br>
而在第2种语句形式下，将表达式的值赋给MATLAB的预定义变量ans。</p>
<p>在语句的最后加分号，那么，MATLAB仅仅执行赋值操作，不再显示运算的结果。</p>
<h4 id="注释以开头">注释以%开头</h4>
<h3 id="常用预定义变量">常用预定义变量</h3>
<table>
<thead>
<tr>
<th style="text-align:center">预定义变量</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">预定义变量</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ans</td>
<td style="text-align:center">计算结果的默认赋值变量</td>
<td style="text-align:center">nargin</td>
<td style="text-align:center">函数输入参数个数</td>
</tr>
<tr>
<td style="text-align:center">eps</td>
<td style="text-align:center">机器零阈值</td>
<td style="text-align:center">nargout</td>
<td style="text-align:center">函数输出参数个数</td>
</tr>
<tr>
<td style="text-align:center">pi</td>
<td style="text-align:center">圆周率的近似值</td>
<td style="text-align:center">realmax</td>
<td style="text-align:center">最大正实数</td>
</tr>
<tr>
<td style="text-align:center">i，j</td>
<td style="text-align:center">虚数单位</td>
<td style="text-align:center">realmin</td>
<td style="text-align:center">最小正实数</td>
</tr>
<tr>
<td style="text-align:center">inf，Inf</td>
<td style="text-align:center">无穷大。如1/0的结果</td>
<td style="text-align:center">lasterr</td>
<td style="text-align:center">存放最新的错误信息</td>
</tr>
<tr>
<td style="text-align:center">NaN，nan</td>
<td style="text-align:center">非数。如0/0、inf/inf的结果</td>
<td style="text-align:center">lastwarn</td>
<td style="text-align:center">存放最新的警告信息</td>
</tr>
</tbody>
</table>
<h3 id="内存变量文件">内存变量文件</h3>
<p>利用MAT文件可以把当前MATLAB工作空间中的一些有用变量长久地保留下来。<br>
MAT文件是MATLAB保存数据的一种标准格式二进制文件，扩展名是.mat。</p>
<ul>
<li><strong>-append</strong>选项控制将变量追加到MAT文件中。</li>
<li><strong>-ascii</strong>选项使文件以ASCII格式处理，省略该选项时文件以二进制格式处理。</li>
</ul>
<h4 id="mat文件的生成">MAT文件的生成</h4>
<p>save  文件名 [变量名表]  [-append][-ascii]</p>
<h4 id="mat文件的装入">MAT文件的装入</h4>
<p>load  文件名  [变量名表]  [-ascii]</p>
<h2 id="数据输出格式">数据输出格式</h2>
<p><strong>format 格式符</strong><br>
<strong>注意</strong>，format命令只影响数据输出格式，不影响数据的计算和存储。</p>
<table>
<thead>
<tr>
<th style="text-align:center">格式符</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">输出小数点后4位，最多不超过7位有效数字。对于大于1000的实数，用5位有效数字的科学计数形式输出</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">15位有效数字形式输出</td>
</tr>
<tr>
<td style="text-align:center">short e</td>
<td style="text-align:center">5位有效数字的科学计数形式输出</td>
</tr>
<tr>
<td style="text-align:center">long e</td>
<td style="text-align:center">15位有效数字的科学计数形式输出</td>
</tr>
<tr>
<td style="text-align:center">short g</td>
<td style="text-align:center">从short和short e中自动选择最佳输出方式</td>
</tr>
<tr>
<td style="text-align:center">long g</td>
<td style="text-align:center">从long和long e中自动选择最佳输出方式</td>
</tr>
<tr>
<td style="text-align:center">rat</td>
<td style="text-align:center">近似有理数表示</td>
</tr>
<tr>
<td style="text-align:center">hex</td>
<td style="text-align:center">十六进制表示</td>
</tr>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">正数、负数、零分别用+、-、空格表示</td>
</tr>
<tr>
<td style="text-align:center">bank</td>
<td style="text-align:center">银行格式，以元、分表示</td>
</tr>
<tr>
<td style="text-align:center">compact</td>
<td style="text-align:center">输出变量之间没有空行</td>
</tr>
<tr>
<td style="text-align:center">loose</td>
<td style="text-align:center">输出变量之间有空行</td>
</tr>
</tbody>
</table>
<h2 id="matlab矩阵及其基本运算">MATLAB矩阵及其基本运算</h2>
<h3 id="矩阵的生成">矩阵的生成</h3>
<p>在MATLAB中，生成矩阵时无须对矩阵的维数和类型进行说明，MATLAB会根据用户所输入的内容自动进行配置。</p>
<h4 id="直接输入法">直接输入法</h4>
<p>将矩阵的所有元素用<strong>方括号</strong>括起来，按矩阵行的顺序输入各元素，同一行的各元素之间用<strong>空格或逗号</strong>分隔，不同行的元素之间用<strong>分号</strong>分隔。</p>
<h4 id="利用m文件建立矩阵">利用M文件建立矩阵</h4>
<p>对于比较大且比较复杂的矩阵，可以为它专门建立一个M文件</p>
<h4 id="利用数据文件建立指定矩阵">利用数据文件建立指定矩阵</h4>
<p>用户能够通过load命令，将外部数据文件中的内容调入到工作空间中创建矩阵，外部文件的扩展名为.dat。</p>
<h4 id="利用已建好的矩阵建立更大的矩阵">利用已建好的矩阵建立更大的矩阵</h4>
<h3 id="冒号表达式">冒号表达式</h3>
<p>在MATLAB中利用冒号可以产生行向量。<br>
冒号表达式的一般格式为</p>
<p>a : b : c</p>
<p>其中，a为初始值，b为步长，c为终止值（c &gt; a）。<br>
冒号表达式可产生一个由a开始到c结束，以步长b自增的行向量。</p>
<p>在MATLAB中，还可以用linspace函数产生行向量。<br>
其调用格式为</p>
<p>linspace(a,b,n)</p>
<p>其中a和b是生成向量的第1个和最后一个元素，n是元素总数。<br>
当n省略时，自动产生100个元素。</p>
<h3 id="矩阵的拆分">矩阵的拆分</h3>
<h4 id="矩阵元素">矩阵元素</h4>
<p>对矩阵的单个元素操作。<br>
例如，如果想将矩阵A的第a行第b列的元素赋为c，则可以通过下面语句来完成：<br>
A(a,b)=c<br>
这时将只改变该元素的值，而不影响其他元素的值。</p>
<p>在MATLAB中，也可以采用矩阵元素的序号来引用矩阵元素。矩阵元素的序号就是相应元素在内存中的排列顺序。矩阵元素按列编号，先第1列，再第2列，依次类推。<br>
例如：<br>
A=[10,20,30;40,50,60];<br>
A(3)的元素是20。</p>
<p>序号（Index）与下标（Subscript）是一一对应的，以m × n矩阵A为例，矩阵元素A(i, j)的序号为(j−1)*m + i。其相互转换关系也可利用sub2ind和ind2sub函数求得。</p>
<ul>
<li>size(A) 函数返回包含两个元素的向量，分别是矩阵A的行数和列数</li>
<li>length(A) 给出行数和列数中的较大者,即length(A)=max(size(A))</li>
<li>ndims(A) 给出A的维数</li>
<li>reshape(A,m,n) 函数在矩阵总元素保持不变的前提下，将矩阵A重新排列成m*n的二维矩阵。</li>
</ul>
<h4 id="矩阵拆分">矩阵拆分</h4>
<h5 id="利用冒号表达式获得子矩阵">利用冒号表达式获得子矩阵</h5>
<p>① A(m,n)表示取A矩阵第m行、第n列的元素，A(m,:)表示取A矩阵第m行的全部元素，A(:,n)表示取A矩阵的第n列全部元素。<br>
② A(m1:m2,:)表示取A矩阵第m1～m2行的全部元素，A(:,n1:n2)表示取A矩阵第n1～n2列的全部元素，A(m1:m2,n1:n2)表示取A矩阵第m1～m2行内，并在第n1～n2列中的所有元素。<br>
③ A(:)将矩阵A每一列元素堆叠起来，成为一个列向量。</p>
<h5 id="end表示某一维的末尾元素下标">end表示某一维的末尾元素下标</h5>
<h5 id="利用空矩阵删除矩阵的元素">利用空矩阵删除矩阵的元素</h5>
<p>在MATLAB中，空矩阵是指无任何元素的矩阵，表示形式为[]。<br>
给变量x赋空矩阵的语句为<br>
x=[]<br>
将某些元素从矩阵中删除，采用将其置为空矩阵的方法就是一种有效的方法。<br>
例如：<br>
A=[1 2 3 4 5 6;7 8 9 10 11 12;13 14 15 16 17 18];<br>
A(:,[2 4])=[]<br>
其中第2条命令将删除A的第2列和第4列元素。</p>
<h3 id="算术运算">算术运算</h3>
<h4 id="基本算术运算">基本算术运算</h4>
<p>MATLAB的基本算术运算有：+（加）、−（减）、*（乘）、/（右除）、\（左除）、^（乘方）。</p>
<h5 id="矩阵加减运算">矩阵加减运算</h5>
<p>运算规则是：若<strong>A和B矩阵的维数相同</strong>，则可以执行矩阵的加减运算，A和B矩阵的相应元素相加减。如果A与B的维数不相同，则MATLAB将给出错误信息，提示用户两个矩阵的维数不匹配。<br>
一个标量也可以和其他不同维数的矩阵进行加减运算。例如：<br>
x=[2,-1,0;3,2,-4];<br>
y=x-1;<br>
y=y+x</p>
<h5 id="矩阵乘法">矩阵乘法</h5>
<p>矩阵A和B进行乘法运算，要求<strong>A的列数与B的行数相等</strong>，或称A和B两矩阵维数相容。如果两者的维数不相容，则将给出错误信息，提示用户两个矩阵是不可乘的。例如：<br>
A=[1,2,3;4,5,6];<br>
B=A*A<br>
??? Error using ==&gt; mtimes<br>
Inner matrix dimensions must agree.<br>
在MATLAB中，还可以进行矩阵和标量相乘，标量可以是乘数也可以是被乘数。<strong>矩阵和标量相乘是矩阵中的每个元素与此标量相乘。</strong></p>
<h5 id="矩阵除法">矩阵除法</h5>
<p>在MATLAB中，有两种矩阵除法运算：\和/，分别表示左除和右除。如果A矩阵是非奇异方阵，则A\B和B/A运算可以实现。A\B等效于A的逆左乘B矩阵，也就是inv(A)<em>B，而B/A等效于A矩阵的逆右乘B矩阵，也就是B</em>inv(A)。</p>
<ul>
<li>inv(矩阵名) 矩阵求逆</li>
</ul>
<h5 id="矩阵的乘方">矩阵的乘方</h5>
<p>一个矩阵的乘方运算可以表示成A^x，要求A为方阵，x为标量。</p>
<h4 id="点运算">点运算</h4>
<p>两矩阵进行点运算是指它们的<strong>对应元素</strong>进行相关运算，要求两矩阵的维参数相同。点运算符有.*、./、.\和.^。</p>
<p>如果A、B两矩阵具有相同的维数，则A./B表示A矩阵除以B矩阵的对应元素。B.\A等价于A./B。 （与矩阵的左除、右除不同）</p>
<p>若两个矩阵维数一致，则A.^B表示两矩阵对应元素进行乘方运算。其中指数和底数也可以是标量。</p>
<h3 id="matlab常用数学函数">MATLAB常用数学函数</h3>
<table>
<thead>
<tr>
<th style="text-align:center">函数名</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">函数名</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">sin</td>
<td style="text-align:center">正弦函数</td>
<td style="text-align:center">exp</td>
<td style="text-align:center">自然指数函数</td>
</tr>
<tr>
<td style="text-align:center">cos</td>
<td style="text-align:center">余弦函数</td>
<td style="text-align:center">pow2</td>
<td style="text-align:center">2的幂</td>
</tr>
<tr>
<td style="text-align:center">tan</td>
<td style="text-align:center">正切函数</td>
<td style="text-align:center">abs</td>
<td style="text-align:center">绝对值函数</td>
</tr>
<tr>
<td style="text-align:center">asin</td>
<td style="text-align:center">反正弦函数</td>
<td style="text-align:center">angle</td>
<td style="text-align:center">复数的俯角</td>
</tr>
<tr>
<td style="text-align:center">acos</td>
<td style="text-align:center">反余弦函数</td>
<td style="text-align:center">real</td>
<td style="text-align:center">复数的实部</td>
</tr>
<tr>
<td style="text-align:center">atan</td>
<td style="text-align:center">反正切函数</td>
<td style="text-align:center">imag</td>
<td style="text-align:center">复数的虚部</td>
</tr>
<tr>
<td style="text-align:center">sinh</td>
<td style="text-align:center">双曲正弦函数</td>
<td style="text-align:center">conj</td>
<td style="text-align:center">复数共轭运算</td>
</tr>
<tr>
<td style="text-align:center">cosh</td>
<td style="text-align:center">双曲余弦函数</td>
<td style="text-align:center">rem</td>
<td style="text-align:center">求余数或模运算</td>
</tr>
<tr>
<td style="text-align:center">tanh</td>
<td style="text-align:center">双曲正切函数</td>
<td style="text-align:center">mod</td>
<td style="text-align:center">模除求余</td>
</tr>
<tr>
<td style="text-align:center">asinh</td>
<td style="text-align:center">反双曲正弦函数</td>
<td style="text-align:center">fix</td>
<td style="text-align:center">向零方向取整</td>
</tr>
<tr>
<td style="text-align:center">acosh</td>
<td style="text-align:center">反双曲余弦函数</td>
<td style="text-align:center">floor</td>
<td style="text-align:center">不大于自变量的最大整数</td>
</tr>
<tr>
<td style="text-align:center">atanh</td>
<td style="text-align:center">反双曲正切函数</td>
<td style="text-align:center">ceil</td>
<td style="text-align:center">不小于自变量的最小整数</td>
</tr>
<tr>
<td style="text-align:center">sqrt</td>
<td style="text-align:center">平方根函数</td>
<td style="text-align:center">round</td>
<td style="text-align:center">四舍五入到最邻近的整数</td>
</tr>
<tr>
<td style="text-align:center">log</td>
<td style="text-align:center">自然对数函数</td>
<td style="text-align:center">sign</td>
<td style="text-align:center">符号函数</td>
</tr>
<tr>
<td style="text-align:center">log10</td>
<td style="text-align:center">常用对数函数</td>
<td style="text-align:center">gcd</td>
<td style="text-align:center">最大公因子</td>
</tr>
<tr>
<td style="text-align:center">log2</td>
<td style="text-align:center">以2为底的对数函数</td>
<td style="text-align:center">lcm</td>
<td style="text-align:center">最小公倍数</td>
</tr>
</tbody>
</table>
<p>函数使用说明：<br>
（1）函数的自变量规定为矩阵变量，运算法则是将函数逐项作用于矩阵的元素上，因而运算的结果是一个与自变量同维数的矩阵。<br>
（2）abs函数可以求实数的绝对值、复数的模、字符串的ASCII码值。<br>
（3）用于取整的函数有fix、floor、ceil、round，要注意它们的区别。<br>
（4）rem与mod函数的区别。rem(x,y)和mod(x,y)要求x,y必须为相同大小的实矩阵或为标量。当y≠0时，rem(x, y) = x − y.<em>fix(x ./ y)，而mod(x,y) = x − y .</em> floor(x ./ y)，当y = 0时，rem(x, 0) = NaN，而mod(x,0) = x。显然，当x，y同号时，rem(x,y)与mod(x,y)相等。rem(x,y)的符号与x相同，而mod(x, y)的符号与y相同。</p>
<h3 id="关系运算">关系运算</h3>
<p>MATLAB提供了6种关系运算符：&lt;（小于）、&lt;=（小于或等于）、&gt;（大于）、&gt;=（大于或等于）、= =（等于）、～=（不等于）。<br>
（1）当两个比较量是标量时，直接比较两数的大小。若关系成立，关系表达式结果为1，否则为0。<br>
（2）当参与比较的量是两个维数相同的矩阵时，比较是对两矩阵相同位置的元素按标量关系运算规则逐个进行，并给出元素的比较结果。最终的关系运算的结果是一个维数与原矩阵相同的矩阵，它的元素由0或1组成。<br>
（3）当参与比较的一个是标量，而另一个是矩阵时，则把标量与矩阵的每一个元素按标量关系运算规则逐个比较，并给出元素比较结果。最终的运算结果是一个维数与矩阵相同的矩阵，它的元素由0或1组成。</p>
<h3 id="逻辑运算">逻辑运算</h3>
<p>MATLAB提供了3种逻辑运算符：&amp;（与）、|（或）和～（非）。此外，MATLAB还提供了4个逻辑运算函数：and(a,b)、or(a,b)、not(a)和xor(a,b)。<br>
在逻辑运算中，确认非零元素为真，用1表示；零元素为假，用0表示。设参与逻辑运算的是两个标量a和b，那么，逻辑运算符和逻辑运算函数的含义如下。</p>
<ul>
<li>a&amp;b或函数and(a, b)表示a和b作逻辑<strong>与</strong>运算，当a、b全为非零时，运算结果为1，否则为0。</li>
<li>a|b或函数or(a, b)表示a和b作逻辑<strong>或</strong>运算，当a、b中只要有一个非零，运算结果为1。</li>
<li>～a和函数not(a)表示对a作逻辑<strong>非</strong>运算，当a是零时，运算结果为1；当a非零时，运算结果为0。</li>
<li>函数xor(a, b)表示a和b作逻辑<strong>异或</strong>运算，当a、b的值不同时，运算结果为1，否则运算结果为0。</li>
</ul>
<p>（1）若参与逻辑运算的是两个同维矩阵，那么运算将对矩阵相同位置上的元素按标量规则逐个进行。最终运算结果是一个与原矩阵同维的矩阵，其元素由1或0组成。<br>
（2）若参与逻辑运算的一个是标量，一个是矩阵，那么运算将在标量与矩阵中的每个元素之间按标量规则逐个进行。最终运算结果是一个与矩阵同维的矩阵，其元素由1或0组成。<br>
（3）逻辑非是单目运算符，也服从矩阵运算规则。</p>
<h3 id="优先级">优先级</h3>
<p>在算术、关系、逻辑运算中，算术运算优先级最高，逻辑运算优先级最低。</p>
<h3 id="关系与逻辑运算函数">关系与逻辑运算函数</h3>
<table>
<thead>
<tr>
<th style="text-align:center">函数名</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">all</td>
<td style="text-align:center">若向量的所有元素为零，则结果为1</td>
</tr>
<tr>
<td style="text-align:center">any</td>
<td style="text-align:center">向量中任意一个元素非零，都给出结果1</td>
</tr>
<tr>
<td style="text-align:center">exist</td>
<td style="text-align:center">检测变量在工作空间是否存在，若存在结果为1；否则为0</td>
</tr>
<tr>
<td style="text-align:center">find</td>
<td style="text-align:center">找出向量或矩阵中非零元素的位置</td>
</tr>
<tr>
<td style="text-align:center">isempty</td>
<td style="text-align:center">若被查变量是空阵，则结果为1</td>
</tr>
<tr>
<td style="text-align:center">isglobal</td>
<td style="text-align:center">若被查变量是全局变量，则结果为1</td>
</tr>
<tr>
<td style="text-align:center">isinf</td>
<td style="text-align:center">若元素是±inf，则结果矩阵相应位置元素取1，否则取0</td>
</tr>
<tr>
<td style="text-align:center">isnan</td>
<td style="text-align:center">若元素是nan，则结果矩阵相应位置元素取1，否则取0</td>
</tr>
<tr>
<td style="text-align:center">isfinite</td>
<td style="text-align:center">若元素值大小有限制，则结果矩阵相应位置元素取1，否则取0</td>
</tr>
<tr>
<td style="text-align:center">issparse</td>
<td style="text-align:center">若变量是稀疏矩阵，则结果矩阵相应位置元素取1，否则取0</td>
</tr>
<tr>
<td style="text-align:center">isstr</td>
<td style="text-align:center">若变量是字符串，则结果矩阵相应位置元素取1，否则取0</td>
</tr>
</tbody>
</table>
<p><strong>INF</strong>表示“无穷大”，是infinite的缩写。<strong>NAN</strong>表示“无效数字”，是Not a number的缩写。<br>
在矩阵中，若数值为0的元素数目远远多于非0元素的数目，并且非0元素分布没有规律时，则称该矩阵为<strong>稀疏矩阵</strong>；与之相反，若非0元素数目占大多数时，则称该矩阵为<strong>稠密矩阵</strong>。</p>
<h2 id="字符串">字符串</h2>
<p>字符串的每个字符都是字符矩阵的一个元素。其构建方式是通过<strong>单撇号</strong>括起来的字符序列来实现的。<br>
MATLAB将一个字符串当作一个<strong>行向量</strong>，每个元素对应一个字符，其标识方法和数值向量相同。<br>
<strong>多行字符串要求各行字符数要相等</strong><br>
字符串是以<strong>ASCII</strong>形式存储的。abs和double函数都可以用来获取字符串矩阵所对应的ASCII数值矩阵。相反，char函数可以把ASCII矩阵转换为字符串矩阵。</p>
<p>把字符串的内容作为对应的MATLAB语句来执行。<br>
<strong>eval(t)</strong><br>
其中t为字符串。</p>
<h3 id="字符串处理函数">字符串处理函数</h3>
<table>
<thead>
<tr>
<th style="text-align:center">函数名</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">函数名</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">setstr</td>
<td style="text-align:center">将ASCII码值转换为字符</td>
<td style="text-align:center">strcat</td>
<td style="text-align:center">用于字符串的连接</td>
</tr>
<tr>
<td style="text-align:center">findstr</td>
<td style="text-align:center">查找匹配的字符串所在的位置</td>
<td style="text-align:center">strcmp</td>
<td style="text-align:center">用于字符串的比较</td>
</tr>
<tr>
<td style="text-align:center">mat2str</td>
<td style="text-align:center">将矩阵转换为字符串</td>
<td style="text-align:center">strrep</td>
<td style="text-align:center">替换匹配的字符串</td>
</tr>
<tr>
<td style="text-align:center">num2str</td>
<td style="text-align:center">将数值转换为字符串</td>
<td style="text-align:center">isspace</td>
<td style="text-align:center">判断是否为空格</td>
</tr>
<tr>
<td style="text-align:center">int2str</td>
<td style="text-align:center">将整数转换为字符串</td>
<td style="text-align:center">ischar</td>
<td style="text-align:center">判断是否为字符</td>
</tr>
<tr>
<td style="text-align:center">str2num</td>
<td style="text-align:center">将数字型字符串转换为数值</td>
<td style="text-align:center">isletter</td>
<td style="text-align:center">判断是否为字母</td>
</tr>
</tbody>
</table>
<p>disp 显示数组。disp函数的自变量是一个长字符串。</p>
<p><strong>字符串写法的注意事项：</strong><br>
（1）若字符串中的字符含有单撇号，则该单撇号字符应用两个单撇号来表示。<br>
（2）可以用字符串向量的形式连接多个字符串，即用中括号括起来。</p>
<h1 id="第二章-matlab程序设计">第二章 MATLAB程序设计</h1>
<h2 id="m文件的分类">M文件的分类</h2>
<p>M文件可以根据调用方式的不同分为两类：<strong>命令文件</strong>（Script File）和<strong>函数文件</strong>（Function File）。扩展名均为.m。<br>
主要分别如下：<br>
（1）命令文件没有输入参数，也不返回输出参数；而函数文件可以带输入参数，也可返回输出参数。<br>
（2）命令文件对MATLAB工作空间中的变量进行操作，文件中所有命令的执行结果也完全返回到工作空间中；而函数文件中定义的变量为局部变量，当函数文件执行完毕时，这些变量被清除。<br>
（3）命令文件可以直接运行，在MATLAB命令窗口输入命令文件的名字，就会顺序执行命令文件中的命令；而函数文件不能直接运行，而要以函数调用的方式来调用它。</p>
<h2 id="程序控制结构">程序控制结构</h2>
<p>顺序结构、选择结构、循环结构</p>
<h3 id="顺序结构">顺序结构</h3>
<p>顺序结构是指按照程序中语句的排列顺序依次执行，一般涉及数据的输入、数据的计算或处理、数据的输出等内容。</p>
<h4 id="数据的输入">数据的输入</h4>
<p>从键盘输入数据，则可以使用input函数来进行，该函数的调用格式为<br>
A=input（提示信息，选项）；<br>
其中，“提示信息”为一个字符串，用于提示用户输入什么样的数据。<br>
如果在input函数调用时采用's'选项，则允许用户输入一个字符串。</p>
<h4 id="数据的输出">数据的输出</h4>
<p>MATLAB提供的命令窗口输出函数主要有disp函数，其调用格式为<br>
disp（输出项）<br>
其中，输出项既可以为字符串，也可以为矩阵。</p>
<h4 id="程序的暂停">程序的暂停</h4>
<p>当程序运行时，为了查看程序的中间结果或者观看输出的图形，有时需要暂停程序的执行。这时可以使用pause函数，其调用格式为<br>
pause（延迟秒数)<br>
如果省略延迟时间，则将暂停程序，直到用户按任一键后程序继续执行。<br>
若要强行中止程序的运行可使用Ctrl+C组合键。</p>
<h3 id="选择结构">选择结构</h3>
<p>选择结构是根据给定的条件成立或不成立，分别执行不同的语句。（if、swich、try）</p>
<h4 id="if语句">if语句</h4>
<h5 id="单分支if语句">单分支if语句：</h5>
<p>if  条件<br>
语句块<br>
end</p>
<p>当条件成立时，则执行语句组，执行完之后继续执行if语句的后继语句，若条件不成立，则直接执行if语句的后继语句。</p>
<h5 id="双分支if语句">双分支if语句：</h5>
<p>if  条件<br>
语句块1<br>
else<br>
语句块2<br>
end</p>
<p>当条件成立时，执行语句组1，否则执行语句组2，语句组1或语句组2执行后，再执行if语句的后继语句。</p>
<h5 id="多分支if语句">多分支if语句：</h5>
<p>if  条件1<br>
语句块1<br>
elseif  条件2<br>
语句块2<br>
……<br>
elseif  条件n<br>
语句块n<br>
else<br>
语句块n+1<br>
end</p>
<h4 id="switch语句">switch语句</h4>
<p>switch语句根据表达式的取值不同，分别执行不同的语句，其语句格式为</p>
<p>switch  表达式<br>
case  结果表1<br>
语句块1<br>
case  结果表2<br>
语句块2<br>
……<br>
case  结果表n<br>
语句块n<br>
otherwise<br>
语句块n+1<br>
end</p>
<p>switch子句后面的表达式应为一个标量或一个字符串，case子句后面的结果不仅可以为一个标量或一个字符串，而且还可以为一个将多个结果用大括号括起来的单元数据（Cell）。如果case子句后面的结果为一个单元数据，则表达式的值等于该单元数据中的某个元素时，执行相应的语句组。</p>
<h4 id="try语句">try语句</h4>
<p>try语句是一种试探性执行语句，为开发人员提供了一种捕获错误的机制，其语句格式为</p>
<p>try<br>
语句块1<br>
catch<br>
语句块2<br>
end</p>
<p>try语句先试探性执行语句块1，如果语句块1在执行过程中出现错误，则将错误信息赋给保留的lasterr变量，并转去执行语句块2。</p>
<h3 id="循环结构">循环结构</h3>
<p>循环是指按照给定的条件，重复执行指定的语句。</p>
<h4 id="for语句">for语句</h4>
<p>for语句的格式为<br>
for 循环变量=表达式1:表达式2:表达式3<br>
循环体语句<br>
end<br>
其中，表达式1的值为循环变量的初值，表达式2的值为步长，表达式3的值为循环变量的终值。步长为1时，表达式2可以省略。</p>
<p>for语句更一般的格式为<br>
for 循环变量=矩阵表达式<br>
循环体语句<br>
end<br>
执行过程是依次将矩阵的各列元素赋给循环变量，然后执行循环体语句，直至各列元素处理完毕。</p>
<h4 id="while语句">while语句</h4>
<p>while语句的一般格式为<br>
while(条件)<br>
循环体语句<br>
end</p>
<h4 id="break语句和continue语句">break语句和continue语句</h4>
<p>break语句用于终止循环的执行。当在循环体内执行到该语句时，程序将跳出循环，继续执行循环语句的下一语句。<br>
continue语句控制跳过循环体中的某些语句。当在循环体内执行到该语句时，程序将跳过循环体中所有剩下的语句，继续下一次循环。</p>
<h2 id="函数文件">函数文件</h2>
<h3 id="函数文件的基本结构">函数文件的基本结构</h3>
<p>函数文件由function语句引导，其基本结构为<br>
function 输出形参表=函数名（输入形参表)<br>
注释说明部分<br>
函数体语句<br>
其中，以function开头的一行为引导行，表示该M文件是一个函数文件。函数名的命名规则与变量名相同。输入形参为函数的输入参数，输出形参为函数的输出参数。当输出形参多于一个时，则应该用方括号括起来。<br>
说明：<br>
（1）函数文件名通常由函数名再加上扩展名.m组成，不过函数文件名与函数名也可以不相同。当两者不同时，MATLAB将忽略函数名而确认函数文件名，因此，<strong>调用时使用函数文件名。</strong><br>
（2）注释说明包括如下3部分内容。</p>
<ul>
<li>紧随函数文件引导行之后以%开头的第一注释行。这一行一般包括大写的函数文件名和函数功能简要描述，供lookfor关键词查询和help在线帮助用。</li>
<li>第一注释行及之后连续的注释行。通常包括函数输入输出参数的含义及调用格式说明等信息，构成全部在线帮助文本。</li>
<li>与在线帮助文本相隔一空行的注释行。包括函数文件编写和修改的信息，如作者、修改日期、版本等内容，用于软件档案管理。</li>
</ul>
<p>采用help命令或lookfor命令可以显示出注释说明部分的内容，其功能和一般MATLAB函数的帮助信息是一致的。<br>
利用help命令可查询fvector函数的注释说明：<br>
help fvector<br>
再用lookfor命令在第一注释行查询指定的关键词：<br>
lookfor fvector</p>
<p>（3）如果在函数文件中插入了return语句，则执行到该语句就结束函数的执行，程序流程转至调用该函数的位置。不写return语句，则执行完后，自动返回。</p>
<h3 id="函数调用">函数调用</h3>
<p>函数调用的一般格式为</p>
<p>[输出实参表]=函数名(输入实参表)</p>
<p>函数调用时各实参出现的顺序、个数，应与函数定义时形参的顺序、个数一致，否则会出错。函数调用时，先将实参传递给相应的形参，从而实现参数传递，然后再执行函数的功能。</p>
<p>在MATLAB中。函数可以嵌套调用，即一个函数可以调用别的函数，甚至调用自身。一个函数调用它自身称为函数的递归调用。</p>
<h3 id="函数参数的可调性">函数参数的可调性</h3>
<p>MATLAB在函数调用上有一个与一般高级语言不同之处，就是函数所传递参数数目的可调性。</p>
<p>在调用函数时，MATLAB用两个永久变量nargin和nargout分别记录调用该函数时的输入实参和输出实参的个数。只要在函数文件中包含这两个变量，就可以准确地知道该函数文件被调用时的输入/输出参数个数，从而决定函数如何进行处理。</p>
<h3 id="全局变量与局部变量">全局变量与局部变量</h3>
<p>在MATLAB中，函数文件中的变量是局部的，与其他函数文件及MATLAB工作空间相互隔离，即在一个函数文件中定义的变量不能被另一个函数文件引用。如果在若干函数中，都把某一变量定义为全局变量，那么这些函数将公用这一个变量。全局变量的作用域是整个MATLAB工作空间，即全程有效，所有的函数都可以对它进行存取和修改，定义全局变量是函数间传递信息的一种手段。</p>
<p>全局变量用global命令定义，格式为<br>
global 变量名</p>
<p>在函数文件里，全局变量的定义语句应放在变量使用之前，为了便于了解所有的全局变量，一般把全局变量的定义语句放在文件的前部。</p>
<p>全局变量在结构化程序设计中，很少使用。尤其是当程序较大，子程序较多时，全局变量会给程序调试和维护带来不便。因此不提倡使用。如果一定要使用全局变量，最好起一个能反应变量含义的名字，以免和其他变量混淆。</p>
<h1 id="第三章-图形绘制">第三章 图形绘制</h1>
<h2 id="二维曲线的绘制">二维曲线的绘制</h2>
<p>二维曲线是将平面坐标上的数据点连接起来的平面图形。除直角坐标系外，还可采用对数坐标、极坐标。数据点可以是向量、矩阵，类型可以是实型和虚型。</p>
<h3 id="绘制二维曲线">绘制二维曲线</h3>
<h4 id="plot函数">plot函数</h4>
<p>绘制直角坐标系下的二维曲线，用<br>
plot(x,y)<br>
其中x和y为大小相同的向量，分别用于存储x坐标和y坐标数据。</p>
<p>输入参数变化形式说明：<br>
（1）当x和y是同维矩阵时，配对的x、y按对应列元素为横、纵坐标分别绘制曲线，曲线条数等于矩阵的列数。<br>
（2）当plot函数只有一个输入参数时，即plot(y)<br>
若y是<strong>实型向量</strong>，则以该向量元素的下标为横坐标、元素值为纵坐标画出一条连续曲线；若y是<strong>复数向量</strong>，则分别以向量元素实部和虚部为横、纵坐标绘制一条曲线。若y是<strong>实矩阵</strong>，则按列绘制每列元素值相对其下标的曲线，曲线条数等于输入参数矩阵的列数；若y是<strong>复数矩阵</strong>，则按列分别以元素实部和虚部为横、纵坐标绘制多条曲线。<br>
3）当plot函数有多个输入参数，且都为向量时，即plot(x1,y1,x2,y2,…,xn,yn)<br>
其中，x1和y1，x2和y2，……，xn和yn分别组成一组向量对，每一组向量对的长度可以不同。每一向量对可以绘制出一条曲线，这样可以在同一坐标内绘制出多条曲线。</p>
<h4 id="具有两个纵坐标标度的图形">具有两个纵坐标标度的图形</h4>
<p>绘制出具有不同纵坐标标度的两个图形，可以使用plotyy绘图函数。这种图形有利于图形数据的对比分析。<br>
plotyy(x1,y1,x2,y2)<br>
其中，x1和y1对应一条曲线，x2和y2对应另一条曲线。横坐标的标度相同，纵坐标有两个，左纵坐标用于x1、y1数据对，右纵坐标用于x2、y2数据对。</p>
<h3 id="设置曲线样式">设置曲线样式</h3>
<p>MATLAB提供了一些绘图选项，用于确定所绘曲线的线型、颜色和数据点标记符号。</p>
<h4 id="线型选项">线型选项</h4>
<table>
<thead>
<tr>
<th style="text-align:center">选项</th>
<th style="text-align:center">线型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">实线(默认值)</td>
</tr>
<tr>
<td style="text-align:center">-.</td>
<td style="text-align:center">点画线</td>
</tr>
<tr>
<td style="text-align:center">--</td>
<td style="text-align:center">双画线</td>
</tr>
<tr>
<td style="text-align:center">:</td>
<td style="text-align:center">虚线</td>
</tr>
</tbody>
</table>
<h4 id="颜色选项">颜色选项</h4>
<table>
<thead>
<tr>
<th style="text-align:center">选项</th>
<th style="text-align:center">颜色</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">b</td>
<td style="text-align:center">蓝色</td>
</tr>
<tr>
<td style="text-align:center">g</td>
<td style="text-align:center">绿色</td>
</tr>
<tr>
<td style="text-align:center">r</td>
<td style="text-align:center">红色</td>
</tr>
<tr>
<td style="text-align:center">m</td>
<td style="text-align:center">品红色</td>
</tr>
<tr>
<td style="text-align:center">c</td>
<td style="text-align:center">青色</td>
</tr>
<tr>
<td style="text-align:center">y</td>
<td style="text-align:center">黄色</td>
</tr>
<tr>
<td style="text-align:center">k</td>
<td style="text-align:center">黑色</td>
</tr>
<tr>
<td style="text-align:center">w</td>
<td style="text-align:center">白色</td>
</tr>
</tbody>
</table>
<h4 id="符号标记选项">符号标记选项</h4>
<table>
<thead>
<tr>
<th style="text-align:center">选项</th>
<th style="text-align:center">符号标记</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">点</td>
</tr>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">加号</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">星号</td>
</tr>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">朝左三角符号</td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">朝右三角符号</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">朝上三角符号</td>
</tr>
<tr>
<td style="text-align:center">v</td>
<td style="text-align:center">朝下三角符号</td>
</tr>
<tr>
<td style="text-align:center">O</td>
<td style="text-align:center">圆圈</td>
</tr>
<tr>
<td style="text-align:center">X</td>
<td style="text-align:center">叉号</td>
</tr>
<tr>
<td style="text-align:center">s</td>
<td style="text-align:center">方块符</td>
</tr>
<tr>
<td style="text-align:center">d</td>
<td style="text-align:center">菱形符</td>
</tr>
<tr>
<td style="text-align:center">p</td>
<td style="text-align:center">五角星符</td>
</tr>
<tr>
<td style="text-align:center">h</td>
<td style="text-align:center">六角星符</td>
</tr>
</tbody>
</table>
<p>例如：“y:d”表示黄色虚线并用菱形符标记数据点。<br>
要设置曲线样式可以在plot函数中加绘图选项，其调用格式为<br>
plot(x1,y1,选项1,x2,y2,选项2,…,xn,yn,选项n)</p>
<h3 id="图形标注与坐标控制">图形标注与坐标控制</h3>
<h4 id="图形标注">图形标注</h4>
<p>在绘制图形的同时，可以对图形加上一些说明，如图形名称、坐标轴说明、图形某一部分的含义等，这些操作称为添加图形标注。有关图形标注函数的调用格式如下。</p>
<ul>
<li>title（图形名称）</li>
<li>xlabel（x轴说明）</li>
<li>ylabel（y轴说明）</li>
<li>text（x，y，图形说明）</li>
<li>legend（图例1，图例2，……）<br>
title和xlabel、ylabel 函数分别用于说明图形和坐标轴的名称。<br>
text函数是在（x，y）坐标处添加图形说明。<br>
添加文本说明也可用gtext命令，执行该命令时，十字坐标光标自动跟随鼠标移动，单击鼠标即可将文本放置在十字光标处，如命令gtext('cos(x)')，即可放置字符串cos（x）。<br>
legend函数用于绘制曲线所用线型、颜色或数据点标记图例，图例放置空白处，还可用鼠标将其拖动。</li>
</ul>
<h4 id="上标下标">上标下标</h4>
<p>如果想要在某个字符后面加上一个上标，则可以在该字符后面跟上一个^引导的字符串。<br>
如果想要在某个字符后面加上一个下标，则可以在该字符后面跟上一个_引导的字符串。</p>
<h4 id="坐标控制">坐标控制</h4>
<p>MATLAB会根据要绘制曲线数据的范围，自动选择合适的坐标刻度。但可以自定义，其函数的调用格式为：<br>
axis([xmin xmax ymin ymax])<br>
系统按照给出的坐标轴的最小值和最大值选择坐标系范围。<br>
axis函数的其他用法</p>
<ul>
<li>axis auto：使用默认设置。</li>
<li>axis equal：纵、横坐标轴采用等长刻度。</li>
<li>axis square：产生正方形坐标系（默认为矩形）。</li>
<li>axis on/off：显示/取消坐标轴。<br>
给坐标加网格线用grid命令来控制，加边框用box命令来控制。grid on/off命令控制是画还是不画网格线，box on/off命令控制是加还是不加边框线。</li>
</ul>
<h3 id="对函数自适应采用的绘图函数">对函数自适应采用的绘图函数</h3>
<p>使用plot函数绘图时，都是等间隔取点。<br>
fplot函数可自适应地对函数进行采样，调用格式为<br>
fplot(fname,lims,tol,选项)<br>
其中，fname为函数名，以字符串形式出现。它可以是由多个分量函数构成的行向量，分量函数可以是函数的直接字符串，也可以是内部函数名或函数文件名，但自变量都必须为x。lims为x、y的取值范围，以行向量形式出现，取二元向量[xmin，xmax]时，x轴的范围被人为确定，取四元向量[xmin，xmax，ymin，ymax]时，x、y轴的范围被人为确定。tol为相对允许误差，其系统默认值为2e − 3。选项定义与plot函数相同。</p>
<h3 id="多图形显示">多图形显示</h3>
<h4 id="图形窗口的分割">图形窗口的分割</h4>
<p>分割后的图形窗口由若干个绘图区组成，每一个绘图区可以建立独立的坐标系并绘制图形。同一图形窗口中的不同图形称为子图。MATLAB用subplot函数，将当前窗口分割成若干个绘图区。每个绘图区拥有独立坐标系，可以通过subplot函数激活，被激活的为活动区，所有绘图指令都只针对活动区。<br>
调用格式为：<br>
subplot(m,n,p)<br>
该函数将当前图形窗口分成m × n个绘图区，即每行n个，共m行，区号按行优先编号，且选定第p个区为当前活动区。在每一个绘图区允许以不同的坐标系单独绘制图形。</p>
<h4 id="图形叠加">图形叠加</h4>
<p>一般情况下，绘图命令每执行一次就刷新当前图形窗口，图形窗口原有图形将不复存在。若希望在已存在的图形上再叠加新的图形，可使用图形保持命令hold。hold on/off命令控制是保持原有图形还是刷新原有图形。</p>
<h3 id="其他坐标系">其他坐标系</h3>
<h4 id="对数坐标图形">对数坐标图形</h4>
<p>控制理论中的Bode图采用的就是对数坐标。MATLAB提供的函数调用格式为：</p>
<ul>
<li>semilogx（x1，y1，选项1，x2，y2，选项2，……）</li>
<li>semilogy（x1，y1，选项1，x2，y2，选项2，……）</li>
<li>loglog（x1，y1，选项1，x2，y2，选项2，……）<br>
其中，选项的定义与plot函数完全一致，所不同的是坐标轴的选取。semilogx函数使用半对数坐标，x轴为常用对数刻度，而y轴仍保持线性刻度。semilogy函数也使用半对数坐标，y轴为常用对数刻度，而x轴仍保持线性刻度。loglog函数使用全对数坐标，x、y轴均采用常用对数刻度。</li>
</ul>
<h4 id="极坐标图">极坐标图</h4>
<p>极坐标图用一个夹角和一段相对中心点—极点的距离来表示数据。MATLAB中用polar函数来绘制极坐标图，其调用格式为<br>
polar(theta,rho,选项)<br>
其中，theta为极坐标极角，rho为极坐标矢径，选项的内容与plot函数相似。</p>
<h3 id="其他二维图形">其他二维图形</h3>
<h4 id="二维统计分析图">二维统计分析图</h4>
<h5 id="条形图">条形图</h5>
<p>MATLAB中提供了多个函数可绘制各种条形图，bar函数绘制柱形图，barh函数绘制水平条形图，stem函数绘制杆图，errorbar函数绘制误差条图。下面以bar函数为例，说明条形图函数的用法。bar函数的基本用法与plot函数相似，其调用格式为<br>
bar(x,width,style)<br>
当x是m × n阶的矩阵时，绘制的条形图以分组或堆积的形式表现。矩阵中每一行元素绘制在一组中，每一列元素绘制在每组中相对应的位置上。其中，width设置条形的相对宽度和控制在一组内条形的间距，默认值为0.8，style指定条形的排列模式，类型有'group'（分组）和 'stack'（堆积），默认时采用'group'模式。</p>
<h5 id="饼图">饼图</h5>
<p>饼图能反映每一数值相对于总数值的大小。MATLAB中绘制饼图的函数是pie，其调用格式为<br>
pie(x,explode)<br>
pie函数使用x中的数据绘制一个饼图，x可以是向量或矩阵。explode是与x同等大小的向量或矩阵，与explode的非零值对应的部分将从饼图中心分离出来。默认explode时，饼图是一个整体。</p>
<h5 id="散点图">散点图</h5>
<p>散点图是数据点在直角坐标系平面上的分布图。MATLAB中绘制散点图的函数是scatter，其调用格式为<br>
scatter(x,y,s,c,'filled')<br>
其中，x、y、s和c为同等大小的向量。x和y用于定位数据点；s指定绘图点的大小，s也可以是一个标量，则所有数据点同等大小；c指定绘图所使用的色彩，c也可以是一个标量，所有数据点使用同一种颜色；'filled'表示填充绘图点，默认时，数据点是空心的。</p>
<h4 id="实心图">实心图</h4>
<p>实心图是将数据的起点和重点连成多边形，并填充颜色。绘制实心图的函数是fill，其调用格式为<br>
fill(x1,y1,选项1,x2,y2,选项2,…)<br>
fill函数按向量元素下标渐增次序依次用直线段连接x、y对应元素定义的数据点。假若这样连接所得折线不封闭，那么MATLAB将自动把该折线的首尾连接起来，构成封闭多边形，然后将多边形内部涂满指定的颜色。</p>
<h4 id="复数向量图">复数向量图</h4>
<p>MATLAB中除可以用plot函数绘制复数向量图外，还可用compass和feather函数，compass函数绘制围绕原点的罗盘图，feather函数绘制围绕x轴的羽毛图，其调用格式为<br>
compass(z)或compass(u,v)<br>
featuher(z)或faether(u,v)<br>
其中，z为复数向量，u、v分别为复数向量的实部和虚部。</p>
<h2 id="三维图形的绘制">三维图形的绘制</h2>
<h3 id="三维曲线">三维曲线</h3>
<p>最基本的三维图形函数为plot3，其调用格式为<br>
plot3(x1,y1,z1,选项1,x2,y2,z2,选项2,…,xn,yn,zn,选项n)<br>
其中，每一组x，y，z组成一组曲线的坐标参数，选项的定义和plot函数相同。当x、y、z是同维向量时，则x、y、z对应元素构成一条三维曲线；当x、y、z是同维矩阵时，则以x、y、z对应列元素绘制三维曲线，曲线条数等于矩阵列数。</p>
<h3 id="三维曲面">三维曲面</h3>
<p>MATLAB中绘制三维网格图和曲面图，先要生成在x−y平面的网格数据，再以一组z轴的数据对应到这个二维的网格，然后调用绘图函数绘制。</p>
<h4 id="产生三维数据">产生三维数据</h4>
<p>在MATLAB中产生三维图形数据的方法是：将x方向区间[a，b]分成m份，将y方向区间[c，d ]分成n份，由各划分点分别作平行于两坐标轴的直线，将区域[a，b] × [c，d ]分成m × n个小矩形，生成代表每一个小矩形顶点坐标的平面网格坐标矩阵，最后求对应网格坐标的Z矩阵。<br>
MATLAB中的meshgrid函数可以将向量转换为矩阵。meshgrid函数的调用格式为<br>
[X,Y]=meshgrid(x,y);<br>
其中x、y为向量。</p>
<h4 id="绘制三维曲面的函数">绘制三维曲面的函数</h4>
<p>MATLAB提供了mesh函数和surf函数来绘制三维曲面图。mesh函数用于绘制三维网格图；surf用于绘制三维曲面图，各线条之间的补面用颜色填充。surf函数和mesh函数的调用格式为</p>
<ul>
<li>mesh(x,y,z,c)</li>
<li>surf(x,y,z,c)<br>
一般情况下，x、y、z是维数相同的矩阵。x、y是网格坐标矩阵，z是网格点上的高度矩阵，c用于指定在不同高度下的颜色范围。c默认时，MATLAB认为c = z，即颜色的设定是正比于图形的高度的，这样就可以画出层次分明的三维图形。当x，y是向量时，要求x的长度等于z矩阵的列，y的长度等于z矩阵的行，x、y向量元素的组合构成网格点的x、y坐标，z坐标则取自z矩阵，然后绘制三维曲面图。</li>
<li>mesh:绘制三维网格图</li>
<li>meshc:绘制三维网格图，在xy平面上绘制曲面z轴方向的等高线</li>
<li>meshz:绘制三维网格图，在xy平面上绘制曲面底座</li>
</ul>
<h4 id="标准三维曲面">标准三维曲面</h4>
<h5 id="sphere函数">sphere函数</h5>
<p>sphere函数用于绘制三维球面，其调用格式为<br>
[x,y,z]=sphere(n)<br>
该函数将产生（n + 1）×（n + 1）矩阵x、y、z，采用这3个矩阵可以绘制出圆心位于原点、半径为1的单位球体。若在调用该函数时不带输出参数，则直接绘制所需球面。n决定了球面的圆滑程度，其默认值为20。若n值取得较小，则将绘制出多面体表面图。</p>
<h5 id="cylinder函数">cylinder函数</h5>
<p>cylinder函数用于绘制柱面，其调用格式为<br>
[x,y,z]= cylinder(R,n)<br>
其中，R是一个向量，存放柱面各个等间隔高度上的半径；n表示在圆柱圆周上有n个间隔点，默认时表示有20个间隔点。</p>
<h5 id="peaks函数">peaks函数</h5>
<p>peaks函数（多峰函数）常用于三维曲面的演示。该函数可以用来生成绘图数据矩阵。也可以根据网格坐标矩阵x、y重新计算函数值矩阵。生成的数值矩阵可以作为mesh、surf等函数的参数而绘制出多峰函数曲面图。另外，若在调用peaks函数时不带输出参数，则直接绘制出多峰函数曲面图。</p>
<h4 id="其他三维图形">其他三维图形</h4>
<p>绘制二维图形时的条形图、饼图、杆图、填充图等特殊图形可以扩展为三维形式出现，使用的函数分别是bar3、bar3h、pie3、stem3和fill3。</p>
<h5 id="三维统计分析图">三维统计分析图</h5>
<p>bar3和bar3h函数绘制垂直和水平三维条形图，pie3函数绘制饼图。常用格式为</p>
<ul>
<li>bar3(x,y)</li>
<li>bar3h(x,y)</li>
<li>pie3(x)<br>
其中，x是向量，y是向量或矩阵，x向量元素的个数与y的行数相同。bar3和bar3h函数在x指定的位置上绘制y中元素的条形图，x默认时，若y是长度为n的向量，则x轴坐标从1变化到n；若y是m × n的矩阵，则x轴坐标从1变化到n，y中的元素按行分组。pie3函数用x中的数据绘制一个三维饼图。</li>
</ul>
<h5 id="三维多边形">三维多边形</h5>
<p>fill3函数可在三维空间内绘制出多边形，并填充颜色。常用格式为<br>
fill3(x,y,z,c)<br>
其中，使用x,y,z作为多边形的顶点，而c指定填充的颜色。</p>
<h5 id="其他三维图形-2">其他三维图形</h5>
<p>除了上面讨论的三维图形外，常用图形还有瀑布图、三维曲面的等高线图。绘制瀑布图用waterfall函数，它的用法及图形效果与meshz函数相似，只是它的网格线是在x轴方向出现，具有瀑布效果。等高线图分二维和三维两种形式，分别使用函数contour和contour3绘制。<br>
contour(z);<br>
contour(z,n);<br>
contour(z,v);<br>
contour(X,Y,z);<br>
contour(X,Y,z,n);</p>
<h2 id="图形修饰处理">图形修饰处理</h2>
<h3 id="视点处理">视点处理</h3>
<p>从不同的视点绘制的图形其形状是不一样的。视点位置可由方位角和仰角表示。方位角又称旋转角，它是视点与原点连线在xy平面上的投影与y轴负方向形成的角度，正值表示逆时针，负值表示顺时针。仰角又称视角，它是视点与原点连线与xy平面的夹角，正值表示视点在xy平面上方，负值表示视点在xy平面下方。<br>
MATLAB提供了设置视点的函数view，其调用格式为<br>
view(az,el)<br>
其中，az为方位角，el为仰角，它们均以度为单位。系统默认的视点定义为方位角−37.5°，仰角30°。</p>
<h3 id="色彩处理">色彩处理</h3>
<h4 id="颜色的向量表示">颜色的向量表示</h4>
<p>MATLAB除用字符表示颜色外，还可以用含有3个元素的向量表示颜色。向量元素的范围取值为[0，1]，3个元素分别表示红、绿、蓝3种颜色的相对亮度，称为RGB向量。</p>
<h5 id="几种常见的rgb向量">几种常见的RGB向量</h5>
<table>
<thead>
<tr>
<th style="text-align:center">RGB值</th>
<th style="text-align:center">颜色</th>
<th style="text-align:center">字符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[0 0 1]</td>
<td style="text-align:center">蓝色</td>
<td style="text-align:center">b</td>
</tr>
<tr>
<td style="text-align:center">[0 1 0]</td>
<td style="text-align:center">绿色</td>
<td style="text-align:center">g</td>
</tr>
<tr>
<td style="text-align:center">[1 0 0]</td>
<td style="text-align:center">红色</td>
<td style="text-align:center">r</td>
</tr>
<tr>
<td style="text-align:center">[0 1 1]</td>
<td style="text-align:center">青色</td>
<td style="text-align:center">c</td>
</tr>
<tr>
<td style="text-align:center">[1 0 1]</td>
<td style="text-align:center">品红色</td>
<td style="text-align:center">m</td>
</tr>
<tr>
<td style="text-align:center">[1 1 0]</td>
<td style="text-align:center">黄色</td>
<td style="text-align:center">y</td>
</tr>
<tr>
<td style="text-align:center">[0 0 0]</td>
<td style="text-align:center">黑色</td>
<td style="text-align:center">k</td>
</tr>
<tr>
<td style="text-align:center">[1 1 1]</td>
<td style="text-align:center">白色</td>
<td style="text-align:center">w</td>
</tr>
<tr>
<td style="text-align:center">[0.5 0.5 0.5]</td>
<td style="text-align:center">灰色</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">[0.67 0 1]</td>
<td style="text-align:center">紫色</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">[1 0.5 0]</td>
<td style="text-align:center">橙色</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">[1 0.64 0.40]</td>
<td style="text-align:center">铜色</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">[0.49 1 0.83]</td>
<td style="text-align:center">宝石蓝</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h3 id="色图">色图</h3>
<p>色图（Color map）是MATLAB中的颜色参照表。色图以m × 3的数值矩阵表示，用于定义m种颜色，它的每一行对应某个颜色的RGB向量。色图保存着颜色从浓到淡或从一种颜色过渡到另一种颜色的所有中间颜色的值。除plot及其派生函数外，mesh、surf等函数均使用色图着色。MATLAB中使用函数colormap设置和获取图像显示用的颜色参照表，函数的调用格式为<br>
colormap(m)<br>
其中m代表色图。</p>
<h3 id="三维表面图形的着色">三维表面图形的着色</h3>
<p>三维表面图实际上就是在网格图的每一个网格片上涂上颜色。surf函数用默认的着色方式对网格片着色。此外，还可以用shading命令来改变着色方式，shading命令的调用格式为<br>
shading 选项<br>
其中，“选项”有如下3种取值。</p>
<ul>
<li>faceted：将每个网格片用其高度对应的颜色进行着色，但网格线仍保留着，其颜色是黑色。这是系统的默认着色方式。</li>
<li>flat：将每个网格片用同一个颜色进行着色，且网格线也用相应的颜色，从而使得图形表面显得更加光滑。</li>
<li>interp：在网格片内采用颜色插值处理，绘制出的表面图显得最光滑。</li>
</ul>
<h3 id="光照处理">光照处理</h3>
<p>MATLAB提供了灯光设置的函数，其调用格式为<br>
light(属性,选项)<br>
常用属性有表示光的颜色的color属性、表示光源形式的style属性和表示光源位置的position属性。color属性的选项可取相应的颜色字符或RGB三元组。style属性的选项有'infinite'和'local'两个取值，分别表示无限远的平行光源和近光源。position属性的选项取三维坐标点组成的向量形式[x，y，z]。</p>
<h3 id="图形的裁剪处理">图形的裁剪处理</h3>
<p>MATLAB定义的NaN常数可以用于表示那些不可使用的数据，利用这种特性，可以将图形中需要裁剪部分对应的函数值设置成NaN，这样在绘制图形时，函数值为NaN的部分将不显示出来，从而达到对图形进行裁剪的目的。</p>
<h2 id="隐函数绘图">隐函数绘图</h2>
<p>如果给定了函数的显式表达式，可以先设置自变量向量，然后根据表达式计算出函数向量，从而用plot等函数绘制出图形。但如果函数用隐函数形式给出，则很难用上述方法绘制出图形。MATLAB提供了一个ezplot函数绘制二元隐函数图形和ezplot3函数绘制三元隐函数图形，下面介绍其用法。</p>
<h3 id="ezplot函数">ezplot函数</h3>
<p>（1）对于一元函数f (x)，ezplot函数的调用格式为<br>
ezplot(f,a,b)<br>
在区间a &lt; x &lt; b绘制f (x)的图形。a、b默认时，在区间−2<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span></span>&lt; x &lt; 2<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span></span>绘制f = f (x)的图形。<br>
（2）对于二元函数f (x,y)，ezplot函数的调用格式为<br>
ezplot(f,a,b,c,d)<br>
在区间a &lt; x &lt; b和c &lt; y &lt;d绘制f(x,y)的图形。a、b、c、d默认时，在区间−2<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span></span>&lt; x &lt; 2<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span></span>和−2<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span></span> &lt; y &lt;2<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span></span>绘制f (x,y)的图形。<br>
（3）对于参数方程x = funx (t)和y = funy (t)，ezplot函数的调用格式为<br>
ezplot(x,y, a,b)<br>
在区间a &lt; t &lt; b绘制x = funx (t)和y = funy (t)的图形。a、b默认时，在区间0 &lt; t &lt; 2<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span></span>绘制图形。</p>
<h3 id="ezplot3函数">ezplot3函数</h3>
<p>ezplot3函数的调用格式为<br>
ezplot3(x,y,z,[a,b])<br>
对于参数方程在区间a &lt; t &lt; b绘制x = funx (t)，y = funy (t) 和z = funz (t) 的图形。未指定区间时，默认在区间0 &lt; t &lt; 2<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span></span> 绘制图形。例如，绘制例3.13的三维曲线也可以采用以下命令：<br>
ezplot3('sin(t)+t<em>cos(t)','cos(t)-t</em>sin(t)','t',[0,10*pi]);</p>
<h2 id="图像处理">图像处理</h2>
<p>MATLAB基本系统提供了几个用于简单图像处理的函数，利用这些函数可进行图像的读写和显示。此外，MATLAB还有一个功能更强的图像处理工具箱（Image Processing Toolbox），可以对图像进行更专业的处理。</p>
<h3 id="imread和imwrite函数">imread和imwrite函数</h3>
<p>imread函数用于将图像文件读入MATLAB工作空间，imwrite函数用于将图像数据和色图数据一起写入图像文件。函数的调用格式为<br>
A=imread(fname)<br>
imwrite(A,fname,fmt)<br>
其中，fname为读/写的图像文件名，fmt为图像文件格式，如'bmp'、'jpg'、'gif'、'tif'、'png'等。若读写的是灰度图像，则A为二维矩阵；若读写的是彩色图像，则A为三维矩阵，第三维存储颜色数据。</p>
<h3 id="image和imagesc函数">image和imagesc函数</h3>
<p>image、imshow和imagesc函数用于显示图像。imagesc函数可以按照指定的色图显示灰度图像，色图可以通过colormap函数设置。</p>
<h2 id="动画制作">动画制作</h2>
<p>MATLAB具有动画制作能力，它可以存储一系列各种类型的二维或三维图，然后像放电影一样把它们按次序播放出来，称为逐帧动画。一种明显的动画类型是取出一幅三维图形，然后缓慢地将它旋转，这样就可以从不同角度来观察它。另一种类型是在描绘质点运动轨迹的动画，称为轨迹动画。</p>
<h3 id="创建逐帧动画">创建逐帧动画</h3>
<p>MATLAB提供getframe、moviein和movie函数进行逐帧动画制作。创建逐帧动画包括两个步骤。<br>
（1）用getframe函数截取画面信息（一幅画面称为动画中的一帧）。<br>
（2）movie(M,n)函数播放由矩阵M所定义的画面n次，默认时播放一次。矩阵M用来保存n幅画面的数据，每列存储一帧画面信息，以备播放。</p>
<h3 id="创建轨迹动画">创建轨迹动画</h3>
<p>MATLAB中提供了comet和comet3函数展现质点在二维平面和三维空间的运动轨迹，其调用格式为</p>
<ul>
<li>comet(x,y,p)</li>
<li>comet3(x,y,z,p)<br>
其中，每一组x、y、z组成一组曲线的坐标参数，用法与plot和plot3函数相同。选项p用于设置绘制的彗星轨迹线的彗长，彗长为p倍y向量的长度。</li>
</ul>
<h1 id="第四章-线性代数中的数值计算">第四章 线性代数中的数值计算</h1>
<h2 id="特殊矩阵的生成">特殊矩阵的生成</h2>
<h3 id="通用的特殊矩阵">通用的特殊矩阵</h3>
<p>●	zeros函数：产生全0矩阵，即零矩阵。<br>
●	ones函数：产生全1矩阵，即幺矩阵。<br>
●	eye函数：产生单位矩阵，即对角线上的元素为1、其余元素为0的矩阵。<br>
●	rand函数：产生0～1均匀分布的随机矩阵。<br>
●	randn函数：产生均值为0、方差为1的标准正态分布随机矩阵。<br>
这几个函数的调用格式相似，如果这个函数的参数只是一个，那么MATLAB将会创建一个方阵，行数和列数均为这个参数；如果这个函数的参数有两个，那么第一个参数代表行数，第二个参数代表列数。下面以产生零矩阵的zeros函数为例进行说明。<br>
zeros函数的调用格式如下。<br>
●	zeros(m)：产生m × m零矩阵。<br>
●	zeros(m,n)：产生m × n零矩阵。当m = n时，等同于zeros(m)。<br>
●	zeros(size(A))：产生与矩阵A同样大小的零矩阵。</p>
<h3 id="面向特定应用的特殊矩阵">面向特定应用的特殊矩阵</h3>
<h4 id="魔方矩阵">魔方矩阵</h4>
<p>魔方矩阵有一个有趣的性质，其每行、每列及两条对角线上的元素和都相等。对于n阶魔方阵，其元素由1，2，3，…，n2共n2个整数组成。MATLAB提供了求魔方矩阵的函数magic(n)，其功能是生成一个n阶魔方阵。</p>
<h4 id="范得蒙矩阵">范得蒙矩阵</h4>
<p>范得蒙（Vandermonde）矩阵的最后一列全为1，倒数第二列为一个指定的向量，其他各列是其后列与倒数第二列的点乘积。可以用一个指定向量生成一个范得蒙矩阵。在MATLAB中，函数vander(V)生成以向量V为基础向量的范得蒙矩阵。</p>
<h4 id="希尔伯特矩阵">希尔伯特矩阵</h4>
<p>希尔伯特（Hilbert）矩阵是一种数学变换矩阵，它的每个元素hij = 1/(i + j − 1)。在MATLAB中，生成希尔伯特矩阵的函数是hilb(n)。<br>
专门求希尔伯特矩阵的逆的函数invhilb(n)</p>
<h4 id="托普利兹矩阵">托普利兹矩阵</h4>
<p>托普利兹（Toeplitz）矩阵除第一行第一列外，其他每个元素都与左上角的元素相同。生成托普利兹矩阵的函数是toeplitz(x,y)，它生成一个以x为第一列、y为第一行的托普利兹矩阵。这里x、y均为向量，两者不必等长。toeplitz(x)用向量x生成一个对称的托普利兹矩阵。</p>
<h4 id="伴随矩阵">伴随矩阵</h4>
<p>生成伴随矩阵的函数是compan(p)，其中p是一个多项式的系数向量，高次幂系数排在前，低次幂排在后。</p>
<h4 id="帕斯卡矩阵">帕斯卡矩阵</h4>
<p>我们知道，二次项(x + y)n展开后的系数随n的增大组成一个三角形表，称为杨辉三角形。由杨辉三角形表组成的矩阵称为帕斯卡（Pascal）矩阵，函数pascal(n)生成一个n阶帕斯卡矩阵。</p>
<h2 id="矩阵分析">矩阵分析</h2>
<h3 id="矩阵结构变换">矩阵结构变换</h3>
<h4 id="对角阵">对角阵</h4>
<p>只有对角线上有非0元素的矩阵称为对角矩阵，对角线上的元素都为1的对角矩阵称为单位矩阵。<br>
（1）提取矩阵的对角线元素<br>
设A为m × n矩阵，函数diag(A)用于提取矩阵A主对角线元素，产生一个具有min(m,n)个元素的列向量。<br>
diag(A,k) 提取第k条对角线的元素。主对角线为第0条对角线；与主对角线平行，往上为第1条，第2条，…，第n条对角线，往下为第 − 1条，第 − 2条，…，第 − n条对角线。<br>
（2）构造对角矩阵<br>
设V为具有m个元素的向量，diag(V,k)的功能是产生一个n × n（n = m + |k|）对角阵，其第k条对角线的元素即为向量V的元素。<br>
省略k时，相当于k为0，其主对角线元素即为向量V的元素。</p>
<h4 id="三角阵">三角阵</h4>
<p>三角阵又进一步分为上三角阵和下三角阵。所谓上三角阵，即矩阵的对角线以下的元素全为0的一种矩阵，而下三角阵则是对角线以上的元素全为0的一种矩阵。</p>
<p>与矩阵A对应的上三角阵B是与A具有相同的行数和列数的一个矩阵，并且B的对角线以上（含对角线）的元素和A对应相等，而对角线以下的元素等于0。求矩阵A的上三角阵的MATLAB函数是triu(A)。</p>
<p>triu(A,k)，其功能是求矩阵A的第k条对角线以上的元素。</p>
<p>在MATLAB中，提取矩阵A的下三角矩阵的函数是tril(A)和tril(A,k)。</p>
<h4 id="矩阵的转置">矩阵的转置</h4>
<p>所谓转置，即把源矩阵的第一行变成目标矩阵第一列，第二行变成第二列……依此类推。显然，一个m行n列的矩阵经过转置运算后，变成一个n行m列的矩阵。MATLAB中，转置运算符是单撇号(')。</p>
<h4 id="矩阵的旋转">矩阵的旋转</h4>
<p>在MATLAB中，可以很方便地以90°为单位对矩阵A按逆时针方向进行旋转。利用函数rot90(A,k)将矩阵A旋转90°的k倍，当k为负整数时，对矩阵A按顺时针方向进行旋转；当k为1时可省略。</p>
<h4 id="矩阵的翻转">矩阵的翻转</h4>
<p>矩阵的翻转分左右翻转和上下翻转。对矩阵实施左右翻转是将原矩阵的第一列和最后一列调换，第二列和倒数第二列调换……依此类推。<br>
对矩阵A实施左右翻转的函数是fliplr(A)。<br>
对矩阵A实施上下翻转的函数是flipud(A)。</p>
<h2 id="矩阵求值">矩阵求值</h2>
<h3 id="方阵的行列式值">方阵的行列式值</h3>
<p>把一个方阵看作一个行列式，并对其按行列式的规则求值，这个值就称为矩阵所对应的行列式的值。在MATLAB中，求方阵A所对应的行列式的值的函数是det(A)。</p>
<h3 id="矩阵的秩">矩阵的秩</h3>
<p>rank(A)</p>
<h3 id="矩阵的迹">矩阵的迹</h3>
<p>矩阵的迹即矩阵的对角线元素之和。<br>
trace(A)</p>
<h3 id="向量和矩阵的范数">向量和矩阵的范数</h3>
<p>函数norm用于计算矩阵或向量的范数，norm函数的格式如下。<br>
●	norm(X,1)：求向量或矩阵X的1− 范数。<br>
●	norm(X)、norm(X,2)：求向量或矩阵X的2− 范数。<br>
●	norm(X,inf)：求向量或矩阵X的∞− 范数。</p>
<h3 id="矩阵的条件数">矩阵的条件数</h3>
<p>条件数，用于判断矩阵是良性矩阵还是病态矩阵的参数。</p>
<ul>
<li>良性矩阵:系数矩阵的微小变化不会导致解向量发生很大变化</li>
<li>病态矩阵:系数矩阵的个别元素的微小变化会导致解向量发生很大变化<br>
矩阵A的条件数等于A的范数与A的逆矩阵的范数的乘积，即cond(A)=||A||*||A-1||。这样定义的条件数总是大于1的。条件数越接近于1，矩阵的性能越好，反之，矩阵的性能越差。A有3种范数，相应地可定义3种条件数。在MATLAB中，计算A的3种条件数的函数如下。<br>
●	cond(A,1)：计算A的1−范数下的条件数。<br>
●	cond(A)或cond(A,2)：计算A的2−范数数下的条件数。<br>
●	cond(A,inf)：计算A的∞ −范数下的条件数。</li>
</ul>
<h3 id="矩阵的特征值与特征向量">矩阵的特征值与特征向量</h3>
<p>对于n阶方阵A，求数λ和向量ζ，使得等式Aζ = λζ成立，满足等式的数λ称为A的特征值，而向量ζ称为A的特征向量。<br>
在MATLAB中，计算矩阵A的特征值和特征向量的函数是eig(A)，常用的调用格式有如下3种。<br>
●	E = eig(A)：求矩阵A的全部特征值，构成向量E。<br>
●	[V,D] = eig(A)：求矩阵A的全部特征值，构成对角阵D，并求A的特征向量构成V的列向量。<br>
●	[V,D] = eig(A,'nobalance')：与第2种格式类似，但第2种格式中先对A作相似变换后求矩阵A的特征值和特征向量，而格式3直接求矩阵A的特征值和特征向量。<br>
一个矩阵的特征向量有无穷多个，eig函数只找出其中的n个，A的其他特征向量，均可由这n个特征向量的线性组合表示。</p>
<h2 id="线性方程组求解">线性方程组求解</h2>
<h3 id="矩阵求逆及线性代数方程组求解">矩阵求逆及线性代数方程组求解</h3>
<h4 id="矩阵求逆">矩阵求逆</h4>
<p>inv(A)函数用于计算方阵的逆矩阵。</p>
<h4 id="利用矩阵求逆方法解线性方程组">利用矩阵求逆方法解线性方程组</h4>
<p>inv(A)*B</p>
<h4 id="利用左除运算符求解线性方程组">利用左除运算符求解线性方程组</h4>
<p>对于线性方程组Ax = b，可以利用左除运算符“\”求解：<br>
x = A\b    等效于inv(A)*B。</p>
<h2 id="矩阵分解">矩阵分解</h2>
<p>矩阵分解是指根据一定的原理用某种算法将一个矩阵分解成若干个矩阵的乘积。常见的矩阵分解有LU分解、QR分解、Cholesky分解以及Schur分解、Hessenberg分解、奇异分解等。</p>
<h3 id="矩阵的lu分解">矩阵的LU分解</h3>
<p>矩阵的LU分解又称Gauss消去分解或三角分解，就是将一个方阵表示为一个行交换下三角矩阵和一个上三角矩阵的乘积形式。<br>
MATLAB提供的lu函数用于对矩阵进行LU分解，其调用格式如下。<br>
●	[L,U] = lu(X)：产生一个上三角阵U和一个变换形式的下三角阵L(行交换)，使之满足X = LU。注意，这里的矩阵X必须是方阵。<br>
●	[L,U,P] = lu(X)：产生一个上三角阵U和一个下三角阵L以及一个置换矩阵P，使之满足PX = LU。当然矩阵X同样必须是方阵。<br>
当使用第1种格式时，矩阵L往往不是一个下三角矩阵，但可以通过行交换成为一个下三角阵。</p>
<h3 id="矩阵的qr分解">矩阵的QR分解</h3>
<p>对矩阵X进行QR分解，就是把X分解为一个正交矩阵Q和一个上三角矩阵R的乘积形式。MATLAB的函数qr可用于对矩阵进行QR分解，其调用格式如下。<br>
●	[Q,R] = qr(X)：产生一个一个正交矩阵Q和一个上三角矩阵R，使之满足X = QR。<br>
●	[Q,R,E] = qr(X)：产生一个一个正交矩阵Q、一个上三角矩阵R以及一个置换矩阵E，使之满足XE = QR。</p>
<h3 id="矩阵的cholesky分解">矩阵的Cholesky分解</h3>
<p>如果矩阵X是对称正定的，则Cholesky分解将矩阵X分解成一个下三角矩阵和上三角矩阵的乘积。设上三角矩阵为R，则下三角矩阵为其转置，即X = R'R。MATLAB函数chol(X)用于对矩阵X进行Cholesky分解，其调用格式如下。<br>
●	R = chol(X)：产生一个上三角阵R，使R'R = X。若X为非对称正定，则输出一个出错信息。<br>
●	[R,p] = chol(X)：这个命令格式将不输出出错信息。当X为对称正定的，则p = 0，R与上述格式得到的结果相同；否则p为一个正整数。如果X为满秩矩阵，则R为一个阶数为q = p − 1的上三角阵，且满足R'R = X(1:q,1:q)。</p>
<h2 id="超越函数运算">超越函数运算</h2>
<h3 id="超越函数">超越函数</h3>
<p>MATLAB还提供了一些直接作用于矩阵的超越函数，如矩阵平方根函数sqrtm、矩阵指数函数expm、矩阵对数函数logm等，这些函数名都在上述内部函数名之后缀以m，并规定输入参数A必须是方阵。</p>
<h3 id="通用矩阵函数funm">通用矩阵函数funm</h3>
<p>funm(A,'fun')对方阵A计算由fun定义的函数的矩阵函数值。例如，当fun取exp时，funm(A,'exp')可以计算矩阵A的指数，与expm(A)的计算结果一样。</p>
<h2 id="稀疏矩阵的处理">稀疏矩阵的处理</h2>
<p>稀疏矩阵中具有大量的零元素，而仅含极少量的非零元素。</p>
<h3 id="矩阵存储方式">矩阵存储方式</h3>
<ul>
<li>完全存储方式: 矩阵的全部元素按列存储。以前讲到的矩阵的存储方式都是按这个方式存储的，此存储方式对稀疏矩阵也适用。例如，不论是m × n阶普通的还是稀疏的实矩阵均需要m × n个存储单元，而复矩阵还要翻倍。在这种方式下，矩阵中的全部零元素也必须输入。</li>
<li>稀疏存储方式: 仅存储矩阵所有的非零元素的值及其位置，即行号和列号。</li>
</ul>
<h3 id="矩阵的稀疏存储方式">矩阵的稀疏存储方式</h3>
<h4 id="将完全存储方式转化为稀疏存储方式">将完全存储方式转化为稀疏存储方式</h4>
<p>函数A = sparse(S)将矩阵S转化为稀疏存储方式的矩阵A。当矩阵S是稀疏存储方式时，则函数调用相当于A = S。<br>
sparse函数还有其他一些调用格式。<br>
●	sparse(m,n)：生成一个m × n的所有元素都是0的稀疏矩阵。<br>
●	sparse(u,v,S)：u、v、S是3个等长的向量。S是要建立的稀疏矩阵的非0元素，u(i)、v(i)分别是S(i)的行和列下标，该函数建立一个max(u)行、max(v)列并以S为稀疏元素的稀疏矩阵。<br>
和稀疏矩阵操作有关的函数。<br>
●	[u,v,S] = find(A)：返回矩阵A中非0元素的下标和元素。这里产生的u、v、S可作为sparse(u,v,S)的参数。<br>
●	full(A)：返回和稀疏存储矩阵A对应的完全存储方式矩阵。</p>
<h4 id="产生稀疏存储矩阵">产生稀疏存储矩阵</h4>
<p>B = spconvert(A)<br>
其中A为一个m × 3或m × 4的矩阵，其每行表示一个非0元素，m是非0元素的个数，A中每个元素的意义是：<br>
(i,1)  第i个非0元素所在的行；<br>
(i,2)  第i个非0元素所在的列；<br>
(i,3)  第i个非0元素值的实部；<br>
(i,4)  第i个非0元素值的虚部，若矩阵的全部元素都是实数，则无须第4列。<br>
该函数将A所描述的一个稀疏矩阵转化为一个稀疏存储矩阵。</p>
<h4 id="单位矩阵的稀疏存储">单位矩阵的稀疏存储</h4>
<p>单位矩阵只有对角线元素为1，其他元素都为0，是一种具有稀疏特征的矩阵。函数eye产生一个完全存储方式的单位矩阵。MATLAB还有一个产生稀疏存储方式的单位矩阵的函数，这就是speye。函数speye(m,n)返回一个m × n的稀疏存储单位矩阵。</p>
<h1 id="第五章-数据处理与多项式计算">第五章 数据处理与多项式计算</h1>
<h2 id="最大值和最小值">最大值和最小值</h2>
<h3 id="求最大值max和最小值min">求最大值max和最小值min</h3>
<p>●	max(A)：如果A是向量，则返回向量A的最大值。如果A中包含复数元素，则按模取最大值。如果A是矩阵，则返回一个行向量，向量的第i个元素是矩阵A的第i列上的最大值。<br>
●	[Y,U] = max(A)：如果A是向量，则返回向量A的最大值存入Y，最大值的序号存入U。如果A中包含复数元素，则按模取最大值。如果A是矩阵，则Y向量记录A的每列的最大值，U向量记录每列最大值的行号。<br>
●	max(A,[],dim)：仅用于矩阵。dim取1或2。dim取1时，该函数和max(A)完全相同；dim取2时，该函数返回一个列向量，其第i个元素是A矩阵的第i行上的最大值。</p>
<p>求矩阵最小值的函数是min，其用法和max完全相同。</p>
<h3 id="两个向量或矩阵对应元素的比较">两个向量或矩阵对应元素的比较</h3>
<p>函数max和min还能对两个同型的向量或矩阵进行比较。max函数调用格式如下。<br>
●	max(A,B)：A、B是两个同型的向量或矩阵，返回值是与A、B同型的向量或矩阵，其中的每个元素等于A、B对应元素的较大者。<br>
●	max(A,n)：n是一个标量，返回值是与A同型的向量或矩阵，其中的每个元素等于A对应元素和n中的较大者。</p>
<h2 id="求和与求积">求和与求积</h2>
<p>数据序列求和的函数是sum。sum函数的调用格式如下。<br>
●	sum(A)：如果A是一个向量，则返回向量各元素的和。如果A是一个矩阵，则返回一个行向量，其第i个元素是A的第i列的元素和。<br>
●	sum(A,dim)：当dim为1时，该函数等同于sum(A)；当dim为2时，返回一个列向量，其第i个元素是A的第i行的各元素之和。</p>
<p>数据序列求积的函数是prod，其用法和sum完全相同。</p>
<h2 id="平均值和中值">平均值和中值</h2>
<p>数据序列的平均值指的是算术平均值。中值是指在数据序列中其值的大小恰好处在中间的元素。</p>
<p>求数据序列平均值的函数是mean，mean函数的调用格式如下。<br>
●	mean(A)：如果A是一个向量，则返回向量的算术平均值。如果A是一个矩阵，则返回一个行向量，其第i个元素是A的第i列的算术平均值。<br>
●	mean(A,dim)：当dim为1时，该函数等同于mean(A)；当dim为2时，返回一个列向量，其第i个元素是A的第i行的算术平均值。</p>
<p>求数据序列中值的函数是median，其用法和mean完全相同</p>
<h2 id="累加和与累乘积">累加和与累乘积</h2>
<p>所谓累加和或累乘积，是指从数据序列的第1元素开始直到当前元素进行累加或累乘，作为结果序列的当前元素值。<br>
在MATLAB中，使用cumsum和cumprod函数求得向量和矩阵元素的累加和与累乘积向量。cumsum函数的调用格式如下。<br>
●	cumsum(A)：如果A是一个向量，则返回向量的累加和。如果A是一个矩阵，则返回一个矩阵，其第i列是A的第i列的累加和向量。<br>
●	cumsum(A,dim)：当dim为1时，该函数等同于cumsum(A)；当dim为2时，返回一个矩阵，其第i行是A的第i行的累加和向量。</p>
<p>求累乘积的函数是cumprod，其用法和cumsum完全相同。</p>
<h2 id="标准方差与相关系数">标准方差与相关系数</h2>
<h3 id="求标准方差">求标准方差</h3>
<p>方差描述了一组数据波动的大小，方差越小，数据波动越小。在MATLAB中，提供了计算数据序列的标准方差的函数std。对于向量X，std(X)返回一个标准方差。对于矩阵A，std(A)返回一个行向量，它的各个元素便是矩阵A各列或各行的标准方差。std函数的一般调用格式为<br>
Y=std(A,flag,dim)<br>
其中flag取0或1，当flag = 0时，按σ1所列公式计算标准方差；当flag = 1时，按σ2所列公式计算标准方差。dim取1或2. 当dim = 1时，求各列元素的标准方差；当dim = 2时，则求各行元素的标准方差。默认flag = 0，dim = 1。</p>
<h3 id="相关系数">相关系数</h3>
<p>相关系数用来衡量两组数据之间的线性相关程度。 相关系数绝对值越接近1，两组数据相关程度越高<br>
corrcoef函数用于求数据的相关系数矩阵。<br>
●	corrcoef(X,Y)：求向量X和Y的相关系数。<br>
●	corrcoef(X)：返回从矩阵X形成的一个相关系数矩阵。它把矩阵X的每列作为一个变量，然后求它们的相关系数。</p>
<h2 id="排序">排序</h2>
<p>MATLAB提供了对向量X进行排序的函数sort(X)，函数返回一个对X中的元素按升序排列的新向量。<br>
sort函数也可以对矩阵A的各列或各行重新排序，其调用格式为<br>
[Y,I]=sort(A,dim,mode)<br>
其中Y是排序后的矩阵，而I记录Y中的元素在A中的位置。dim指明对A的列还是行进行排序，若dim = 1，则按列排；若dim = 2，则按行排。mode指明按升序还是降序排序，'ascend'为升序，'descend'为降序。dim默认取1，mode默认取'ascend'。</p>
<h2 id="数据插值">数据插值</h2>
<p>在工程测量和科学实验中，所得到的数据通常都是离散的。如果要得到这些离散点以外的其他点的数值，就需要根据这些已知数据进行估算，即插值。</p>
<h3 id="一维数据插值">一维数据插值</h3>
<p>若已知的数据集是平面上的一组离散点集，即被插值函数是一个单变量函数，则数值插值问题称为一维插值。在MATLAB中，实现插值的函数是interp1，其调用格式为<br>
Y1=interp1(X,Y,X1,'method')<br>
函数根据X、Y的值，计算函数在X1处的值。X、Y是两个等长的已知向量，分别描述采样点和样本值，X1是一个向量或标量，描述欲插值的点，Y1是一个与X1等长的插值结果。method是插值方法，允许的取值如下。<br>
●'linear'：线性插值。线性插值是默认的插值方法。它是把与插值点靠近的两个数据点用直线连接，然后在直线上选取对应插值点的数据。<br>
●'nearest'：最近点插值。根据已知插值点与已知数据点的远近程度进行插值。插值点优先选择较近的数据点进行插值操作。<br>
●'cubic'：3次多项式插值。根据已知数据求出一个3次多项式，然后根据该多项式进行插值。<br>
●'spline'：3次样条插值。所谓3次样条插值，是指在每个分段（子区间）内构造一个3次多项式，使其插值函数除满足插值条件外，还要求在各节点处具有光滑的条件。</p>
<h3 id="二维数据插值">二维数据插值</h3>
<p>若已知的数据集是三维空间中的一组离散点集，即被插值函数依赖于两个自变量变化时，插值函数也是一个二维函数。对依赖于两个参数的函数进行插值的问题称为二维插值问题。解决二维插值问题的函数是interp2，其调用格式为<br>
Z1=interp2(X,Y,Z,X1,Y1,'method')<br>
其中X、Y是两个向量，分别描述两个参数的采样点，Z是与参数采样点对应的函数值，X1、Y1是两个向量或标量，描述欲插值的点，Z1是根据相应的插值方法得到的插值结果，method的取值与一维插值函数相同。X、Y、Z也可以是矩阵形式。</p>
<h2 id="曲线拟合">曲线拟合</h2>
<p>曲线拟合的目的也是用一个较简单的函数去逼近一个复杂的或未知的函数。构造函数y = g(x)去逼近实际函数f(x)，但它放弃在插值点两者完全相等的要求，使它在某种意义下最优。MATLAB曲线拟合的最优标准是采用常见的最小二乘原理，所构造的g(x)是一个次数小于插值节点个数的多项式。曲线拟合的最小二乘原理，就是使上述拟合多项式在各节点处的偏差g(xi)  yi的平方和达到最小。(xi,yi)是离散数据点。</p>
<p>最小二乘拟合多项式系数调用格式<br>
[P,S]=polyfit(X,Y,m)<br>
函数根据采样点X和采样点函数值Y，产生一个m次多项式P及其在采样点的误差向量S。其中X、Y是两个等长的向量，P是一个长度为m+1的向量，P的元素为多项式系数。</p>
<p>多项式曲线拟合函数：polyfit( )<br>
调用格式：  p=polyfit(x,y,n)<br>
[p,s]= polyfit(x,y,n)<br>
说明：x,y为数据点，n为多项式阶数，返回p为幂次从高到低的多项式系数向量p。矩阵s用于生成预测值的误差估计。(见下一函数polyval，求插值点xi的函数近似值)</p>
<h2 id="离散傅立叶变换">离散傅立叶变换</h2>
<h3 id="离散傅立叶变换的实现">离散傅立叶变换的实现</h3>
<p>●	fft(X)：返回向量X的离散傅立叶变换。设X的长度（即元素个数）为N，若N为2的幂次，则为以2为基数的快速傅立叶变换，否则为运算速度很慢的非2幂次的算法。对于矩阵X，fft(X)应用于矩阵的每一列。<br>
●	fft(X,N)：计算N点离散傅立叶变换。它限定向量的长度为N，若X的长度小于N，则不足部分补上零；若大于N，则删去超出N的那些元素。对于矩阵X，它同样应用于矩阵的每一列，只是限定了向量的长度为N。<br>
●	fft(X,[],dim)或fft(X,N,dim)：这是对于矩阵而言的函数调用格式，前者的功能与fft(X)基本相同，而后者则与fft(X,N)基本相同。只是当参数dim = 1时，该函数作用于X的每一列；当dim = 2时，则作用于X的每一行。</p>
<p>一维离散傅立叶逆变换函数：ifft(F)返回F的一维离散傅立叶逆变换；ifft(F,N)为N点逆变换；ifft(F,[],dim)或ifft(F,N,dim)由N或dim确定逆变换的点数或操作方向。</p>
<h2 id="多项式计算">多项式计算</h2>
<h3 id="多项式的四则运算">多项式的四则运算</h3>
<h4 id="多项式的加减运算">多项式的加减运算</h4>
<p>在MATLAB中，多项式的加减运算就是其所对应的系数向量的加减运算。如果多项式的次数不同，则应该把低次的多项式系数不足的高次项用0补足，使同式中的各多项式具有相同的次数。</p>
<h4 id="多项式乘除运算">多项式乘除运算</h4>
<p>函数conv(P1,P2)用于求多项式的乘积，其中P1、P2是两个多项式的系数向量。<br>
函数[Q,r] = deconv(P1,P2)用于对多项式作除法运算，其中P1、P2是两个多项式的系数向量，返回值Q是商式的系数向量，r是余式的系数向量。</p>
<h3 id="多项式的导函数">多项式的导函数</h3>
<p>对多项式求导数的函数如下。<br>
●	p=polyder(P)：求多项式P的导函数<br>
●	p=polyder(P,Q)：求P·Q的导函数<br>
●	[p,q]=polyder(P,Q)：求P/Q的导函数，导函数的分子存入p，分母存入q。<br>
上述函数中，参数P、Q是多项式的系数向量，结果p、q也是多项式的系数向量。</p>
<h2 id="多项式的求值">多项式的求值</h2>
<p>MATLAB提供了两种求多项式值的函数：polyval与polyvalm，它们的输入参数均为多项式系数向量P和自变量x。两者的区别在于前者是代数多项式求值，而后者是矩阵多项式求值。</p>
<h3 id="代数多项式求值">代数多项式求值</h3>
<p>polyval函数用来求代数多项式的值，其调用格式为<br>
Y=polyval(P,x)<br>
若x为一数值，则求多项式在该点的值；若x为向量或矩阵，则对向量或矩阵中的每个元素求其多项式的值。</p>
<h3 id="矩阵多项式求值">矩阵多项式求值</h3>
<p>polyvalm函数用来求矩阵多项式的值，其调用格式与polyval相同，但含义不同。polyvalm函数要求x为方阵，它以方阵为自变量求多项式的值。</p>
<h2 id="多项式求根">多项式求根</h2>
<h3 id="由多项式求出根">由多项式求出根</h3>
<p>roots函数用于求多项式的全部根，其调用格式为<br>
x=roots(P)<br>
其中P为多项式的系数向量，求得的根赋给向量x，即x(1)，(2)，…，x(n)分别代表多项式的n个根。</p>
<h3 id="由根求出多项式">由根求出多项式</h3>
<p>若已知多项式的全部根，则可以用poly函数建立起该多项式，其调用格式为<br>
P=poly(x)<br>
其中x为具有n个元素的向量。poly(x)建立以x为其根的多项式，且将该多项式的系数赋给向量P。</p>
<h2 id="非线性方程数值求解">非线性方程数值求解</h2>
<h3 id="单变量非线性方程求解">单变量非线性方程求解</h3>
<p>z=fzero(@fname,x0,tol,trace)<br>
其中fname是待求根的函数文件名，x0为搜索的起点。一个函数可能有多个根，但fzero函数只给出离x0最近的那个根。tol控制结果的相对精度，默认时取tol = eps。trace指定迭代信息是否在运算中显示，为1时显示，为0时不显示，默认时trace为0。</p>
<h3 id="非线性方程组的求解">非线性方程组的求解</h3>
<p>求解非线性方程组需要用到MATLAB的优化工具箱（Optimization Toolbox）。对于非线性方程组F(X)=0，用fsolve函数求其数值解。fsolve函数的调用格式为<br>
X=fsolve(@fun,X0,option)<br>
其中X为返回的解，fun是用于定义需求解的非线性方程组的函数文件名，X0是求根过程的初值，option为最优化工具箱的选项设定。最优化工具箱提供了20多个选项，用户可以使用optimset命令将它们显示出来。如果想改变其中某个选项，则可以调用optimset()函数来完成。例如，Display选项决定函数调用时中间结果的显示方式，其中'off'为不显示，'iter'表示每步都显示，'final'则只显示最终结果。optimset('Display','off')将设定Display选项为'off'。</p>
<h1 id="第六章-数值微积分与常微分方程求解">第六章 数值微积分与常微分方程求解</h1>
<h1 id="第七章-符号计算">第七章 符号计算</h1>
<h1 id="第八章-图形句柄">第八章 图形句柄</h1>
<h1 id="第九章-图形用户界面设计">第九章 图形用户界面设计</h1>
<h1 id="第十章-simulinl仿真环境">第十章 Simulinl仿真环境</h1>
<h1 id="第十一章-matlab应用接口">第十一章 MATLAB应用接口</h1>
<h1 id="第十二章-matlab的学科应用">第十二章 MATLAB的学科应用</h1>
<h1 id="a-target_blank-hrefhttpmailqqcomcgi-binqm_sharetqm_mailmeemailk_h88fzp0_livfd8-g-styletext-decorationnone-意见反馈a"><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=k_H88fzp0_LivfD8-g" style="text-decoration:none;">✉ 意见反馈</a></h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[网站收藏集]]></title>
        <id>https://roboz-up.github.io/post/shi-yong-wang-zhan-ji/</id>
        <link href="https://roboz-up.github.io/post/shi-yong-wang-zhan-ji/">
        </link>
        <updated>2020-03-23T14:01:05.000Z</updated>
        <content type="html"><![CDATA[<p>⏰最后更新时间：2020.5.6</p>
<h1 id="搜索引擎">搜索引擎</h1>
<p><a href="https://cn.bing.com/">必应 - 综合搜索引擎</a></p>
<p><a href="https://magi.com/">Magi - 综合搜索引擎</a></p>
<p><a href="https://mijisou.com/">秘迹搜索 - 综合搜索引擎</a></p>
<p><a href="https://www.jiumodiary.com/">鸠摩搜索 - 文档搜索引擎</a></p>
<p><a href="https://www.ixueshu.com/">爱学术 - 文档搜索引擎</a></p>
<p><a href="http://datasheet.eepw.com.cn/">Datasheet - 电子元器件搜索引擎</a></p>
<p><a href="https://www.findic.com/">采芯网 - 电子元器件搜索引擎</a></p>
<h1 id="资讯">资讯</h1>
<p><a href="https://www.csdn.net/">CSDN</a></p>
<p><a href="https://www.jianshu.com/">简书</a></p>
<p><a href="https://www.w3school.com.cn/">W3school</a></p>
<p><a href="https://404.life/">404模板网</a></p>
<p><a href="http://www.eepw.com.cn/">EEPW电子产品世界</a></p>
<p><a href="https://aosky.wordpress.com/">傲天分享站</a></p>
<p><a href="https://msdn.itellyou.cn/">MSDN</a><br>
<a href="https://next.itellyou.cn/">NEXT</a></p>
<p><a href="https://sansummers.com/">叁夏资源</a></p>
<h1 id="工具">工具</h1>
<p><a href="https://tool.520101.com/">实用工具大全</a></p>
<p><a href="https://www.sojson.com/">SO JSON在线解析</a></p>
<p><a href="https://sm.ms/">SMMS图床</a></p>
<p><a href="https://developer.aliyun.com/">阿里云开发者社区</a></p>
<p><a href="https://ziyuan.baidu.com/">百度搜索资源平台</a></p>
<p><a href="http://www.smdmark.com/">芯片丝印反查网</a></p>
<h1 id="视频">视频</h1>
<p><a href="https://www.acfun.cn/">A站-ACFUN</a></p>
<p><a href="https://www.bilibili.com/">B站-哔哩哔哩</a></p>
<p><a href="https://91mjw.com/">91美剧网</a></p>
<p><a href="http://www.kanjp.com/">看精品</a></p>
<p><a href="https://www.ikukk.com/">爱酷看看</a></p>
<h1 id="游戏">游戏</h1>
<p><a href="https://mubu.com/doc/2_vWBogdplk">单机游戏合集</a></p>
<p><a href="http://www.yxdown.com/">游迅网</a></p>
<h1 id="博客">博客</h1>
<p><a href="https://zgboke.org/">中国博客联盟</a></p>
<p><a href="https://fehey.com/">海岛心hey</a></p>
<h1 id="a-target_blank-hrefhttpmailqqcomcgi-binqm_sharetqm_mailmeemailk_h88fzp0_livfd8-g-styletext-decorationnone-意见反馈a"><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=k_H88fzp0_LivfD8-g" style="text-decoration:none;">✉ 意见反馈</a></h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[笔记：微机原理及接口技术]]></title>
        <id>https://roboz-up.github.io/post/bi-ji-wei-ji-yuan-li-ji-jie-kou-ji-zhu/</id>
        <link href="https://roboz-up.github.io/post/bi-ji-wei-ji-yuan-li-ji-jie-kou-ji-zhu/">
        </link>
        <updated>2020-03-22T04:27:34.000Z</updated>
        <content type="html"><![CDATA[<p>⏰最后更新时间：2020.5.1</p>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2020/05/01/gHNOETMRqb4yha1.png" alt="" loading="lazy"></figure>
<h1 id="预-备-知-识">预 备 知 识</h1>
<ul>
<li>
<h2 id="微处理器">微处理器</h2>
</li>
</ul>
<p>微处理器即为CPU（Central Processing Unit）又叫中央处理器。<br>
主要<strong>功能</strong>：运算和逻辑运算<br>
内部<strong>结构</strong>分为：控制单元、算术逻辑单元和存储单元等几个部分。<br>
按照其处理信息的字长可以分为：八位微处理器、十六位微处理器、三十二位微处理器以及六十四位微处理器等等。</p>
<ul>
<li>
<h2 id="微型计算机">微型计算机</h2>
</li>
</ul>
<p>微型计算机是以<strong>微处理器</strong>为核心，再配上<strong>存储器</strong>和<strong>接口电路</strong>等芯片构成的。</p>
<ul>
<li>
<h2 id="单片机">单片机</h2>
</li>
</ul>
<p>单片机(Microcontrollers)是一种集成电路芯片。<br>
采用超大规模集成电路技术把具有数据处理能力的<strong>中央处理器CPU</strong>、<strong>数据存储器RAM</strong>、<strong>程序存储器ROM</strong>、<strong>多种I/O口和中断系统</strong>、<strong>定时器/计数器</strong>等功能(可能还包括显示驱动电路、脉宽调制电路、模拟多路转换器、A/D转换器等电路)集成到一块硅片上构成的一个小而完善的<strong>微型计算机系统</strong>。</p>
<ul>
<li>
<h2 id="嵌入式系统包括">嵌入式系统包括</h2>
</li>
</ul>
<p>嵌入式微<strong>控制器</strong>(16位、8位、以及8位以下的CPU，典型代表就是单片机)<br>
嵌入式微<strong>处理器</strong>(32位，以及32位以上的称为处理器，典型为ARM核的处理器。)<br>
DSP(Digital Signal Processing，<strong>数字信号处理器</strong>)<br>
SOC(System on Chip， <strong>片上系统</strong>，就是把所有的 模块都做到一块芯片上)</p>
<h2 id="程序设计语言">程序设计语言</h2>
<p>程序设计语言通常分为三类：<strong>机器语言</strong>、<strong>汇编语言</strong>和<strong>高级语言</strong>。</p>
<ul>
<li>机器语言<br>
计算机能够直接识别的数据是由二进制数0和1组成的代码。<br>
机器指令就是用二进制代码组成的指令，一条机器指令控制计算机完成一个基本操作。<br>
用机器语言编写的程序是计算机惟一能够直接识别并执行的程序，而用其他语言编写的程序必须经过翻译才能变换成机器语言程序。<br>
所以，机器语言程序被称为<strong>目标程序</strong>。</li>
<li>汇编语言<br>
为了克服机器语言的缺点，人们采用助记符表示机器指令的操作码,用变量代替操作数的存放地址等，这样就形成了汇编语言。<br>
汇编语言是一种用符号书写的、基本操作与机器指令相对应的、并遵循一定语法规则的计算机语言。<br>
汇编语言是一种符号语言，比机器语言容易理解和掌握，也容易调试和维护。<br>
但是，汇编语言源程序要翻译成机器语言程序才可以由计算机执行。<br>
这个翻译的过程称为“汇编”，这种把汇编源程序翻译成目标程序的语言加工程序称为<strong>汇编程序</strong>。<br>
用汇编语言编写的程序称为<strong>汇编源程序</strong>。</li>
<li>面向机器的低级语言<br>
面向机器的低级语言，通常是为特定的计算机或计算机系列专门设计的。<br>
保持了机器语言的优点，具有直接和简捷的特点。<br>
可有效地访问、控制计算机的各种硬件设备,  如磁盘、存储器、CPU、I/O端口等。<br>
目标代码简短，占用内存少，执行速度快，  是高效的程序设计语言。<br>
经常与高级语言配合使用，应用十分广泛。</li>
<li>高级语言<br>
高级程序设计语言接近于人类自然语言的语法习惯，与计算机硬件无关，易被用户掌握和使用。</li>
</ul>
<h2 id="c语言与汇编语言的区别">C语言与汇编语言的区别</h2>
<ul>
<li><strong>汇编语言</strong>是<strong>低级语言</strong>，在编写程序的时候会把根据不同的情况指定使用不同的寻址方式，能够对内存和CPU里的通用寄存器直接操纵。不同的计算机系列会有不同的汇编语言。<strong>注重描述过程</strong>。</li>
<li><strong>C语言</strong>是<strong>高级语言</strong>，可以实现跨平台。编写程序无需指定CPU的指令执行情况，一段程序可以在不同体系结构的计算机上使用。<strong>注重描述结果</strong>。</li>
</ul>
<h2 id="汇编语言">汇编语言</h2>
<ul>
<li>汇编语言的<strong>特点</strong><br>
可直接<strong>控制硬件</strong>，充分发挥硬件功能。<br>
汇编语言程序代码<strong>质量高</strong>，占用内存<strong>空间少</strong>，执行<strong>速度快</strong>。</li>
<li>应用<strong>优势</strong><br>
对于解决某些领域的问题，如操作系统，实时控制和处理、加密/解密、软件调试、病毒分析及逆向工程等领域具有独特的优势。</li>
<li>实际应用中<br>
常常编写汇编语言子程序，解决如下的问题：<br>
（1）进行计算速度或代码长度优化<br>
（2）存取系统资源<br>
（3）直接访问硬件<br>
（4）为不兼容的代码（编程环境）提供接口</li>
<li><strong>缺点</strong>可移植性差、可读性差。</li>
</ul>
<h2 id="微机的性能指标">微机的性能指标</h2>
<ul>
<li>字长<br>
指CPU内部一次能够处理的二进制数的位数。</li>
<li>存储容量<br>
存储的二进制信息。一般以字节为单位来表示。<br>
常用单位：<br>
b（bit）比特：一位二进制<br>
B（byte）字节：8位二进制<br>
Word 字 = 2Byte = 16bit<br>
KB:2^10=1024B=1KB<br>
MB:2^20=1024KB=1MB<br>
GB:2^30=1024MB=1GB<br>
TB:2^40=1024GB=1TB</li>
<li>运算速度:<br>
主频：CPU的<strong>时钟频率</strong>,用来表示CPU的<strong>运算速度</strong><br>
外频：CPU的<strong>基准频率</strong>,是<strong>CPU</strong>与主板之间<strong>同步运行的速度</strong> ,也是<strong>内存</strong>与主板之间**同步运行的速度 **。<br>
倍频：指CPU外频与主频相差的倍数。<br>
三者关系是：主频=外频*倍频。</li>
<li>运算速度的计算方法：<br>
（1）MIPS方法:	以<strong>每秒能执行几百万条</strong>指令来衡量。<br>
（2）最短指令法: 以<strong>执行时间最短</strong>的指令为标准来计算<br>
（3）直接计算法 :根据<strong>主频和指令的执行所需的时钟周期</strong>直接计算指令执行的时间。</li>
<li>CPU内核和I/O工作电压<br>
内核电压的大小是根据CPU的生产工艺而定，一般制作工艺越小，内核工作电压越低。早期的CPU工作电压为5V,而奔腾可降到2V。<br>
I/O工作电压在1.6-3V。<br>
低电压能解决耗电过大和发热过高的问题。</li>
<li>扩展能力和外设配置</li>
<li>软件配置</li>
</ul>
<h1 id="第一章-微型计算机基础">第一章 微型计算机基础</h1>
<h2 id="11-计算机中数制与编码及其数的表示">1.1  计算机中数制与编码及其数的表示</h2>
<p>计算机内部的信息分为两大类：控制信息和数据信息。</p>
<ul>
<li>控制信息<br>
是一系列的控制命令，用于指挥计算机如何操作。</li>
<li>数据信息<br>
是计算机操作的对象，一般又可分为数值数据和非数值数据。</li>
</ul>
<h3 id="进位计数制">进位计数制</h3>
<table>
<thead>
<tr>
<th style="text-align:center">进制</th>
<th style="text-align:center">符号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">二进制</td>
<td style="text-align:center">B</td>
</tr>
<tr>
<td style="text-align:center">八进制</td>
<td style="text-align:center">O/Q</td>
</tr>
<tr>
<td style="text-align:center">十进制</td>
<td style="text-align:center">D</td>
</tr>
<tr>
<td style="text-align:center">十六进制</td>
<td style="text-align:center">H</td>
</tr>
</tbody>
</table>
<ul>
<li>计数制的书写规则<br>
为了区别不同的计数制，可采用下列两种方法：<br>
1.在数字后面加写相应的英文字母作为标识，英文字母不分大小写。<br>
2.在括号外面加数字下标。</li>
</ul>
<h3 id="数制之间的转换">数制之间的转换</h3>
<h4 id="十进制数与二进制数之间的转换">十进制数与二进制数之间的转换</h4>
<ul>
<li>十进制整数转换成二进制整数<br>
方法：除2取余法<br>
注意：第一次得到的余数为二进制数的最低位，最后得到的余数为二进制数的最高位。</li>
<li>十进制小数转换成二进制小数<br>
方法：乘2取整法<br>
注意：最后将每次得到的整数部分（必定是0或1）按先后顺序从左到右排列即得到所对应二进制小数。</li>
<li>一般的十进制数转换成二进制数<br>
为了将一个既有整数又有小数部分的十进制数转换成二进制数，可以将其整数部分和小数部分分别进行转换，然后再组合起来。</li>
<li>二进制数转换十进制数<br>
方法：按位权展开后相加。<br>
注意：用其各位所对应的系数，按“位权展开求和”的方法就可以得到，其基数为2。</li>
</ul>
<h4 id="十进制数与八进制数之间的转换">十进制数与八进制数之间的转换</h4>
<ul>
<li>十进制整数转换成八进制整数<br>
方法：除8取余法<br>
注意：采用基数8连续去除该十进制整数，直至商等于“0”为止，然后逆序排列所得到的余数。</li>
<li>十进制小数转换成八进制小数<br>
方法：乘8取整法<br>
注意：连续用基数8去乘以该十进制小数，直至乘积的小数部分等于“0”，然后顺序排列每次乘积的整数部分。</li>
<li>八进制数转换成十进制数<br>
方法：按位权展开后相加。<br>
用其各位所对应的系数，按“位权展开求和”的方法就可以得到，其基数为8。</li>
</ul>
<h4 id="十进制与十六进制之间的转换">十进制与十六进制之间的转换</h4>
<ul>
<li>十进制整数转换成十六进制整数<br>
方法：除16取余法<br>
注意：采用基数16连续去除该十进制整数，直至商等于“0”为止，然后逆序排列所得到的余数。</li>
<li>十进制小数转换成十六进制小数<br>
方法：乘16取整法<br>
注意：连续用基数16去乘以该十进制小数，直至乘积的小数部分等于“0”，然后顺序排列每次乘积的整数部分。</li>
<li>十六进制数转换十进制数<br>
方法：按位权展开后相加<br>
注意：用其各位所对应的系数，按“位权展开求和”的方法就可以得到，其基数为16。</li>
</ul>
<h4 id="二进制与八进制-十六进制数之间的转换">二进制与八进制、十六进制数之间的转换</h4>
<p>2^3=8，所以每三位二进制数对应一位八进制数；<br>
2^4=16，所以每四位二进制数对应一位十六进制。</p>
<ul>
<li>二进制数转换成八进制数<br>
从小数点所在位置分别向左向右每三位一组进行划分。<br>
若小数点左侧的位数不是3的整数倍，在数的最左侧补零。<br>
若小数点右侧的位数不是3的整数倍，在数的最右侧补零。<br>
然后将每三位二进制数转换成对应的一位八进制数，即为二进制数对应的八进制数。</li>
<li>八进制数转换成二进制数<br>
将每一位八进制数转换成对应的三位二进制数，即为八进制数对应的二进制数。</li>
<li>二进制数转换成十六进制数<br>
从小数点所在位置分别向左向右每四位一组进行划分。<br>
若小数点左侧的位数不是4的整数倍，在数的最左侧补零。<br>
若小数点右侧的位数不是4的整数倍，在数的最右侧补零 。<br>
然后将每四位二进制数转换成对应的一位十六进制数，即为二进制数对应的十六进制数。</li>
<li>十六进制数转换成二进制数<br>
将每一位十六进制数转换成对应的四位二进制数，即为十六进制数对应的二进制数。</li>
<li>十六进制和二进制的相互转换<br>
对于二进制整数，只要从右到左每4位组成一组，不足4位最左边补0，即可得到相应的十六进制。<br>
对于二进制小数，只要从左到右每4位组成一组，不足4位最右边补0，即可得到相应的十六进制。<br>
将十六进制转成二进制数，只要每一位十六进制数用四位二进制数表示即可。</li>
</ul>
<h3 id="常用的编码方法">常用的编码方法</h3>
<p>计算机中数值型数据是用二进制数来表示的，而非数值型数据包括英文字母、标点符号、专用符号、汉字等，也是用二进制数来编码的。</p>
<h4 id="十进制数的编码">十进制数的编码</h4>
<ul>
<li>BCD码<br>
BCD（Binary-Coded  Decimal）码又称为“二—十进制编码”，专门解决用二进制数表示十进数的问题。最常用的是8421编码，其方法是用4位二进制数表示1位十进制数，自左至右每一位对应的位权是8、4、2、1。</li>
<li>BCD码有两种格式：<br>
1.压缩BCD码格式（Packed BCD Format）<br>
用4个二进制位表示一个十进制位，就是用0000B-1001B来表示十进制数0-9。<br>
例如：十进制数4256的压缩BCD码表示为：<br>
0100 0010 0101 0110 B<br>
2.非压缩BCD码格式（Unpacked BCD Format）<br>
用8个二进制位表示一个十进制位，其中，高四位无意义，我们一般用xxxx表示，低四位和压缩BCD码相同。<br>
例如：十进制数4256的非压缩BCD码表示为：<br>
xxxx0100 xxxx0010 xxxx0101 xxxx0110 B</li>
</ul>
<h4 id="非数值型数据的编码">非数值型数据的编码</h4>
<h5 id="字符编码">字符编码</h5>
<ul>
<li>ASCII字符编码<br>
即美国标准信息交换代码(American Standard Code for Information Interchance)</li>
<li>ASCII码<br>
用一个字节来表示一个字符，低7位为字符的ASCII值，最高位一般用作校验位。</li>
<li>ASCII码表有以下几个特点：<br>
每个字符用7位基2码表示，其排列次序为B6 B5 B4 B3 B2 B1 B0。</li>
<li>ASCII码共编码了128个字符,它们分别是：<br>
32个控制字符，主要用于通信中的通信控制或对计算机设备的功能控制，编码值为0～31（十进制）。<br>
间隔字符（也称空格字符）SP，编码值为20H。<br>
删除控制码DEL，编码值为7FH。<br>
94个可印刷字符（或称有形字符）。</li>
</ul>
<h5 id="汉字的编码">汉字的编码</h5>
<p>计算机在处理汉字时，汉字字符也必须用基2码编码表示，一般汉字编码采用两个字节即16位二进制数。但由于汉字的特殊性，在汉字的输入、存储、输出过程中所使用的汉字编码是不一样的，输入时有输入编码，存储时有汉字机内码，输出时有汉字字形码。</p>
<ul>
<li>汉字输入编码<br>
为了能把汉字这种象形文字通过西文标准键盘输入到计算机内，就必须对汉字用键盘已有的字符设计编码，这种编码称为汉字的输入编码，又称为汉字外部码，简称外码。使用较多的有以下4类：<br>
①顺序码：如区位码、电报码等。<br>
②音码：如拼音码、自然码等。<br>
③形码：如五笔字型、大众码等。<br>
④音形码：如双拼码、五十字元等。</li>
<li>汉字机内码<br>
汉字机内码也称汉字内部码，简称内码。它是机器存储和处理汉字时采用的统一编码。每个汉字的机内码是惟一的，用两个字节表示。为了避免与西文字符的ASCII码之间产生二义性，汉字机内码中两个字节的最高位均规定为“1”。</li>
<li>汉字字形码<br>
汉字字形码也叫汉字字模点阵码，是汉字输出时的字形点阵代码，是一串基2码编码。</li>
</ul>
<h5 id="逻辑数据的编码">逻辑数据的编码</h5>
<ul>
<li>逻辑数据是用来表示“是”与“否”，或称“真”与“假”两个状态的数据。<br>
在计算机中，用“1”表示“真”或“是”，用“0”表示“假”或“否”。<br>
需要注意的是，这里的1和0没有数值和大小概念，只有逻辑意义。</li>
<li>对逻辑数据只能进行逻辑运算，例如逻辑非、逻辑加、逻辑乘等基本逻辑运算和由基本逻辑运算构成的各种组合逻辑运算，运算结果仍是逻辑数据。</li>
<li>逻辑运算（按位操作）<br>
“与”运算（AND）<br>
“或”运算（OR）<br>
“非”运算（NOT）<br>
“异或”运算（XOR）</li>
</ul>
<h3 id="计算机中数的表示">计算机中数的表示</h3>
<h4 id="真值与机器数">真值与机器数</h4>
<ul>
<li>计算机中正负数的表示<br>
最高位为符号位<br>
符号位 = 0正数、 = 1 负数</li>
</ul>
<h4 id="有符号数与无符号数">有符号数与无符号数</h4>
<ul>
<li>无符号整数的编码<br>
在某些情况下，计算机要处理的数据全是正数，此时机器数再保留符号位就没有意义了。这时，我们将机器数最高有效位也作为数值位处理。<br>
无符号整数的表示范围为：0≤N≤2^n –1。<br>
在计算机中最常见的无符号整数是地址。另外，双字长数据的低位字也是无符号整数。<br>
要注意的是，计算机本身不论是对有符号数还是无符号数，总是按照补码的运算规则做运算。</li>
</ul>
<h4 id="原码-反码-补码"><strong>原码  反码  补码</strong></h4>
<ul>
<li>原码表示法<br>
符号 + 绝对值</li>
<li>反码表示法<br>
正数的反码同原码<br>
负数的反码数值位与此负数原码数值位相反</li>
<li>补码（Two’s  Complement）表示法<br>
正数的补码： 同原码<br>
负数的补码：<br>
（1）写出与该负数相对应的正数的补码<br>
（2）按位求反<br>
（3）末位加一<br>
n位二进制补码的表数范围：   - 2^(n-1)  ≤  N ≤ 2^(n-1)-1</li>
<li>补码的加法和减法<br>
求补运算 ：对一个二进制数按位求反、末位加一<br>
加法规则：[X+Y]补码  =  [X]补码  +  [Y]补码<br>
减法规则：[X-Y]补码  =  [X]补码  +  [-Y]补码<br>
补码减法可转换为补码加法</li>
<li>进位和溢出<br>
进位: 由于运算结果超出了位数,最高有效位向前的进位，这一位自然丢失，一般不表示结果的对错。<br>
溢出：表示结果超出了字长允许表示的范围， 一般会造成结果出错。</li>
</ul>
<h2 id="12-微型计算机系统">1.2 微型计算机系统</h2>
<p>典型的微型计算机硬件主要由微处理器、存储器、系统总线、I/O接口电路和I/O设备组成。</p>
<h3 id="微处理器-2">微处理器</h3>
<p>微处理器也称中央处理器（CPU），是微型计算机的核心部件，芯片内集成了运算器、控制器和寄存器组，用来执行程序指令，完成所有的算术和逻辑运算及全机的控制工作。</p>
<h3 id="存储器">存储器</h3>
<p>存储器是微型计算机的重要组成部件，用来存放程序和数据。</p>
<ul>
<li>
<p>微型计算机的存储器分为“主存”和“辅存”两类。</p>
<p>主存也称内存，CPU可以通过总线直接存取，微型计算机的主存储器主要都是采用半导体存储器，按照读写方式的不同，分为只读存储器ROM（Read Only Memory）和随机存取存储器RAM（Random Access Memory）两种类型。</p>
<p>辅存也称外存，如磁盘、磁带、光盘等，CPU通过I/O接口对其进行存取，它的容量比内存大很多，但存取信息的速度要比内存慢得多。一般程序（包括数据）是存放在外存中的，只有当运行时，才把它从外存传送到内存的某个区域，再由CPU控制执行。</p>
</li>
</ul>
<h3 id="系统总线">系统总线</h3>
<p>总线是指传送信息的一组公共导线，是计算机各功能部件之间进行信息传输的通道。CPU、存储器和I/O接口电路之间通过DB（数据总线）、AB（地址总线）和CB（控制总线）相连，这三组总线统称为系统总线。</p>
<ul>
<li>数据总线<br>
数据总线是用来传送数据信息的。<br>
该总线是双向总线。<br>
数据总线的位数（也称宽度）决定了一次能够传送数据的位数。</li>
<li>地址总线<br>
地址总线是传送地址信息的。<br>
该总线是单向总线，用来输出CPU要访问的内存单元或I/O端口的地址。<br>
地址总线位数决定了CPU可以直接寻址的内存空间的大小，对于n条地址总线，可直接寻址的内存范围为<strong>2^n</strong>。</li>
<li>控制总线<br>
控制总线是用来传送控制信息的。<br>
这组信号线比较复杂，有的是微处理器送往存储器和I/O接口的控制信号，如读写控制信号、中断响应信号等；有的是将外界的请求或联络信号送往微处理器，如中断请求信号、准备就绪信号等。</li>
</ul>
<p>采用标准的总线结构是微型计算机系统的显著特点之一。采用了总线结构后，一个部件只要符合总线标准，就可以连接到采用这种总线标准的系统中，使系统的功能可以很方便地得以扩展。</p>
<h3 id="io接口电路和io设备">I/O接口电路和I/O设备</h3>
<p>I/O设备是指微型计算机配备的输入输出设备，也称外围设备（简称外设），是微型计算机必不可少的组成部分。对外设的管理是汇编语言的重要应用之一。<br>
由于微机的外部设备种类繁多、工作原理各异，它们不能直接连到微机系统总线上实现与主机通信，必须经过中间电路再与系统相连，通过该电路来完成数据缓冲、信号变换及与CPU联络等工作，这部分电路被称为I/O接口电路。</p>
<h4 id="io接口电路一般由三种寄存器组成">I/O接口电路一般由三种寄存器组成</h4>
<ul>
<li>数据寄存器：用来保存I/O设备和主机之间传送的数据。</li>
<li>状态寄存器：用来保存I/O设备或接口电路的状态信息，以便CPU在需要时可从中读取外设的状态，了解外设的工作情况。</li>
<li>控制寄存器：保存CPU给外设或接口电路的命令。CPU向控制寄存器写入命令，选择接口电路的工作方式或控制外设进行有关操作。</li>
</ul>
<p>为便于主机访问外设，将I/O接口电路中每个寄存器统一编号，称为I/O端口地址或端口号。<br>
<strong>8086的I/O地址空间为64KB，可寻址65536个不同的I/O地址，端口地址的范围是0000H~FFFFH。</strong></p>
<h3 id="软件">软件</h3>
<p>没有配置软件的计算机,什么工作也不能做，软件是计算机系统的重要组成部分。</p>
<ul>
<li>
<p>微型计算机的软件分为系统软件和应用软件两大类。</p>
<p>系统软件是面向所有用户的一类软件，通常包括：操作系统（DOS、Windows、Linux等）、语言翻译程序、诊断调试程序、I/O驱动程序等。<br>
系统软件的核心是操作系统，所有应用的程序都是在操作系统构筑的平台上运行的。</p>
<p>应用软件主要是指用户围绕某项应用编写的各种程序。</p>
</li>
</ul>
<h4 id="系统软件">系统软件</h4>
<p>核心为操作系统，包括：I/O驱动程序、文件管理程序、文本编辑程序等。<br>
应用程序是建立在操作系统之上的，我们采用DOS（MS-DOS 6.22 或 Windows 的MS-DOS环境）</p>
<ul>
<li>开发汇编语言程序涉及到<br>
文本编辑器<br>
汇编程序<br>
连接程序<br>
调试程序</li>
</ul>
<h2 id="13-微型计算机发展概述">1.3  微型计算机发展概述</h2>
<h3 id="双核技术">双核技术</h3>
<ul>
<li>线程：程序由多个执行线程组成，这些线程是一系列相关指令。</li>
<li>超线程技术：专用于浮点和整数数学的逻辑。利用特殊的硬件指令，把两个逻辑内核模拟成两个物理片，让单个处理器都能使用线程级并行计算，进而兼容多线程操作系统和软件，减少了CPU的闲置时间，提高CPU的运行效率。</li>
</ul>
<p>Intel双核采用多个核心共享前端总线的方式。Intel的架构会遇到多个内核争用总线资源的瓶颈问题。</p>
<p>AMD从一开始设计时就考虑到了对多核心的支持。所有组件都直接连接到CPU，消除系统架构方面的挑战和瓶颈。两个处理器核心直接连接到同一个内核上，核心之间以芯片速度通信，进一步降低了处理器之间的延迟。</p>
<p>AMD将两个内核做在一个Die（晶元）上，通过直连架构连接起来，集成度更高。Intel则是将放在不同Die（晶元）上的两个内核封装在一起。因此有人将Intel的方案称为“双芯”，认为 AMD的方案才是真正的“双核”。</p>
<h1 id="第二章-微处理器的结构">第二章 微处理器的结构</h1>
<h2 id="80868088cpu的内部结构">8086/8088CPU的内部结构</h2>
<p>8086微处理器——16位</p>
<ul>
<li>特点：<br>
<strong>内部结构和外部数据总线都是16位的</strong>，可进行8位（字节）和16位（字）算术运算和逻辑运算；<br>
<strong>地址总线20位，可寻址1MB存储空间和64KB的I/O端口；</strong><br>
时钟频率为5MHz~8MHz；<br>
支持单任务单用户操作：只允许登陆一个用户，同时只能运行一个程序。</li>
</ul>
<h3 id="80868088cpu功能结构">8086/8088CPU功能结构</h3>
<h4 id="总线接口部件biu">总线接口部件BIU</h4>
<ul>
<li>组成：<br>
段寄存器、指令指针寄存器、地址加法器、指令队列和输入输出控制电路</li>
<li>功能：<br>
取指令、指令排队、读/写操作数、地址转换、总线控制</li>
</ul>
<h5 id="段寄存器">段寄存器</h5>
<p>4个16位的段寄存器，代码段寄存器CS、数据段寄存器DS、附加段寄存器ES和堆栈段寄存器SS。<br>
用于存放代码段、数据段、附加段、堆栈段起始地址的高16位（段基值）。</p>
<h5 id="指令指针寄存器ip">指令指针寄存器（IP）</h5>
<p>16位，用于存放下一条要执行指令在代码段中的偏移地址。</p>
<h5 id="地址加法器">地址加法器</h5>
<p>20位，用于将逻辑地址变成存储器的20位物理地址。</p>
<h5 id="指令队列">指令队列</h5>
<p>6字节，用于存放从内存中取来的指令，按照先进先出的方式工作，并按顺序送到EU中执行。<br>
其操作遵循下列原则：</p>
<ul>
<li>每当指令队列缓冲器中存满一条指令后，EU就立即开始执行</li>
<li>指令队列缓冲器只要有2个空字节时，BIU就会自动把指令取到指令队列中，直到填满为止。</li>
<li>在执行转移、调用或返回指令时，接下去要执行的指令不再是程序中紧接着排列的那条指令了，这样，指令队列中已经装入的指令就没用了，则要清除指令队列缓冲器，并要求BIU从新地址开始取指令填入指令队列缓冲器。</li>
</ul>
<h5 id="总线控制电路">总线控制电路</h5>
<p>将CPU的内部总线与系统总线相连，产生和输出对外部操作的地址信号、数据信号、总线控制信号，以实现CPU与I/O设备、存储器间的数据传递，是CPU与内存单元或I/O端口交换数据的必经之路。</p>
<h4 id="执行部件eu">执行部件EU</h4>
<ul>
<li>组成<br>
算术逻辑部件(ALU)、通用寄存器、标志寄存器、暂存器、控制器</li>
<li>功能<br>
指令的执行、数据的运算、指令译码</li>
</ul>
<h4 id="通用寄存器">通用寄存器</h4>
<p>4个16位的数据寄存器AX、BX、CX、DX，用于存放8位数据；<br>
4个16位的指针与变址寄存器SI、DI与SP、BP，用于存放偏移地址。</p>
<h5 id="标志寄存器fr">标志寄存器(FR)</h5>
<p>16位的寄存器，用于存放运算结果的状态标志和控制标志。</p>
<h5 id="算术逻辑部件alu">算术逻辑部件(ALU)</h5>
<p>用于完成8位或16位二进制算术和逻辑运算</p>
<h5 id="执行部件控制电路">执行部件控制电路</h5>
<p>负责从总线接口部件（BIU）的指令队列缓冲器中取指令，并对指令进行译码，根据指令要求向执行部件内部个部分发出控制命令以完成各条指令的功能。</p>
<h3 id="8086的寄存器结构">8086的寄存器结构</h3>
<h4 id="通用寄存器-2">通用寄存器</h4>
<p>8个16位寄存器AX、BX、CX、DX、BP、SP、SI、DI<br>
8个8位寄存器AH、AL、BH、BL、CH、CL、DH、DL。<br>
数据寄存器共有4个寄存器AX、BX、CX、DX，用来保存操作数或运算结果等信息。</p>
<h4 id="ax-累加器">AX 累加器</h4>
<p>用于算术、逻辑运算以及与外设传送信息等。<br>
在有些指令中要求必须使用AX或AL（称为隐含寻址），如乘除法指令和I/O指令。</p>
<h4 id="bx-基址寄存器">BX 基址寄存器</h4>
<p>在存储器寻址中，常用于存放操作数的16位偏移地址。</p>
<h4 id="cx-计数器">CX 计数器</h4>
<p>一般作为循环或串操作等指令中的计数器。<br>
在位操作中，当移多位时，要用CL来指明移位的位数。</p>
<h4 id="dx-数据寄存器">DX 数据寄存器</h4>
<p>在乘除法指令中与AX配合存放运算结果；<br>
在I/O指令的间接寻址中，存放端口地址；<br>
其他场合存放16位数据。</p>
<h4 id="bp-基址指针寄存器">BP 基址指针寄存器</h4>
<p>用MOV指令读/写堆栈中的数据时，用BP寻址堆栈的16位偏移地址。</p>
<h4 id="sp-堆栈指针">SP 堆栈指针</h4>
<p>在堆栈操作指令PUSH和POP中，用SP指向栈顶的偏移地址。<br>
SP和BP通常和SS连用，可以对堆栈中的数据进行读/写操作。</p>
<h4 id="si-源变址寄存器">SI 源变址寄存器</h4>
<p>在串操作指令中，SI用于存放源操作数（源串）的偏移地址，并且SI的内容有自动加减修改功能；<br>
在存储器寻址中，SI通常与DS联用，为程序访问当前数据段提供操作数的段内偏移地址。</p>
<h4 id="di-目的变址寄存器">DI 目的变址寄存器</h4>
<p>在串操作指令中，DI用于存放目的操作数（目的串）的偏移地址，并且DI的内容有自动加减修改功能；<br>
在存储器寻址中，DI通常与DS联用，为程序访问当前数据段提供操作数的段内偏移地址。</p>
<h3 id="段寄存器-2">段寄存器</h3>
<p>段寄存器用来存储20位起始地址的高16位（段基址或段基值）。<br>
段寄存器是根据内存分段的管理模式而设置的。<br>
内存单元的<strong>物理地址</strong>由段寄存器的值和一个偏移量组合而成的，这样可用两个较少位数的值组合成一个可访问较大物理空间的内存地址。</p>
<h4 id="cs-代码段寄存器">CS 代码段寄存器</h4>
<p>用来存放程序的指令序列<br>
代码段寄存器CS存放代码段的段地址<br>
指令指针寄存器IP指示下条指令的偏移地址<br>
即BIU里面的指令列队存放着下一条要执行的指令，而该指令的地址由两部分组成，一个是段首址，另一个是偏移地址，段首址存放在段寄存器CS中，而偏移地址就是IP<br>
（段基址+偏移地址=逻辑地址）<br>
（物理地址=存储器中真实地址）<br>
CPU利用（CS:IP）取得下一条要执行的指令</p>
<h4 id="ds-数据段寄存器">DS 数据段寄存器</h4>
<p>存放运行程序所用的数据（地址）<br>
数据段寄存器DS存放数据段的段地址<br>
各种主存寻址方式（有效地址EA）得到存储器中操作数的偏移地址<br>
CPU利用（DS:EA）存取数据段中某一存储单元的地址</p>
<h4 id="ss-堆栈段寄存器">SS 堆栈段寄存器</h4>
<p>确定堆栈所在的主存区域<br>
堆栈段寄存器SS存放堆栈段的段地址<br>
堆栈指针寄存器SP指示堆栈栈顶的偏移地址<br>
CPU利用（SS:SP）操作堆栈顶的地址</p>
<h4 id="es-附加段寄存器">ES 附加段寄存器</h4>
<p>一个段的空间最大是64KB。<br>
要在2个相距超过64KB的单元传递数据，仅以DS为段址寄存器时，一般需要先设置DS为源数据单元所在的段址，读出数据后，再改变DS的值为接收数据的目的单元所在的段址，实现传递数据功能。如果不想频繁改变DS的值，可以使用ES。</p>
<h3 id="ip-指令指针寄存器">IP 指令指针寄存器</h3>
<p>16位寄存器<br>
用于存放将要执行的指令在现行代码段中的偏移地址。<br>
IP的内容是在启动程序执行时由系统自动设置的，程序在运行过程中，IP的内容由BIU自动修改，使IP始终指向下一条将要执行的指令地址。<br>
正常情况，程序不能修改IP内容，但跳转指令或者调用指令会使IP的内容发生改变。<br>
IP，它总是保存下一次将要从主存中取出指令的偏移地址，偏移地址的值为该指令到所在段段起始址的字节距离。</p>
<h3 id="fr-标识寄存器">FR 标识寄存器</h3>
<p>16位，在8086中只定义了9位。</p>
<h4 id="状态标志">状态标志</h4>
<p>用来记录程序运行结果的状态信息，许多指令的执行都将相应地设置它。<br>
状态标志：6个，用于表示运算结果特征，由CPU在运算过程中自动设置。</p>
<h5 id="of-溢出标志">OF  溢出标志</h5>
<p>运算结果是否超出及其所能表示的范围。溢出，OF=1，否则=0。<br>
只对判有符号数的运算结果产生溢出有意义。</p>
<h5 id="sf-符号标志">SF  符号标志</h5>
<p>运算结果最高位的状态。运算结果为负数，SF=1，否则=0。<br>
对于逻辑运算只表示结果的最高位是1或0，无实际意义。</p>
<h5 id="zf-零标志">ZF  零标志</h5>
<p>运算结果是否为零，为零，ZF=1，否则=0。</p>
<h5 id="cf-进位标志">CF  进位标志</h5>
<p>计算结果使最高位产生进位或借位情况时，CF=1，否则=0。</p>
<h5 id="af-辅助进位标志">AF  辅助进位标志</h5>
<p>运算结果低4位向高4位有进位或借位时，AF=1，否则=0。<br>
用于BCD码运算中的十进制调整指令。</p>
<h5 id="pf-奇偶标志">PF  奇偶标志</h5>
<p>运算结果中的低8位有偶数个1，PF=1，否则=0。</p>
<h4 id="控制标志">控制标志</h4>
<p>可由程序根据需要用指令设置，用于控制处理器执行指令的方式。<br>
控制标志：3个，用于控制CPU中断与执行方式，用户可以使用指令对这3位进行置位或清楚。</p>
<h5 id="df-方向标志">DF   方向标志</h5>
<p>决定操作数的地址是按递增方式修改还是递减方式修改。<br>
DF=0，则为递增方式，对于字节操作SI/DI自动加1，对于字操作SI/DI自动加2；<br>
DF=1，则为递减方式，对于字节操作SI/DI自动减1，对于字操作SI/DI自动减2。<br>
DF的状态由STD指令置位和CLD指令清除。</p>
<h5 id="i-f-中断允许标志">I F   中断允许标志</h5>
<p>控制INTR（屏蔽中断请求）输入引脚操作。<br>
IF=1，INTR请求被允许，CPU响应中断请求，转去执行中断处理程序。<br>
IF的状态由STI指令置位（开中断）和CLI指令清除（关中断）。</p>
<h5 id="tf-单步标志陷阱标志">TF   单步标志（陷阱标志）</h5>
<p>用于调试程序，以便找到错误或故障。<br>
TF=1，CPU单步执行，每执行完一条指令就自动产生一个内部中断，使用户可逐条跟踪程序进行调试。</p>
<h2 id="8086的存储器组织">8086的存储器组织</h2>
<h3 id="存储器组织与数据存储格式">存储器组织与数据存储格式</h3>
<h4 id="存储单元地址">存储单元地址</h4>
<p>8086系统中，为了标识和存取每一个存储单元，给每个存储单元规定一个编号。</p>
<h4 id="存储单元的内容">存储单元的内容</h4>
<p>一个存储单元中存放的信息称为该存储单元的内容。</p>
<p>8086的存储器空间为1MB，地址范围为00000H~FFFFFH。</p>
<ul>
<li>注意<br>
存储器以字节（8 bit）为编程单位<br>
每个字节单元都有唯一的地址编码<br>
地址用无符号整数来表示（编程用十六进制表示）<br>
一个字要占用相继的两个字节<br>
低位字节存入低地址，高位字节存入高地址<br>
字单元地址用它的低地址来表示</li>
</ul>
<h4 id="奇地址存储体和偶地址存储体">奇地址存储体和偶地址存储体</h4>
<p>将1MB存储空间分为两个512KB的存储体：奇地址存储体和偶地址存储体；<br>
偶地址存储体与数据线的D7~D0相连，每个存储单元的地址为偶数地址；<br>
奇地址存储体与数据线的D15~D8相连，每个存储单元的地址为奇数地址；<br>
CPU既可以单独对其中一个存储体读/写8位数据，也可以对两个存储体中相邻的两字节单元读/写16位数据。</p>
<h4 id="8086指令系统中字节和字两种操作指令">8086指令系统中，字节和字两种操作指令。</h4>
<ul>
<li>字节数据：一个数据占用一个存储单元，有一个对应的唯一地址。</li>
<li>字数据：一个数据占用相邻两个存储单元，低地址存放低8位，高地址存放高8位，两个地址中较小的作为字的地址。</li>
</ul>
<h3 id="存储器分段结构">存储器分段结构</h3>
<p>8086 CPU的地址总线是20位的，它最大可寻址空间为1MB，而8086的内部寄存器是16位寄存器，16位寄存器只能寻址2^16=64KB，为了能用16位寄存器来有效地访问1MB的存储空间，  8086 CPU采用了内存分段的管理模式。<br>
8086把1MB存储空间分成若干个逻辑段，每个逻辑段最大为64KB，这样段内地址可以用16位表示，这样，系统的整个存储空间可分为16个互不重叠的逻辑段。</p>
<h4 id="根据段内存放信息的不同分为">根据段内存放信息的不同分为</h4>
<p>代码段——存放程序<br>
数据段——存放数据<br>
堆栈段——存放需要保存的信息<br>
附加段——存放数据</p>
<h3 id="逻辑地址与物理地址的转换">逻辑地址与物理地址的转换</h3>
<p><strong>物理地址=段基值×10H + 偏移地址</strong></p>
<h4 id="物理地址">物理地址</h4>
<p>访问存储器的实际地址，一个存储单元对应唯一的一个物理地址。</p>
<h4 id="逻辑地址">逻辑地址</h4>
<p>对应逻辑段内的一种地址表示形式，由段基值和段内偏移地址组成，表示为段基值：<br>
偏移地址。其中，段基值由段寄存器提供，偏移地址由指令的寻址方式提供。</p>
<h4 id="段基值">段基值</h4>
<p>逻辑段20位起始地址中的高16位地址值。</p>
<p>起始地址=段基值+4个0</p>
<h2 id="8086的工作模式及引脚信号">8086的工作模式及引脚信号</h2>
<h3 id="8086的工作模式">8086的工作模式</h3>
<p>为了尽可能适应各种各样的使用场合，在设计8086 CPU芯片时， 使它们可以在两种模式下工作，即<strong>最小模</strong>式和<strong>最大模式</strong>。</p>
<h4 id="最小模式">最小模式</h4>
<p>系统中只有一个8086微处理器，所有的总线控制信号都由8086直接产生。</p>
<ul>
<li>MN/MX端接+5V，工作在最小模式；</li>
<li>有一片8284A，作为时钟信号发生器；</li>
<li>有三片8282或74LS273，用来作为地址信号的锁存器；</li>
<li>当系统中所连的存储器和外设端口较多时，需要增加数据总线的驱动能力，这时，需用2片8286/8287作为数据总线收发器。</li>
</ul>
<h4 id="最大模式">最大模式</h4>
<p>指系统中至少包含两个微处理器，其中一个为主处理器，即8086 CPU，其它的微处理器称之为协处理器，它们是协助主处理器工作的。</p>
<ul>
<li>该模式适用于大中型规模的微机应用系统。</li>
<li>最小模式所拥有的配置；</li>
<li>有一片8288总线控制器来对CPU发出的控制信号进行变换和组合，以得到对存储器或I/O 端口的读/写信号和对锁存器8282及数据总线收发器8286的控制信号。</li>
<li>有8259A（可选）用以对多个中断源进行中断优先级的管理，但如果中断源不多，也可以不用中断优先级管理部件。</li>
</ul>
<h4 id="8087">8087</h4>
<p>是一种专用于数值运算的协处理器，它能实现多种类型的数值运算，如高精度的整型和浮点型数值运算，超越函数（三角函数、对数函数）的计算等，引入8087协处理器，可以把软件功能硬件化，大大的提高了主处理器的运行速度。</p>
<h4 id="8089协处理器">8089协处理器</h4>
<p>在原理上有点象带有两个DMA通道的处理器，它有一套专门用于输入/输出操作的指令系统，但是8089又和DMA控制器不同，它可以直接为输入/输出设备服务，使主处理器不再承担这类工作。所以，在系统中增加8089协处理器之后，会明显提高主处理器的效率，尤其是在输入/输出操作比较频繁的系统中。</p>
<h3 id="8086的引脚信号">8086的引脚信号</h3>
<h4 id="ad15~ad0address-data-bus-2~16">AD15~AD0(Address Data Bus ，2~16)</h4>
<p>地址/数据分时复用总线，三态、双向。在总线周期的T1状态，输出访问存储器或I/O端口的地址信息；在T2~T3状态，传递数据信息。</p>
<h5 id="总线分时复用">总线分时复用</h5>
<p>总线分时复用就是同一总线在不同时间传输的是不同的信号，这些信号的作用是不同的。8086采用总线分时复用方法在不影响CPU功能的情况下，减少了CPU的引脚数目，使系统得到简化。</p>
<h5 id="三态">三态</h5>
<p>三态是指总线输出可以有三个状态：高电平、低电平和高阻状态。当处于高阻状态时，该总线在逻辑上与所有连接负载断开。</p>
<h4 id="a19s6~a16s3address-status-bus35~38">A19/S6~A16/S3(Address Status Bus，35~38)</h4>
<p>地址/状态分时复用线，三态输出。总线周期的T1状态，输出访问存储器的最高4位的地址，与AD15<sub>AD0一起构成20位地址码，访问I/O端口时A19</sub>A16无效。在总线周期的T2~T4用来输出状态信息。</p>
<ul>
<li>状态信息号S6~S3作用如下：<br>
S6恒为0，表示8086当前与总线相连。<br>
S5表明中断允许标志的当前设置。如果IF=1，则S5=1，表示允许可屏蔽中断请求；如果IF=0，则S5=0，表示禁止一切可屏蔽中断请求。<br>
S4和S3组合使用，用于指出当前正在使用哪个段寄存器。</li>
</ul>
<h5 id="可屏蔽中断">可屏蔽中断</h5>
<p>可屏蔽中断属于外中断，是CPU可以不响应的中断。即当这种中断发生时，CPU可以不予以理睬，继续埋头做正在做的事；但CPU是否响应可屏蔽中断，要看标志寄存器的IF位的设置。当CPU检测到可屏蔽中断信息时，如果IF=1，则CPU必须响应；如果IF=0，CPU就不理它了，等于被屏蔽掉了。</p>
<h4 id="bhes7bus-high-enablestatus34">BHE/S7（Bus High Enable/Status，34）</h4>
<p>S7在8086中未定义，作为备用状态信号。<br>
高8位数据总线允许/状态复用线，三态输出。BHE在总线周期的T1状态输出，低电平有效，用来表示当前高8位数据总线D15~D8上数据有效。该引脚和地址总线A0（16）配合表示数据总线上的状态。</p>
<h4 id="mnmxminimummaximum-model-control33">MN/MX(Minimum/Maximum Model Control，33)</h4>
<p>最小/最大模式控制信号，输入。当接高电平（接+5V）时，8086工作在最小模式，系统的控制信号全部由8086提供；当接低电平（接地）时，8086工作在最大模式，8086发出的控制信号经总线控制器进行变换和组合后作为系统的控制信号。</p>
<h4 id="rdread32">RD(Read，32）</h4>
<p>读信号，三态输出，低电平有效。低电平时，8086正在对存储器或I/O端口进行读操作。</p>
<h4 id="testtest23">TEST(Test，23)</h4>
<p>测试信号，输入，低电平有效。TEST与等待指令WAIT配合使用。8086执行WAIT指令后，8086处于空转等待状态。TEST=1，则8086继续处于空转等待状态；TEST=0，退出等待状态，继续执行下一条指令。TEST信号用于多处理器系统中，实现8086主CPU与其他协处理器之间的同步协调功能。</p>
<h4 id="readyready22">READY(Ready，22)</h4>
<p>准备就绪信号，输入，高电平有效。当READY为高电平时，表示内存或I/O设备的数据已准备就绪，可以立即进行一次数据传输。READY=1，则按正常时序进行读、写操作；READY=0，则表示存储器或I/O设备没有准备好数据，不能进行数据传输。</p>
<h4 id="resetreset21">RESET(Reset，21)</h4>
<p>复位信号，输入，高电平有效。复位后，8086内部寄存器初始化，除CS=FFFFH外，包括IP在内的其余寄存器的值均为0。复位后将从逻辑地址FFFFH：0000H处开始执行程序。一般在该地址放置一条转移指令，以转到程序真正的入口地址。</p>
<h4 id="clkclock19">CLK(Clock，19)</h4>
<p>系统时钟，输入。CLK提供8086和总线控制的基本定时脉冲。8086的系统时钟由时钟发生器8284产生。</p>
<h4 id="vcc40">VCC(40)</h4>
<p>电源线，输入。8086电源为5V±10%。</p>
<h4 id="gnd1-20">GND(1、20)</h4>
<p>地线，输入。</p>
<h4 id="nminon-maskable-interrupt17">NMI(Non-Maskable Interrupt，17)</h4>
<p>非屏蔽中断请求信号，输入，上升沿有效。NMI中断请求不受中断允许标志IF的控制，只要在该引脚有上升沿出现，在当前指令结束后8086立即进入非屏蔽中断请求处理。NMI中断通常用于系统紧急情况的处理，如系统电源掉电等。</p>
<h4 id="intrinterrupt-request18">INTR(Interrupt Request，18)</h4>
<p>可屏蔽中断请求信号，输入，高电平有效。IF=1，且INTR接+5V时，8086在当前指令周期结束后进行INTR中断处理。</p>
<h5 id="可屏蔽中断和非屏蔽中断的区别">可屏蔽中断和非屏蔽中断的区别</h5>
<p>可屏蔽中断和不可屏蔽中断都属于外部中断，是由外部中断源引起的；但它们也有区别：可屏蔽中断是通过CPU的INTR引脚引入，当中断标志IF＝1时允许中断，当IF=0时禁止中断，不可屏蔽中断是由NMI引脚引入，不受IF标志的影响。</p>
<h4 id="最小模式下的24到31引脚">最小模式下的24到31引脚</h4>
<h5 id="intainterrupt-acknowledge24">INTA(Interrupt Acknowledge，24）</h5>
<p>中断响应信号，三态输出，低电平有效。INTA是对可屏蔽中断请求信号INTR的响应信号。INTR=1且IF=1时，8086响应INTR请求，向请求设备发送连续的两个INTA中断响应周期信号，表明8086进入了INTR中断处理过程。</p>
<h5 id="aleaddress-lock-enable25">ALE(Address Lock Enable，25)</h5>
<p>地址锁存允许信号，三态输出，高电平有效。当地址/数据线上传送的是地址信息时，ALE信号有效，将地址/数据线上输出的地址信息所存。</p>
<h5 id="dendata-enable26">DEN(Data Enable，26)</h5>
<p>数据允许信号，三态输出，低电平有效。当地址/数据线上传送的是数据信息时，DEN信号有效。</p>
<h5 id="dtrdata-transmitreceive27">DT/R(Data Transmit/Receive，27)</h5>
<p>数据发送/接受控制信号，三态输出。用来控制数据总线上数据传送的方向，通常作为数据总线缓冲器的控制信号。当DT/R为高电平时，8086向存储器或I/O设备发送数据；当DT/R为低电平时，8086从存储器或I/O设备接受数据。</p>
<h5 id="miomemoryinput-output28">M/IO(Memory/Input &amp;Output，28)</h5>
<p>存储器和I/O设备的选择信号，三态输出。数据传送时自动产生的输出信号，用来表示当前是访问存储器还是访问I/O设备。当M/IO为高电平时，表示与存储器传送数据；当M/IO为低电平时，表示与I/O设备传送数据。</p>
<h5 id="wr-write29三态">WR (Write，29，三态)</h5>
<p>写信号，三态输出，低电平有效。低电平时，8086正在度存储器或I/O端口进行写操作。</p>
<h5 id="holdhold-reqest31">HOLD(Hold Reqest，31)</h5>
<p>总线保持请求信号，输入，高电平有效。在最小工作模式中，当除8086 CPU以外的其他总线控制器要求占用总线时，可通过此引脚向CPU发送请求占用总线的信号。例如，系统中的DMA控制器就是通过此引脚向CPU申请使用系统总线的。</p>
<h5 id="hlda-hold-acknowledge30">HLDA (Hold Acknowledge，30)</h5>
<p>总线保持响应信号，输出，高电平有效。该信号是对HOLD的响应信号。当CPU检测到总线请求信号HOLD为高电平时，且CPU允许其他设备占用总线时，则在当前总线周期结束时，输出HLDA信号，作为对总线保持请求信号HOLD的响应，并立即使总线置为高阻状态，CPU放弃对总线的控制权。当获得总线使用权的控制器用完总线后，使HOLD信号变为低电平，表示放弃对总线的控制权。8086CPU检测到HOLD变为低电平后，会使HLDA变为低电平，恢复对总线的控制。</p>
<h4 id="最大工作模式下的引脚信号">最大工作模式下的引脚信号</h4>
<h5 id="rqgtrequestgrant30-31">RQ/GT(Request/Grant，30、31)</h5>
<p>总线请求输入/总线请求允许输出信号，双向，低电平有效。这两个信号是在最大模式系统中主CPU和其他协处理器(如8087、8089）之间交换总线使用权的联络控制信号。RQ为总线请求输入信号，GT为总线请求允许输出信号。</p>
<h5 id="lock">LOCK</h5>
<p>总线封锁信号，三态输出，低电平有效。当LOCK为低电平时，CPU不允许其他总线主控设各占用总线。LOCK信号由指令前缀LOCK产生。在8086CPU处于2个INTA中断响应周期期间，LOCK信号会自动变为有效的低电平，以防止其他总线控制器在中断响应过程中占用总线而使一个完整的中断响应过程被间断。</p>
<h5 id="s2-s1-s0bus-cycles-status">S2、S1、S0(Bus Cycles Status)</h5>
<p>总线周期状态信号，三态输出，低电平有效。</p>
<h5 id="qs1qs0-instruction-queue-status">QS1,QS0 (Instruction Queue Status)</h5>
<p>指令队列状态信号，输出。</p>
<h2 id="8086的总线操作时序">8086的总线操作时序</h2>
<h3 id="时钟周期clock-cycle">时钟周期（Clock Cycle）</h3>
<p>微处理器执行指令的最小时间单位，又称T状态。<br>
例如，8086主频为5MHz，则1个时钟周期为200ns。</p>
<h3 id="指令周期instruction-cyclefetch-decode-execute-cycle">指令周期（Instruction Cycle，fetch-decode-execute cycle）</h3>
<p>CPU执行一条指令所需的时间。</p>
<h3 id="总线周期bus-cycle">总线周期（Bus Cycle）</h3>
<p>CPU对存储器或I/O端口完成一次读/写操作所需时间。</p>
<ul>
<li>振荡周期=1/振荡频率</li>
<li>机器周期=12*振荡周期</li>
</ul>
<h3 id="总线操作步骤">总线操作步骤</h3>
<h4 id="总线操作">总线操作</h4>
<p>通过总线完成存储器读写、I/O读写等的一系列操作。</p>
<h4 id="一个总线周期通常分为四个阶段">一个总线周期通常分为四个阶段</h4>
<h5 id="总线请求和仲裁阶段">总线请求和仲裁阶段</h5>
<p>当有多个模块提出总线请求时，必须由仲裁机构仲裁，确定将总线的使用权分配给哪个模块。</p>
<h5 id="寻址阶段">寻址阶段</h5>
<p>取得使用总线权的模块经总线发出本次要访问的M或I/O端口的地址和有关命令。</p>
<h5 id="传送数据阶段">传送数据阶段</h5>
<p>主模块（指取得总线控制权的模块）与其它模块之间进行数据的传送。</p>
<h5 id="结束阶段">结束阶段</h5>
<p>主从模块将有关信息从总线上撤除，主模块交出总线的控制权。</p>
<h3 id="8086的总线操作时序-2">8086的总线操作时序</h3>
<h4 id="总线操作-2">总线操作</h4>
<p>通过总线完成存储器读写、I/O读写等的一系列操作。</p>
<h4 id="总线时序">总线时序</h4>
<p>与完成总线操作有关的地址线、数据线、控制线及时钟信号相互之间的先后关系，一般用时序图表示。</p>
<h5 id="最小模式下的读总线周期">最小模式下的读总线周期</h5>
<p>一个总线读周期由4个时钟周期T1~T4组成，每个时钟周期称为状态周期。</p>
<h5 id="最小模式下的写总线周期">最小模式下的写总线周期</h5>
<h5 id="空闲周期">空闲周期</h5>
<p>只有BIU与内存或I/O端口交换数据，以及填充指令队列时，BIU才执行总线周期。除此之外，既不需要填充指令队列，EU也没有向BIU发出总线周期请求时，系统总线就处于空闲状态，进入空闲周期，空闲周期由一个或几个TI状态组成。</p>
<ul>
<li>在8086中，一个基本的总线周期由4个时钟周期组成。</li>
</ul>
<h1 id="第三章-指令系统">第三章 指令系统</h1>
<h2 id="指令格式">指令格式</h2>
<p>指令是计算机能够识别和执行的操作命令，由二进制数“0”、“1”组成。每条指令的编码格式由机器指令系统规定。机器指令的集合称为指令系统。指令由操作码和操作数两部分组成。</p>
<ul>
<li>操作码  ：说明指令操作的性质和功能，如传送、运算、移位、跳转等操作，它是指令中不可缺少的组成部分。常用OP表示。</li>
<li>操作数  ： 用于提供指令中要处理的数据或数据所在的地址信息。是指令执行的参与者，即各种操作的对象。<br>
一条指令常由6个字段组成，字段1为前缀字段，字段2~6为基本字段。指令长度超过16字节为非法指令。</li>
</ul>
<h3 id="前缀字段">前缀字段</h3>
<p>前缀字段用于修改指令操作的某些属性，为可选字段。<br>
（1）段超越前缀：用于指明某个段寄存器取代指令中默认的段寄存器。<br>
（2）操作数宽度前缀：用于改变当前操作数的默认宽度值。<br>
（3）地址宽度前缀：用于改变当前地址的默认宽度值。<br>
（4）重复前缀：用于重复串的操作。<br>
（5）总线锁定前缀：用于产生LOCK信号，防止其他设备中断CPU在总线上的操作。</p>
<h3 id="操作码字段1~2字节">操作码字段(1~2字节)</h3>
<p>规定了指令的操作性质和功能。此字段不可省略。</p>
<h3 id="寻址方式字段2字节">寻址方式字段（2字节）</h3>
<p>规定了操作数的寻址方式，包括操作数长度、采用的寻址方式、操作数的存放位置。</p>
<h3 id="位移量字段1-2或4字节">位移量字段（1、2或4字节）</h3>
<p>当寻址方式中有位移量时，指令中将出现此字段。通常用带符号数(补码)表示。</p>
<h3 id="立即数字段12或4字节">立即数字段(1，2或4字节)</h3>
<p>当寻址方式是立即数寻址时，需用此字段。立即数为带符号数，以补码形式存储。</p>
<p>操作码字段是必选字段，其它各字段可根据不同的寻址方式选用。</p>
<h2 id="寻址方式">寻址方式</h2>
<ul>
<li>寻址：寻找操作数的地址。</li>
<li>寻址方式：寻找操作数/操作数地址的方法。</li>
</ul>
<p>根据操作数存放位置不同，指令中操作数分为：<br>
（1）立即操作数：操作数包含在指令中，存放在代码段，其取指令的同时，操作数也随着取出，称这种操作数为立即操作数，寻址方式为立即寻址。<br>
（2）寄存器操作数：这种操作数存放在CPU内部的某个寄存器中，在指令中提供存放操作数的寄存器名。CPU执行指令时，在指定的寄存器中存取操作数，寻址方式为寄存器寻址。<br>
（3）存储器操作数：操作数存放在内存储器中，如数据段和附加段。CPU对存储器操作数进行操作时，指令中提供操作数在寄存器中存放的地址，这种寻址方式为存储器寻址。<br>
（4）I/O端口操作数：操作数存放在I/O接口的端口中，CPU通过I/O接口与输入输出设备交换信息，这种寻址方式为I/O寻址。</p>
<p>速度由快到慢：立即寻址、寄存器寻址、存储器寻址和I/O寻址。</p>
<p>在80X86微机系统中，程序中采用的是逻辑地址方式，即内存单元的地址由段基值和偏移地址两部分组成。在实模式工作方式下，段基值由段寄存器提供，偏移地址由指令提供。</p>
<p>物理地址=段基值×10H+偏移地址</p>
<ul>
<li>段基值在段定义之后便可确定，通常由系统分配。</li>
<li>偏移地址由指令中的寻址方式确定，由下列元素组成：基址寄存器、变址寄存器、比例因子、位移量，这4部分称为偏移地址4元素。</li>
</ul>
<p>由偏移地址4种元素按某种计算方法组合形成的偏移地址称为有效地址EA（Effective Address）。</p>
<p>计算方法：EA=基址+（间址×比例因子）+位移量</p>
<ul>
<li>采用16位寻址：用BX和BP作基址寄存器，SI和DI作变址寄存器，比例因子为1（省略），位移量是8位或16位。</li>
<li>采用32位寻址： 32位的通用寄存器都可作基址寄存器或变址寄存器（ESP不用于变址），可采用2、4、8几种比例因子，可使用8位、16位和32位的位移量。</li>
</ul>
<h3 id="11种寻址方式及对应的有效地址">11种寻址方式及对应的有效地址</h3>
<table>
<thead>
<tr>
<th style="text-align:center">寻址方式</th>
<th style="text-align:center">有效地址EA</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">立即</td>
<td style="text-align:center">imm</td>
<td style="text-align:center">操作数在代码段</td>
</tr>
<tr>
<td style="text-align:center">寄存器</td>
<td style="text-align:center">通用寄存器</td>
<td style="text-align:center">操作数在CPU内部</td>
</tr>
<tr>
<td style="text-align:center">直接</td>
<td style="text-align:center">EA=直接地址</td>
<td style="text-align:center">(1)</td>
</tr>
<tr>
<td style="text-align:center">寄存器间接</td>
<td style="text-align:center">EA=(基址或变址)</td>
<td style="text-align:center">(1)</td>
</tr>
<tr>
<td style="text-align:center">寄存器相对</td>
<td style="text-align:center">EA=(基址或变址)+位移量</td>
<td style="text-align:center">(1)</td>
</tr>
<tr>
<td style="text-align:center">基址加变址</td>
<td style="text-align:center">EA=(基址+变址)</td>
<td style="text-align:center">(1)</td>
</tr>
<tr>
<td style="text-align:center">带位移的基址加变址</td>
<td style="text-align:center">EA=(基址+变址)+位移量</td>
<td style="text-align:center">(1)</td>
</tr>
<tr>
<td style="text-align:center">比例变址</td>
<td style="text-align:center">EA=(变址) x 比例因子</td>
<td style="text-align:center">(1)、(2)</td>
</tr>
<tr>
<td style="text-align:center">带位移的比例变址</td>
<td style="text-align:center">EA=(变址) x 比例因子+位移量</td>
<td style="text-align:center">(1)、(2)</td>
</tr>
<tr>
<td style="text-align:center">基址加比例变址</td>
<td style="text-align:center">EA=(基址)+(变址) x 比例因子</td>
<td style="text-align:center">(1)、(2)</td>
</tr>
<tr>
<td style="text-align:center">带位移的基址加比例变址</td>
<td style="text-align:center">EA=(基址)+(变址) x 比例因子+位移量</td>
<td style="text-align:center">(1)、(2)</td>
</tr>
</tbody>
</table>
<p>(1)操作数在内存的数据段、附加段、堆栈段。<br>
(2)只适用于32位寻址。</p>
<h3 id="寻址方式分类">寻址方式分类</h3>
<p>(1)与数据有关的寻址方式：确定内存单元的地址<br>
(2)与转移地址有关的寻址方式：确定转移地址</p>
<h3 id="立即寻址方式">立即寻址方式</h3>
<p>指定的操作数紧跟在操作码之后，直接存放在代码段中操作数可以是8位、16位。<br>
立即数在指令中表示一个常数。只能作为源操作数给目标单元（寄存器或存储单元）赋值。<br>
如：MOV  AL，20H                 ；AL ←20H<br>
MOV  AX，1234H             ；AX ←1234H</p>
<p>立即数作为指令的一部分直接从指令预取单元中取出，不需要再次访问存储器，因此这种寻址方式执行速度快。</p>
<h3 id="直接寻址方式">直接寻址方式</h3>
<p>操作数有效地址（16位或32位）直接包含在指令中，它位于操作码之后，存放在代码段中，按低地址存放低字节，高地址存放高字节。</p>
<p>两种表示形式：<br>
一种以常数形式给出有效地址（数值地址），用方括号表示；<br>
一种用符号地址代替数值地址，方括号可有可无，符号地址必须在程序中定义（变量定义语句）。</p>
<p>例如：MOV AX, [2000H]<br>
MOV BX, VALUE     或    MOV BX, [VALUE]</p>
<p>8086指令中有效地址（EA）由以下3部分组成：<br>
EA=基址＋变址＋位移量</p>
<ul>
<li>位移量（displacement）：存放在指令中的一个8位或16位的数，但它不是立即数，而是一个地址；</li>
<li>基址（base）：存放在基址寄存器（BX、BP）中的内容。它是有效地址中的基址部分，通常用于指向数据段中数组或字符串的首地址。</li>
<li>变址（index）：存放在变址寄存器（SI、DI）中的内容。通常用来指向数组中某个元素或字符串的某个字符。</li>
</ul>
<p>根据有效地址中含有的成分不同，分别构成不同的寻址方式 。<br>
在执行指令时，先由段寄存器给给出的段基值和指令给出的有效地址算出操作数的物理地址，然后到该物理单元中存取数据。</p>
<p>MOV  BL,[1020H]   ; 将数据段（DS）×10H+1020H中的8位数传送到BL中<br>
MOV  AX,[10A0H]  ; 将数据段（DS）×10H+10A0H中的16位数传送到AX中<br>
MOV  BH,ES:[0010H]  ; 将附加段（ES）×10H+0010H中的8位数传送到BH中<br>
MOV  [0060H],1234H  ; 将立即数1234H传送到数据段（DS）×10H+0060H单元中<br>
MOV  ES:[1000H],78H  ; 将立即数78H传送到附加段（ES）×10H+1000H单元中</p>
<ul>
<li>注意：<br>
直接寻址方式既可以用于源操作数，也可以用于目的操作数，但不允许在同一条指令中同时使用。</li>
</ul>
<h3 id="寄存器寻址方式">寄存器寻址方式</h3>
<p>操作数在寄存器中，CPU中的8位、16位通用寄存器都可以存放操作数。既能作为源操作数，也可以作为目的操作数，在指令中由寄存器的名称表示。<br>
功能：操作数直接存放在寄存器中。</p>
<p>如：<br>
MOV  BL,20H       ；BL ← 20H，目标为寄存器寻址<br>
MOV  AX，BX      ；AX ←（BX）</p>
<p>由于存取此类操作数在CPU内部进行，不需要访问存储器，所以执行速度较快。<br>
指令中可以引用的寄存器及其符号名称如下：<br>
8位寄存器有：AH、AL、BH、BL、CH、CL、DH和DL等；<br>
16位寄存器：AX、BX、CX、DX、SI、DI、SP、BP和段寄存器等。</p>
<ul>
<li>注意：<br>
如果指令中的源操作数和目的操作数都是寄存器寻址时，寄存器的类型要匹配。</li>
</ul>
<h3 id="寄存器间接寻址方式">寄存器间接寻址方式</h3>
<p>操作数存放在存储器中，操作数的有效地址EA存放在某个寄存器中。</p>
<p>（1）16位寻址：EA= (SI)、(DI)、 (BX)、(BP)<br>
前三个默认情况下，操作数在数据段，物理地址=（DS）×10H+（BX、SI、DI）；后面一个默认情况下，操作数在堆栈中，物理地址=（SS）×10H+（BP）。<br>
例如：<br>
MOV AX，[BX]        ； AX     ((DS)*10H+(BX))<br>
MOV AX，[BP]         ； AX     ((SS)*10H+(BP))<br>
MOV AX，ES：[BX]； AX     ((ES)*10H+(BX))<br>
MOV AX，DS：[BP]； AX     ((DS)*10H+(BP))<br>
（2）32位寻址：EA= (EAX)、(EBX)、 (ECX)、(EDX)、(ESP)、(EBP) 、(ESI)、(EDI)<br>
ESP、EBP默认操作数存放在堆栈段，其它默认操作数存放在数据段。<br>
举例：<br>
MOV  AL,[BX]   ；将数据段（DS）×10H+（BX）中８位数据传送到AL<br>
MOV  AX,[BP]　；将堆栈段（SS）×10H+（BP）中１６位数据传送到AX<br>
MOV  CH,ES:[BX]　；将附加段（ES）×10H+（BX）中８位数据传送到AX<br>
MOV  [SI],1234H　；将立即数1234H传送到数据段（DS）×10H+（SI）<br>
MOV  ES:[DI],78H ；将立即数78H传送到附加段（ES）×10H+（DI）</p>
<p>在寄存器间接寻址中，用基址寄存器BX和BP间接寻址的，又称为基址寻址。<br>
用变址寄存器SI和DI间接寻址的称为变址寻址。</p>
<ul>
<li>注意：<br>
寄存器间接寻址和寄存器寻址的区别是，前者寄存器中存放的是操作数的有效地址，后者寄存器中存放的是操作数。<br>
寄存器间接寻址既可以用于源操作数，也可以用于目的操作数，但不可以在一条指令中同时使用。</li>
</ul>
<h3 id="寄存器相对寻址方式">寄存器相对寻址方式</h3>
<p>寄存器的内容与位移量之和形成操作数的有效地址。<br>
即： EA=(寄存器)+位移量。位移量是一个带符号的数，可以是8位、16位或32位。</p>
<p>(1) 16位寻址：EA={(BX)、(BP)、(SI)、(DI)}+位移量(带符号8或16位整数)，BX默认段寄存器DS，BP默认段寄存器SS。<br>
8位位移量范围：-128~+127<br>
16位位移量范围：-32768~+32767<br>
举例：<br>
MOV  AL,[BX+10H] ；源操作数在数据段， EA=（BX）+10H<br>
MOV  AX,[BP+30H] ；源操作数在堆栈段， EA=（BP）+30H<br>
MOV  [DI+34H],1234H  ；目的操作数在数据段， EA=（DI）+34H<br>
MOV  ES:[DI+20H],78H  ; 目的操作数在附加段， EA=（DI）+20H<br>
(2) 32位寻址：EA=(8个32位通用寄存器)+位移量(带符号8、16或32位整数)</p>
<ul>
<li>注意：指令格式中的位移量既可以是常数，也可以是符号地址；允许和寄存器一起写在方括号内（“+”不能省略），也允许单独卸载方括号外（“+”可省略）。</li>
</ul>
<p>例：MOV  AX,[SI+10H]    =      MOV  AX,10H [SI]<br>
MOV  BX,[DI+COUNT]     =     MOV  BX,COUNT [DI]<br>
MOV AX，2040H[BX]  =    MOV AX，[BX+2040H]；DS段(DS)*10H+(BX)+2040H中的字数据送AX<br>
MOV AX，2040H[SI]   =   MOV AX，[SI+2040H]；DS段(DS)*10H+(SI)+2040H中的字数据送AX</p>
<p>对一维数组的操作寻址非常方便</p>
<h3 id="基址加变址寻址方式">基址加变址寻址方式</h3>
<p>EA=(基址寄存器)+(变址寄存器) ，由基址寄存器来决定默认的段寄存器（段基址寄存器）</p>
<p>举例：<br>
MOV  AL,[BX+SI] ;将数据段（DS）×10H+（BX）＋（SI）中的数据传送到AL<br>
MOV  AX,[BP+DI] ;将堆栈段（SS）×10H+（BP）＋（DI）中的数据传送到AX<br>
MOV  CH,ES:[BX+SI] ;将附加段（ES）×10H+（BX）＋（SI）中的数据传送到CH<br>
MOV  [BX+DI],34H ;将立即数34H传送到数据段（DS）×10H+（BX）＋（DI）</p>
<p>对于二维数组的操作处理很方便</p>
<h3 id="带位移的基址加变址寻址方式">带位移的基址加变址寻址方式</h3>
<p>EA=(变址寄存器)+(基址寄存器)+偏移量</p>
<h3 id="比例变址寻址">比例变址寻址</h3>
<p>EA=（变址寄存器）×比例因子，比例因子可取2、4或8<br>
例如：MOV EAX, [ESI*4]</p>
<h3 id="带位移的比例变址寻址">带位移的比例变址寻址</h3>
<p>EA=(变址寄存器) ×比例因子+位移量<br>
例如：<br>
MOV  EAX，1200H[ESI<em>4]<br>
MOV  EAX, TABLE[ESI</em>4]</p>
<h3 id="基址加比例变址寻址32位寻址">基址加比例变址寻址（32位寻址）</h3>
<p>EA= (基址寄存器) +(变址寄存器)<em>比例因子<br>
如：MOV  AX，[ESI+EBX</em>4]（默认段DS）</p>
<h3 id="带位移的基址加比例变址寻址">带位移的基址加比例变址寻址</h3>
<p>EA =(基址寄存器)+(变址寄存器)<em>比例因子+位移量<br>
如：MOV AX，[EBX+EDI</em>8+40H]<br>
MOV ECX，2000H[EDX*4][EAX]</p>
<ul>
<li>比例变址寻址、带位移的比例变址寻址、基址加比例变址寻址、带位移的基址加比例变址寻址只适用于32位寻址方式。</li>
</ul>
<h3 id="寄存器间接寻址的默认段">寄存器间接寻址的默认段</h3>
<table>
<thead>
<tr>
<th style="text-align:center">段寄存器</th>
<th style="text-align:center">16位寄存器</th>
<th style="text-align:center">32位寄存器</th>
<th style="text-align:center">寄存器寻址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CS</td>
<td style="text-align:center">IP</td>
<td style="text-align:center">EIP</td>
<td style="text-align:center">代码段</td>
</tr>
<tr>
<td style="text-align:center">SS</td>
<td style="text-align:center">SP或BP</td>
<td style="text-align:center">ESP或EBP</td>
<td style="text-align:center">堆栈段</td>
</tr>
<tr>
<td style="text-align:center">DS</td>
<td style="text-align:center">BX、DI、SI</td>
<td style="text-align:center">EAX、EBX、ECX、EDX、EDI、ESI</td>
<td style="text-align:center">数据段</td>
</tr>
<tr>
<td style="text-align:center">ES</td>
<td style="text-align:center">串指令的DI</td>
<td style="text-align:center">串指令的EDI</td>
<td style="text-align:center">附加段</td>
</tr>
<tr>
<td style="text-align:center">FS</td>
<td style="text-align:center">无默认值</td>
<td style="text-align:center">无默认值</td>
<td style="text-align:center">附加段</td>
</tr>
<tr>
<td style="text-align:center">GS</td>
<td style="text-align:center">无默认值</td>
<td style="text-align:center">无默认值</td>
<td style="text-align:center">附加段</td>
</tr>
</tbody>
</table>
<h2 id="指令系统">指令系统</h2>
<p>8086的指令系统分为整数指令、浮点数指令和操作系统指令。</p>
<ul>
<li>整数指令：数据传送类、算术运算类、逻辑运算类、串操作类、控制转移类、处理器控制类指令等。</li>
<li>浮点数指令：数据传送、算术运算、比较、超越函数、常量、控制等指令。</li>
</ul>
<h3 id="指令操作数符号说明">指令操作数符号说明：</h3>
<p>ac: 累加器(AL, AX)<br>
reg  ：通用寄存器。长度可以是8位、16位<br>
reg8、reg16：8位、16位通用寄存器<br>
seg  ：段寄存器<br>
mem   ：存储器。长度可以是8位、16位<br>
mem8、mem16 ：8位、16位存储器<br>
imm   ：立即数。长度可以是8位、16位<br>
imm8、imm16：8位、16位<br>
Port: I/O端口<br>
src：源操作数<br>
dst：目标操作数<br>
OP1，OP2，OP3：操作数<br>
exp: 表达式</p>
<h3 id="与运算有关的标志">与运算有关的标志</h3>
<p>标志寄存器FR中存放运算结果的属性。<br>
CF：进位/借位标志。加、减运算最高位产生进位/借位时置1。<br>
AF：辅助进位/借位标志。加、减运算时低半字节位产生进位<br>
/借位时置1。<br>
OF：溢出标志。有符号数二进制加、减运算结果超出范围时<br>
置1。<br>
ZF：零标志。结果为零时置1。<br>
SF：符号标志。结果为负时置1。<br>
PF：奇偶标志。结果“1”的个数为偶数时置1。</p>
<h3 id="指令执行对标志位影响的符号说明">指令执行对标志位影响的符号说明：</h3>
<p>x ：表示相应标志位状态依运算或操作结果决定<br>
0 : 表示相应标志位无条件清“0”<br>
1 ：表示相应标志位无条件置“1”<br>
u : 表示相应标志位状态未定义,状态随机</p>
<ul>
<li>: 表示相应标志位状态不受影响,保持原状态<br>
r ： 恢复原来保存的值 （如执行POPF）</li>
</ul>
<h3 id="数据传送指令">数据传送指令</h3>
<p>数据传送指令负责把数据、地址或立即数传送到寄存器、存储器或端口号寄存器。它相对于高级语言里的赋值语句。<br>
通用数据传送：MOV    PUSH     POP    XCHG<br>
累加器专用传送（输入输出）：  IN    OUT    XLAT<br>
地址传送：  LEA   LDS    LES<br>
标志寄存器传送：  LAHF    SAHF      PUSHF     POPF<br>
类型转换指令：CBW   CWD</p>
<ul>
<li>这类指令一般不影响标志位</li>
</ul>
<h3 id="通用数据传送指令">通用数据传送指令</h3>
<h4 id="mov传送指令">MOV传送指令</h4>
<p>格式： MOV    Seg/Reg/Mem， Seg/Reg/Mem/Imm<br>
其中：Seg—（段寄存器），Reg—Register（通用寄存器），Mem—Memory（存储器），Imm—Immediate（立即数），它们可以是8位、16位。<br>
功能：指令的功能是把源操作数（第二操作数）的值传给目的操作数（第一操作数）。指令执行后，目的操作数的值被改变，而源操作数的值不变。在存储单元是该指令的一个操作数时，该操作数的寻址方式可以是任意一种存储单元寻址方式。</p>
<ul>
<li>注意：对MOV指令有以下几条具体规定，其中有些规定对其它指令也同样有效。<br>
1）两个操作数的数据类型要相同，要同为8位、16位<br>
2）两个操作数不能同时为段寄存器<br>
3）代码段寄存器CS不能为目的操作数，但可作为源操作数<br>
4）立即数不能直接传给段寄存器<br>
5）立即数不能作为目的操作数<br>
6）指令指针IP，不能作为MOV指令的操作数<br>
7）两个操作数不能同时为存储单元</li>
</ul>
<h4 id="xchg数据交换指令">XCHG数据交换指令</h4>
<p>指令的格式为：XCHG	reg/mem，reg/mem<br>
功能：将源操作数与目的操作数相交换。 （字节或字）<br>
说明：交换能在通用寄存器之间、通用寄存器与存储器之间进行。但段寄存器和立即数不能作为操作数。存储器之间不能直接进行数据交换。</p>
<h4 id="堆栈指令">堆栈指令</h4>
<p>堆栈是一个特殊的存储区域，用于存储在程序执行过程中需要保存的信息，如在子程序调用过程中的“断点”和“现场”等。<br>
堆栈采用的是“后进先出”向低地址方向生成的数据结构，即栈底为高地址方向，栈顶为低地址方向。由堆栈指针SP指示栈顶的数据，当堆栈为空时，SP指向栈底。堆栈以字、双字为单位存取数据（不允许字节数据）。<br>
它主要有两大类操作：进栈操作和出栈操作。</p>
<h5 id="入栈指令push">入栈指令PUSH</h5>
<p>指令格式：PUSH　Seg/Reg/Mem<br>
一个字进栈，系统自动完成两步操作：SP←SP-2，（SP）←操作数；<br>
功能：将寄存器、段寄存器或存储器中的一个字数据压入堆栈，堆栈指针减2。</p>
<h5 id="出栈指令pop">出栈指令POP</h5>
<p>指令格式：POP　Seg/Reg/Mem<br>
弹出一个字，系统自动完成两步操作： 操作数←（SP)，SP←SP+2；<br>
功能：将栈顶元素弹出送至某一寄存器、段寄存器（除CS外）或存储器，堆栈指针加2。</p>
<h4 id="其他堆栈操作指令">其他堆栈操作指令</h4>
<h5 id="所有寄存器进栈指令pusha">所有寄存器进栈指令PUSHA</h5>
<p>指令的格式为：PUSHA<br>
功能：16位通用寄存器依次进栈，次序为AX、CX、DX、BX，指令执行前的SP、BP、SI、DI。指令执行后(SP)-16→(SP)仍指向栈顶。</p>
<h5 id="所有寄存器出栈指令popa">所有寄存器出栈指令POPA</h5>
<p>指令的格式为：POPA<br>
功能：16位通用寄存器依次出栈，次序为DI、SI、BP、SP，指令执行前的BX、DX、CX、AX。指令执行后(SP)+16→(SP) 仍指向栈顶。需要说明的是：SP出栈只是修改了指针使其后的BX能够出栈，而堆栈中原先由PUSHA指令存入的SP的原始内容被丢弃，并未真正送到SP寄存器中。</p>
<ul>
<li>上述两条堆栈指令均不影响标志位</li>
</ul>
<h4 id="累加器专用传送指令">累加器专用传送指令</h4>
<h5 id="xlat-查表转换指令">XLAT   查表转换指令</h5>
<p>转换指令有两个隐含操作数BX和AL。<br>
格式：XLAT    OPR 或  XLAT<br>
执行操作： AL←（（BX）+（AL））<br>
功能：BX指向表的首地址(DS段内)，AL装入要转换的代码在表中的序号，并将XLAT指令执行的结果存于AL中。 （查表得到字节数据送入AL中。）</p>
<h4 id="io数据传送指令">I/O数据传送指令</h4>
<p>这组指令仅限于使用累加器AX或AL传送信息。</p>
<p>8086中，所有I/O端口与CPU之间的通信都由IN和OUT指令来完成。其中IN指令完成从I/O端口到CPU的数据传送（输入），OUT指令完成从CPU到I/O端口的数据传送（输出）。外部设备最多有216个I/O端口，端口号为0000～0FFFFH。其中前256个端口（00～0FFH）可以直接在指令中指定，这就是所谓的长格式。当端口号≥256时，只能使用短格式，此时必须先将端口号放到DX寄存器中（端口号为0000～0FFFFH），然后再用IN和OUT指令来传送信息。<br>
（注意：这里的端口号或DX的内容均为地址，而传送的是端口中的信息，在使用短格式时，DX内容就是端口号本身）。</p>
<h5 id="输入指令in将端口的数据送入cpu累加器">输入指令IN（将端口的数据送入CPU累加器）</h5>
<p>输入指令用来从指定的外设寄存器取信息送入累加器。它有几种形式：</p>
<p>长格式：         IN   AL, PORT （字节）<br>
（00H~FFH）      IN   AX, PORT  （字）<br>
执行操作：（AL）← （PORT）                  （字节）<br>
（AX） ←（PORT+1,  PORT）（字）</p>
<p>短格式：      IN   AL, DX   （字节）<br>
（大于00FFH）  IN   AX, DX   （字）<br>
执行操作：（AL）←（（DX））               （字节）<br>
（AX）←（（DX）+1,（DX））（字）</p>
<ul>
<li>注意：该指令的作用是从端口中读入一个字节或字，并保存在寄存器AL或AX中。如果某输入设备的端口地址在0 ~ 255（00H ~ FFH）范围之内，那么，可在指令IN中直接给出，否则，要把该端口地址先存入寄存器DX中，然后在指令中由DX来给出其端口地址。</li>
</ul>
<p>例如：<br>
IN   AL， 60H  ；从端口60H读入一个字节到AL中<br>
IN   AX，20H  ；把端口20H、21H按“高高低低”组成的字读入AX<br>
MOV   DX，2F8H<br>
IN    AL，DX ；从端口2F8H读入一个字节到AL中<br>
IN    AX，DX；把端口2F8H、2F9H按“高高低低”组成的字读入AX<br>
IN  AL，0FAH   ；从端口0FAH读一个字节到AL<br>
MOV DX，3AEH；  I/O地址大于255时．应通过DX间接寻址，不允许加放括号<br>
IN  AX，DX   ；从DX指定的端口读入一个字到AX</p>
<h5 id="out输出指令将cpu累加器中数据写入端口">OUT输出指令（将CPU累加器中数据写入端口）</h5>
<p>输出指令用来把累加器的内容送往指定的外设存储器，它有几种形式：</p>
<p>长格式：       OUT   PORT, AL  （字节）<br>
（00H~FFH）    OUT   PORT, AX  （字）<br>
执行操作：（PORT）←（AL）                 （字节）<br>
（PORT+1, PORT）←（AX）（字）</p>
<p>短格式：        OUT   DX, AL  （字节）<br>
（大于00FFH）    OUT   DX, AX  （字）<br>
执行操作：（（DX））←（AL）               （字节）<br>
（（DX）+1,（DX））←（AX）（字）</p>
<ul>
<li>注意：该指令的作用是把寄存器AL或AX的内容输出到指定端口。如果某输出设备的端口地址在0~255范围之内，那么，可在指令OUT中直接给出，否则，要把该端口地址先存入寄存器DX中，然后在指令中由DX来给出其端口地址。</li>
</ul>
<p>例如：<br>
OUT   61H，AL；把AL的内容输出到端口61H中<br>
OUT   20H，AX；把AX的内容输出到端口20H、21H中<br>
MOV  DX， 3C0H<br>
OUT   DX，AL；把AL的内容输出到端口3C0H中<br>
OUT   DX，AX；把AX的内容输出到端口3C0H、3C1H中</p>
<h4 id="地址传送指令">地址传送指令</h4>
<p>这一组指令完成将地址送到指定的寄存器的功能。</p>
<h5 id="有效地址送寄存器指令lea-load-effective-address">有效地址送寄存器指令LEA (Load Effective Address)</h5>
<p>指令的格式为：LEA	dst，src<br>
功能：将源操作数的有效地址送到指定的寄存器中。<br>
说明：①源操作数必须是一个内存操作数；②目的操作数必须是一个16位的通用寄存器。这条指令通常用来建立串操作指令所须的寄存器指针。</p>
<h5 id="指针送寄存器及相应段寄存器指令lds和les">指针送寄存器及相应段寄存器指令LDS和LES</h5>
<h6 id="lds-load-pointer-into-ds">LDS (Load pointer into DS)</h6>
<p>指令的格式为： LDS  REG，OPS<br>
功能：完成一个地址指针的传送。地址指针包括段地址部分和偏移量部分。指令将段地址（EA+2）送入DS，偏移量部分(EA)送入一个16位的基址寄存器或变址寄存器。<br>
要求：源操作数必须是存储器寻址，目的操作数是16位通用寄存器。<br>
例如：LDS  SI，[BX] ；将把BX所指的32位地址指针的段地址部分送入DS，偏移量部分送入SI。<br>
本组指令的目的寄存器不允许使用段寄存器，且不影响标志位。</p>
<h6 id="les-load-pointer-into-es">LES (Load pointer into ES)</h6>
<p>指令的格式为： LES  REG，OPS<br>
这条指令除将地址指针的段地址部分送入ES外，与LDS类似。<br>
例如： LES  DI，[BX+COUNT]</p>
<h4 id="标志寄存器传送指令">标志寄存器传送指令</h4>
<h5 id="标志送ah指令-lahf">标志送AH指令： LAHF</h5>
<p>执行操作：（AH）←（FLAGS的低八位，只送状态位进入对应位置，其余位空着）</p>
<h5 id="ah送标志寄存器指令sahf">AH送标志寄存器指令：SAHF</h5>
<p>执行操作：   （FLAGS的低八位）←（AH）</p>
<h5 id="标志进栈指令pushf">标志进栈指令：PUSHF</h5>
<p>执行操作： （SP）←（SP） - 2<br>
（（SP）+1,  （SP））←（FLAGS）</p>
<h5 id="标志出栈指令popf">标志出栈指令：POPF</h5>
<p>执行操作： （FLAGS）←（（SP）+1,（SP））<br>
（SP）←（SP）+ 2</p>
<h3 id="算术运算指令">算术运算指令</h3>
<p>算术运算指令是反映CPU计算能力的一组指令，也是编程时常使用的一组指令。它包括：加、减、乘、除及其相关的辅助指令。</p>
<p>该组指令的操作数可以是8位、16位,也可以是压缩、非压缩BCD码。算术运算指令一般会影响FR 寄存器中的状态标志位。</p>
<p>加法指令      ADD、ADC、INC<br>
减法指令      SUB、SBB、DEC、NEG、CMP<br>
乘法指令      MUL、IMUL<br>
除法指令      DIV、IDIV<br>
十进制调整指令      DAA、DAS、 AAA、AAS、AAM、AAD</p>
<h4 id="加法指令">加法指令</h4>
<h5 id="不带进位的加法指令-add-dstsrc">不带进位的加法指令：    ADD  DST，SRC</h5>
<p>功能：将目的操作数与源操作数相加，结果存入目的地址中，源地址的内容不改变。<br>
执行操作：（DST）← （SRC）+（DST）</p>
<h5 id="带进位加法指令-adc-dstsrc">带进位加法指令：  ADC  DST，SRC</h5>
<p>功能：将目的操作数加源操作数再加低位进位，结果送目的地址。执行操作：（DST） （SRC）+（DST）+ CF</p>
<h5 id="加1指令-inc-dst">加1指令：        INC  DST</h5>
<p>功能：将目的操作数加1，结果送目的地址。<br>
执行操作：  （DST）← （DST）+ 1<br>
注意:  除INC指令不影响CF标志外，均对条件(状态)标志位有影响。<br>
INC常用于: 寄存器或存储器单元自增，修改计数器或地址, 比加法指令简便、效率高。</p>
<h4 id="减法指令">减法指令</h4>
<h5 id="减法指令-sub-dstsrc">减法指令： SUB  DST，SRC</h5>
<p>功能：目的操作数减去源操作数，结果存于目的地址，源地址的内容不变。<br>
执行操作：  （DST）←（DST）- （SRC）</p>
<h5 id="带借位减法指令-sbb-dstsrc">带借位减法指令： SBB  DST，SRC</h5>
<p>功能：目的操作数减源操作数再减低位借位CF，结果送目的地址<br>
执行操作：  （DST）←（DST） - （SRC）- CF</p>
<h5 id="减1指令-dec-opr">减1指令： DEC  OPR</h5>
<p>功能：将目的操作数减1，结果送目的地址。<br>
执行操作：   （OPR） ← （OPR） - 1</p>
<h5 id="求补指令-neg-opr">求补指令： NEG  OPR</h5>
<p>功能：将目的操作数的每一位求反（包括符号位）后加1，结果送目的地址。<br>
（正变负，用补码表示；负变正，用源码表示。）<br>
执行操作：（OPR） ←  - （OPR）<br>
NEG指令的功能:改变操作数的符号可用于取操作数的绝对</p>
<h5 id="比较指令-cmp-opr1-opr2">比较指令： CMP  OPR1, OPR2</h5>
<p>功能：目的操作数减源操作数，结果只影响标志位，不送入目的地址。比较指令执行后，源操作数和目的操作数都保持不变，程序通过测试CMP指令执行后形成的标志位来判断两数的大小。<br>
执行操作：（OPR1） - （OPR2）</p>
<p>注意:  除DEC指令不影响 CF标志外，均对状态标志位有影响。</p>
<table border=0 cellpadding=0 cellspacing=0 width=448 style='border-collapse:
 collapse;table-layout:fixed;width:336pt'>
 <col width=64 span=7 style='width:48pt'>
 <tr height=18 style='height:13.8pt'>
  <td colspan=3 height=18 class=xl6329631 width=192 style='height:13.8pt;
  width:144pt'>标志位</td>
  <td class=xl6329631 width=64 style='border-left:none;width:48pt'>CF</td>
  <td class=xl6329631 width=64 style='border-left:none;width:48pt'>ZF</td>
  <td class=xl6329631 width=64 style='border-left:none;width:48pt'>SF</td>
  <td class=xl6329631 width=64 style='border-left:none;width:48pt'>OF</td>
 </tr>
 <tr height=18 style='height:13.8pt'>
  <td colspan=3 height=18 class=xl6329631 style='height:13.8pt'>A = B</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>1</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
 </tr>
 <tr height=18 style='height:13.8pt'>
  <td colspan=2 rowspan=2 height=36 class=xl6329631 style='height:27.6pt'>无符号数</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>A&gt;B</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>-</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>-</td>
 </tr>
 <tr height=18 style='height:13.8pt'>
  <td height=18 class=xl6329631 style='height:13.8pt;border-top:none;
  border-left:none'>A&lt;B</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>1</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>-</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>-</td>
 </tr>
 <tr height=18 style='height:13.8pt'>
  <td rowspan=6 height=108 class=xl6329631 style='height:82.8pt;border-top:
  none'>有符号数</td>
  <td rowspan=2 class=xl6329631 style='border-top:none'>A、B同号</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>A&gt;B</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>-</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
 </tr>
 <tr height=18 style='height:13.8pt'>
  <td height=18 class=xl6329631 style='height:13.8pt;border-top:none;
  border-left:none'>A&lt;B</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>-</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>1</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
 </tr>
 <tr height=18 style='height:13.8pt'>
  <td rowspan=4 height=72 class=xl6329631 style='height:55.2pt;border-top:none'>A、B异号</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>A&gt;B</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>-</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
 </tr>
 <tr height=18 style='height:13.8pt'>
  <td height=18 class=xl6329631 style='height:13.8pt;border-top:none;
  border-left:none'>A&lt;B</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>-</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>1</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
 </tr>
 <tr height=18 style='height:13.8pt'>
  <td height=18 class=xl6329631 style='height:13.8pt;border-top:none;
  border-left:none'>A&gt;B</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>-</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>1</td>
 </tr>
 <tr height=18 style='height:13.8pt'>
  <td height=18 class=xl6329631 style='height:13.8pt;border-top:none;
  border-left:none'>A&lt;B</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>-</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>1</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>1</td>
 </tr>
 <![if supportMisalignedColumns]>
 <tr height=0 style='display:none'>
  <td width=64 style='width:48pt'></td>
  <td width=64 style='width:48pt'></td>
  <td width=64 style='width:48pt'></td>
  <td width=64 style='width:48pt'></td>
  <td width=64 style='width:48pt'></td>
  <td width=64 style='width:48pt'></td>
  <td width=64 style='width:48pt'></td>
 </tr>
 <![endif]>
</table>
<p>说明：<br>
（1）无论A和B是有符号数还是无符号数，若ZF=1且CF=SF=OF=0.则A=B。<br>
（2）A、B为无符号数，判断他们的大小，使用CF和ZF。若CF=0且ZF=0，则A&gt;B；若CF=1且ZF=0，则A&lt;B。<br>
（3）A、B为有符号数，判断他们的大小，使用SF、OF和ZF。当A、B同号或异号时，SF和OF形成的标志位有区别，若ZF=0且OF⊕SF=1，则A&lt;B；若ZF=0且OF⊕SF=0，则A&gt;B。</p>
<h4 id="乘法指令">乘法指令</h4>
<p>乘法指令影响OF和CF标志：<br>
MUL指令——若乘积的高一半（AH或DX）为0，则OF=CF=0；否则OF=CF=1。（用来检查字节相乘的结果是字节还是字，或字相乘的结果是字还是双字）<br>
IMUL指令——若乘积的高一半是低一半的符号扩展，则OF=CF=0；否则均为1。</p>
<p>乘法指令对其他状态标志没有定义：<br>
指令执行后这些标志是任意的、不可预测（就是谁也不知道是0还是1）。<br>
对标志没有影响是指令的执行不改变标志的状态。<br>
注意:乘法指令中的源操作数可以是除立即数以外的任何一种寻址方式.</p>
<h5 id="无符号数乘法指令-mul-src">无符号数乘法指令：        MUL   SRC</h5>
<p>功能： 若是字节数据相乘，（AL）与SRC相乘得到字数据存入AX中；若是字数据相乘，则（AX）与SRC相乘得到双字数据，高字存入DX、低字存入AX中。</p>
<p>执行操作：字节操作数  （AX）←（AL） ×（SRC）<br>
字操作数      （DX，AX）←（AX） × （SRC）</p>
<h5 id="有符号数乘法指令-imul-src">有符号数乘法指令：        IMUL  SRC</h5>
<p>注：IMUL指令除计算对象是带符号二进制数外，其他都与MUL一样，但计算结果不同。</p>
<h4 id="除法指令">除法指令</h4>
<p>当被除数远大于除数时，所得的商就有可能超出它所能表达的范围。如果存放商的寄存器AL/AX不能表达，便产生溢出，8086CPU中就产生编号为0的内部中断——除法错中断。</p>
<p>说明：<br>
1）对DIV指令，除数为0，或者在字节除时商超过8位，或者在字除时商超过16位，则发生除法溢出。<br>
2）对IDIV指令，除数为0，或者在字节除时商不在-128～127范围内，或者在字除时商不在-32768～32767范围内，则发生除法溢出。</p>
<h5 id="无符号数除法指令-div-src">无符号数除法指令：   DIV  SRC</h5>
<h5 id="带符号数除法指令-idiv-src">带符号数除法指令：   IDIV  SRC</h5>
<p>执行操作：<br>
字节操作  （AL）←（AX）/（SRC）的商<br>
（AH）←（AX）/（SRC） 的余数</p>
<p>字操作      （AX）←（DX：AX）/（SRC）的商<br>
（DX） ←（DX：AX）/（SRC） 的余数</p>
<p>注意：除法指令DIV和IDIV虽然对标志的影响未定义，但可产生溢出。</p>
<p>例：<br>
无符号除法：<br>
MOV AX，0400H      ；AX=400H=1024<br>
MOV BL，0B4H         ；BL=B4H=180<br>
DIV BL                          ；商AL＝05H＝5；余数AH＝7CH＝124</p>
<p>有符号除法：<br>
MOV AX，0400H      ；AX=400H=1024<br>
MOV BL，0B4H         ；BL=B4H=－76<br>
IDIV BL                         ；商AL＝F3H＝－13；余数AH＝24H＝36</p>
<p>注：带符号除法的余数符号和被除数符号相同。</p>
<h4 id="类型转换指令指令">类型转换指令指令</h4>
<h5 id="字节扩展为字指令-cbw-al-ax">字节扩展为字指令  CBW          AL ← AX</h5>
<p>执行操作： 若（AL）的最高有效位为0，则（AH)= 00H<br>
若（AL）的最高有效位为1，则（AH)= FFH</p>
<h5 id="字扩展成双字指令cwd-ax-dxax">字扩展成双字指令CWD         AX ← （DX,AX）</h5>
<p>执行操作：若（AX）的最高有效位为0，则（DX)= 0000H<br>
若（AX）的最高有效位为1，则（DX)= FFFFH</p>
<h4 id="十进制调整指令">十进制调整指令</h4>
<p>BCD码（8421码）：用二进制编码的十进制数，又称二--十进制数</p>
<p>压缩的BCD码（组合型）：用 4 位二进制数表示 1 位十进制数<br>
例： （59）<sub>10</sub> ＝（0101 1001）<sub>BCD</p>
<p>非压缩的BCD码（非组合型）：用 8 位二进制数表示 1 位十进制数<br>
例：（ 59 ）<sub>10</sub> ＝ （0000 0101   0000 1001 ）<sub>BCD</p>
<h5 id="压缩的bcd码调整指令">压缩的BCD码调整指令</h5>
<p>DAA      加法的十进制调整指令<br>
（将AL中的和调整为压缩BCD数）<br>
DAS      减法的十进制调整指令<br>
（将AL中的差调整为压缩BCD数）</p>
<h5 id="非压缩的bcd码调整指令">非压缩的BCD码调整指令</h5>
<p>AAA      加法的ASCII码调整指令<br>
（将AL中的和调整为非压缩BCD数）<br>
AAS      减法的ASCII码调整指令<br>
(将AL中的差调整为非压缩BCD数)<br>
AAM      乘法的ASCII码调整指令<br>
(将AL中的积调整为非压缩BCD)<br>
AAD      除法的ASCII码调整指令<br>
(调整AX中的被除数,相除的商即为非压缩BCD数)</p>
<h4 id="进位标志cfcarry-flag">进位标志CF（Carry Flag）</h4>
<p>当运算结果的最高有效位有进位（加法）或借位（减法）时，进位标志置1，即CF = 1；否则CF = 0。</p>
<p>例如：<br>
3AH + 7CH＝B6H，没有进位：CF = 0<br>
AAH + 7CH＝（1）26H，有进位：CF = 1</p>
<h4 id="零标志zfzero-flag">零标志ZF（Zero Flag）</h4>
<p>若运算结果为0，则ZF = 1，否则ZF = 0。<br>
例如：<br>
3AH + 7CH＝B6H，结果不是零：ZF = 0<br>
86H + 7CH＝（1）00H，结果是零：ZF = 1<br>
注意：ZF为1表示的结果是0。</p>
<h4 id="符号标志sfsign-flag">符号标志SF（Sign Flag）</h4>
<p>运算结果最高位为1，则SF = 1；否则SF = 0。<br>
例如：<br>
3AH + 7CH＝B6H，最高位D7＝1：SF = 1<br>
86H + 7CH＝（1）00H，最高位D7＝0：SF = 0</p>
<p>注意：有符号数据利用最高有效位表示数据的符号。所以，最高有效位就是符号标志的状态。</p>
<h4 id="奇偶标志pfparity-flag">奇偶标志PF（Parity Flag）</h4>
<p>当运算结果最低字节中“1”的个数为零或偶数时，PF = 1；否则PF = 0。<br>
例如：<br>
3AH + 7CH＝B6H＝10110110B，<br>
结果中有5个1，是奇数：PF = 0</p>
<p>注意：PF标志仅反映最低8位中“1”的个数是偶或奇，即使是进行16位字操作。</p>
<h4 id="辅助进位标志afauxiliary-carry-flag">辅助进位标志AF（Auxiliary Carry Flag）</h4>
<p>运算时D3位（低半字节）有进位或借位时，AF = 1；否则AF = 0。</p>
<p>例如：<br>
3AH + 7CH＝B6H，D3有进位：AF = 1</p>
<p>注意：这个标志主要由处理器内部使用，用于十进制算术运算指令中，用户一般不必关心。</p>
<h4 id="溢出标志ofoverflow-flag">溢出标志OF（Overflow Flag）</h4>
<p>若算术运算的结果有溢出，则OF=1；否则 OF＝0。<br>
例如：<br>
3AH + 7CH＝B6H，产生溢出：OF = 1<br>
AAH + 7CH＝（1）26H，没有溢出：OF = 0</p>
<h3 id="逻辑指令">逻辑指令</h3>
<p>逻辑指令包括逻辑运算指令和移位操作指令两大类。<br>
其中逻辑运算指令是一组重要的指令，它包括：逻辑与（AND）、逻辑或（OR）、逻辑非（NOT）和异或指令（XOR），逻辑运算指令也是经常使用的指令。<br>
移位操作指令是另一组经常使用的指令，它包括算术移位、逻辑移位、双精度移位、循环移位和带进位的循环移位等五大类。</p>
<h4 id="逻辑运算指令">逻辑运算指令</h4>
<p>AND(and)				逻辑与<br>
OR(or)				逻辑或<br>
NOT(not)				逻辑非<br>
XOR(exclusive or)	                        异或<br>
TEST(test)			            测试</p>
<p>除NOT外，都影响某些标志位(OF、CF、PF、SF、ZF)，对AF无影响或随机。</p>
<h5 id="逻辑与指令and-dstregmem-srcregmemimm">逻辑与指令：AND  DST（reg/mem）, SRC（reg/mem/imm）</h5>
<p>功 能：把源操作数中的每位二进制与目的操作数中的相应二进制进行逻辑“与操作”，操作结果存入目标操作数中。<br>
执行操作：   （DST）←（DST）与（SRC）<br>
用途：该指令用于清除目的操作数中与源操作数置0的对应位。（想让哪位为0，哪位与0作与运算）</p>
<h5 id="逻辑或指令or-dstregmem-srcregmemimm">逻辑或指令：OR  DST（reg/mem）, SRC（reg/mem/imm）</h5>
<p>功 能：把源操作数中的每位二进制与目的操作数中的相应二进制进行逻辑&quot;或操作&quot;，操作结果存入目标操作数中。<br>
执行操作：   （DST）←（DST）或（SRC）<br>
用途：该指令用于设置目的操作数中与源操作数置1的对应位。（想让哪位为1，哪位与1作或运算。）</p>
<h5 id="异或指令-xor-dstregmem-srcregmemimm">异或指令：    XOR  DST（reg/mem）, SRC（reg/mem/imm）</h5>
<p>功能：把源操作数中的每位二进制与目的操作数中的相应二进制进行逻辑“异或操作”，操作结果存入目标操作数中。<br>
执行操作：    （DST）← （DST） 异或 （SRC）<br>
用途：该指令用于将目的操作数中与源操作数置1的对应位取反。（想让哪位取反，哪位与1作异或运算。）</p>
<h5 id="逻辑非指令-not-opr-regmem">逻辑非指令： NOT  OPR （reg/mem）</h5>
<p>功能：将目的地址中的内容逐位取反后送入目的地址。<br>
执行操作：    （OPR）←   非（OPR）</p>
<h5 id="测试指令-test-opr1regopr2regmemimm">测试指令：    TEST  OPR1（reg），OPR2(reg/mem/imm)</h5>
<p>功能：把二个操作数进行逻辑“与”操作，并根据运算结果设置相应的标志位，但并不保存该运算结果，所以，不会改变指令中的操作数。<br>
执行操作： （OPR1） 与 （OPR2）</p>
<h4 id="移位指令">移位指令</h4>
<p>移位指令包括算术移位指令、逻辑移位指令和循环移位指令，分别进行左移和右移操作。这些指令均有统一的语句格式：<br>
操作符   OPR，1<br>
或    操作符   OPR，CL<br>
其功能为将目的操作数的所有位按操作符规定的方式移动1位或按寄存器CL规定的次数（0~255）移动，结果送入目的地址。目的操作数是8位（或16位）的寄存器数据或存储器数据。</p>
<h5 id="移位指令-2">移位指令</h5>
<p>①逻辑左移SHL（Shift Logical Left）<br>
②逻辑右移SHR（Shift Logical Right）<br>
它们的指令格式如下：<br>
SHL/SHR　OPR(reg/mem), CL/Imm8<br>
受影响的标志位：CF、OF、PF、SF和ZF（AF无定义）。<br>
逻辑左移/右移指令只有它们的移位方向不同，移位后空出的位都补0，移出位进入CF。看作无符号数进行移位。</p>
<p>逻辑移位指令常用于无符号数*2或/2</p>
<p>③ 算术左移指令SAL<br>
④ 算术右移指令SAR<br>
它们的指令格式如下：<br>
SAL/SAR　OPR(reg/mem), CL/Imm<br>
受影响的标志位：CF、OF、PF、SF和ZF（AF无定义）。<br>
功能：算术左移SAL把目的操作数的低位向高位移，空出的低位补0，最后移出位保存在CF中；算术右移SAR把目的操作数的高位向低位移，空出的高位补符号位，使数据性质不变，最后移出位保存在CF中。看作有符号数进行移位。</p>
<p>算术移位指令常用于带符号数*2或/2</p>
<h5 id="循环移位指令">循环移位指令</h5>
<p>① 循环左移指令ROL<br>
② 循环右移指令ROR<br>
ROL/ROR　OPR(reg/mem), CL/Imm<br>
循环左移/右移指令只是移位方向不同，不带CF的移位，但它们最后移出的位要进入CF，并且填补空出的位。</p>
<p>③ 带进位的循环左移指令RCL<br>
④ 带进位的循环右移指令RCR<br>
指令的格式：RCL/RCR　OPR(reg/mem), CL/Imm<br>
受影响的标志位：CF和OF<br>
带进位的循环左移／右移指令只有移位的方向不同，它们都用原CF的值填补空出的位，移出的位再进入CF。</p>
<h4 id="串操作指令">串操作指令</h4>
<p>存储器中的地址连续的若干单元的字符或数据称为字符串或数据串。<br>
串操作指令就是用来对串中每个字符或数据进行操作的指令。<br>
字符串操作指令的实质是对一片连续存储单元进行处理。<br>
串操作指令的操作数是主存中连续存放的数据串。（String）——即在连续的主存区域中，字节或字的序列。<br>
串操作指令的操作对象是以字（W）为单位的字串，或是以字节（B）为单位的字节串。每完成一个字节（或字）的操作后，能够自动修改指针，以便执行下一个字节（或字）的操作。<br>
串操作包括串传送（MOVSB/MOVSW）、串装入（LODSB/LODSW） 、串存储（STOSB/STOSW） 、串比较（CMPSB/CMPSW） 、串扫描（SCASB/SCAW）等。<br>
串指令可完成两个存储单元之间的传送和比较操作（也只有串指令才可以）。</p>
<p>源操作数用寄存器SI寻址，默认在数据段DS中，但允许段超越。DS:SI（寻址源串）<br>
目的操作数用寄存器DI寻址，默认在附加段ES中，不允许段超越。ES:DI （寻址目的串）<br>
每执行一次串操作指令，SI和DI将自动修改：<br>
±1（对于字节串）或±2（对于字串）<br>
执行指令CLD后，DF = 0，地址指针增1或2<br>
执行指令STD后，DF = 1，地址指针减1或2</p>
<h5 id="与-rep-配合工作的-movs-stos-lods的指令">与 REP 配合工作的 MOVS / STOS / LODS的指令</h5>
<p>REP MOVS：将数据段中的整串数据传送到附加段中。</p>
<p>源串（数据段）→ 目的串（附加段）<br>
执行 REP MOVS 之前，应先做好：<br>
1）   源串首地址（末地址）→ SI<br>
2）  目的串首地址（末地址）→ DI<br>
3）  串长度 → CX<br>
4）  建立方向标志<br>
（ CLD 使 DF=0，STD 使 DF=1 ）</p>
<h6 id="重复前缀指令rep">重复前缀指令REP</h6>
<p>重复前缀指令是重复其后的字符串操作指令，重复的次数由CX来决定。其一般格式为：<br>
REP　 MOVS / STOS / LODS<br>
重复前缀指令的执行步骤如下：<br>
1）判断：CX=0；<br>
2）如果CX=0，则结束重复操作，执行程序中的下一条指令；<br>
3）否则，CX=CX-1（不影响有关标志位），并执行其后的字符串操作指令，在该指令执行完后，再转到步骤1）。</p>
<h6 id="串传送指令move-string-instruction">串传送指令（Move String Instruction）</h6>
<p>指令的格式：<br>
MOVS  DST，SRC   （需在操作数中表明数据格式）<br>
MOVSB                  （字节）<br>
MOVSW                 （字）<br>
功能：将以SI为指针的源串中的一个字节（或字）存储单元中的数据传送至以DI为指针的目的地址中去，并自动修改指针，使之指向下一个字节（或字）存储单元。<br>
执行操作:<br>
①（DS：[SI]）→ES：[DI]<br>
② （SI)←(SI)±1，(DI)←(DI)±1      字节操作<br>
(SI)←(SI)±2，(DI)←(DI)±2     字  操  作</p>
<h6 id="串存储指令store-string-instruction">串存储指令（Store String Instruction）</h6>
<p>指令的格式：<br>
STOS  DST    （需在操作数中表明数据格式）<br>
STOSB          （字节）<br>
STOSW         （字）<br>
功能：将AL或AX中的数据送入ES：DI所指的目的串中的字节（或字）存储单元中。<br>
执行操作：<br>
字节操作：ES:[DI]←（AL），（DI）←（DI）±l<br>
字操作： ES:[DI] ←（AX），（DI）←（DI）±2</p>
<h6 id="串装入指令load-string-instruction">串装入指令（Load String Instruction）</h6>
<p>指令的格式：<br>
LODS  SRC （需在操作数中表明数据格式）<br>
LODSB          （字节）<br>
LODSW         （字）<br>
功能：将SI所指的源串中的一个字节（或字）存储单元中的数据取出来送入AL（或AX）中。<br>
执行操作：<br>
① 字节操作：（DS:[SI]）→AL，(SI) ±l → (SI)<br>
② 字操作：    （DS:[SI]）→AX，(SI) ±2 → (SI)</p>
<h6 id="串输入指令ins">串输入指令INS</h6>
<p>指令格式：<br>
INSB         ；字节串输入： ES:[DI] ←（（DX）），；DI←DI±1<br>
INSW          ；字串输入： ES:[DI] ← （（DX））， ；DI←DI±2</p>
<p>功能：将由DX寄存器指定的I/O端口中的字、字节传送到附加段中的目的串中，并根据DF和数据类型来改变目的变址寄存器的方向内容。</p>
<h6 id="串输出指令outs">串输出指令OUTS</h6>
<p>功能：将由源串中的字、字节传送到在DX寄存器指定的I/O端口中，并根据DF和数据类型来改变源变址寄存器的方向内容。</p>
<p>指令格式：<br>
OUTSB        ；字节串输出： （（DX））←DS：[SI] ；SI←SI±1<br>
OUTSW      ；字串串输出： （（DX））←DS：[SI] ；SI←SI±2</p>
<h5 id="与-repzrepnz配合工作的cmps-和-scas指令">与 REPZ（REPNZ）配合工作的CMPS 和 SCAS指令</h5>
<h6 id="相等重复前缀指令-reperepz">相等重复前缀指令 REPE/REPZ</h6>
<p>一般格式为：<br>
REPE/REPZ　CMPS/SCAS<br>
执行步骤如下：<br>
1）判断条件：CX≠0 且 ZF=1；<br>
2）如果条件不成立，则结束重复操作，执行程序中的下一条指令；<br>
3）否则，CX=CX-1（不影响有关标志位），并执行其后的字符串操作指令，在该指令执行完后，再转到步骤（1）。</p>
<h6 id="不等重复前缀指令-repnerepnz">不等重复前缀指令 REPNE/REPNZ</h6>
<p>一般格式为：<br>
REPNE/REPNZ　CMPS/SCAS</p>
<p>执行步骤如下：<br>
1）判断条件：CX≠0 且 ZF=0；<br>
2）如果条件不成立，则结束重复操作，执行程序中的下一条指令；<br>
3）否则，CX=CX-1（不影响有关标志位），并执行其后的字符串操作指令，在该指令执行完后，再转到步骤1）。</p>
<h6 id="串比较指令-cmps">串比较指令 CMPS</h6>
<p>语句格式：① CMPSB——字节串比较<br>
② CMPSW——字串比较<br>
功      能：将SI所指的源串中的一个字节（或字）存储单元中的数据与DI所指的目的串中的一个字节（或字）存储单元中的数据相减，并根据相减的结果设置标志，但结果并不保存。<br>
操作：①（DS:[SI]）－（ES:[DI]）。<br>
② 修改串指针，使之指向串中的下一个元素。<br>
当DF=0时，（SI）和（DI）增量。<br>
当DF=1时，（SI）和（DI）减量。</p>
<h6 id="串扫描指令-scas">串扫描指令 SCAS</h6>
<p>语句格式：① SCASB——字节串搜索<br>
② SCASW——字串搜索</p>
<p>功       能：AL（字节）或AX（字）中的内容与DI所指的目的串中的一个字节（或字）存储单元中的数据相减，根据相减结果设置标志位，结果不保存.<br>
操        作：<br>
① 字节操作：（AL）－（ES:[DI]），<br>
字操作：（AX）－（ES:[DI]）。<br>
② 修改指针使之指向串中的下一个元素。<br>
当DF=0时，（DI）增量。<br>
当DF=1时，（DI）减量。</p>
<h4 id="控制转移指令">控制转移指令</h4>
<p>转移指令是汇编语言程序员经常使用的一组指令。在高级语言中，时常有“尽量不要使用转移语句”的劝告，但如果在汇编语言的程序中也尽量不用转移语句，那么该程序要么无法编写，要么没有多少功能，所以，在汇编语言中，不但要使用转移指令，而且还要灵活运用，因为指令系统中有大量的转移指令。</p>
<p>转移指令分无条件转移指令和有条件转移指令两大类。<br>
无条件转移指令包括：JMP、子程序的调用和返回指令、中断的调用和返回指令等。<br>
条件转移指令又分三大类：基于无符号数的条件转移指令、基于有符号数的条件转移指令和基于特殊算术标志位的条件转移指令。</p>
<h5 id="jmp寻址方式">JMP寻址方式：</h5>
<p>段内转移：CS值不变，只给出地址偏移值（只改变IP）。<br>
短转移：在段内的短距离（-128~127）转移。<br>
近转移：转移的位移量为16位（-32768~32767）。</p>
<p>段间转移：CS和IP的值都发生改变的转移。</p>
<p>为明确表示标号或存储单元的类型，可在操作数前加SHORT、NEAR、FAR、WORD、DWORD、FWORD等修饰符来限定，默认近转移。</p>
<h5 id="无条件转移指令-jmp-op1regmem标号">无条件转移指令    JMP   OP1（reg/mem/标号）</h5>
<p>段内直接短转移：JMP    SHORT  OPR<br>
执行操作：（IP）← （IP）+ 8位位移量（带符号数）<br>
段内直接近转移：JMP    NEAR PTR  OPR<br>
执行操作：（IP）← （IP）+ 16位位移量（带符号数）<br>
段内间接转移：    JMP    WORD PTR  OPR<br>
执行操作：    （IP）← （EA）<br>
段间直接远转移：JMP    FAR PTR  OPR<br>
执行操作：（IP）← OPR 的段内偏移地址<br>
（CS）← OPR 所在段的段地址<br>
段间间接转移：     JMP    DWORD PTR  OPR<br>
执行操作：    （IP）← （EA）<br>
（CS）← （EA+2）</p>
<p>段内直接短转移：JMP    SHORT  OPR<br>
执行操作：（IP）← （IP）+ 8位位移量<br>
段内直接近转移：JMP    NEAR PTR  OPR<br>
执行操作：（IP）← （IP）+ 16位位移量<br>
位移量是紧接着JMP指令后的那条指令的偏移地址，到目标指令的偏移地址的地址位移。当向地址增大方向转移时，位移量为正；向地址减小方向转移时，位移量为负。</p>
<p>段内间接转移：    JMP    WORD PTR  OPR<br>
执行操作：    （IP）← （EA）<br>
将一个寄存器或主存字单元内容送入IP寄存器，作为新的指令指针，但不修改CS寄存器的内容。<br>
JMP    AX                            ；IP←AX<br>
JMP WORD PTR [2000H]；IP←[2000H]</p>
<p>段间直接远转移：JMP    FAR PTR  OPR<br>
执行操作：（IP）← OPR 的段内偏移地址<br>
（CS）← OPR 所在段的段地址<br>
将标号所在段的段地址作为新的CS值，标号在该段内的偏移地址作为新的IP值；这样，程序跳转到新的代码段执行。<br>
JMP  FAR PTR  OTHERSEG         ；远转移到代码段2的OTHERSEG</p>
<p>段间间接转移：    JMP    DWORD PTR  OPR<br>
执行操作：    （IP）← （EA）<br>
（CS）← （EA+2）<br>
用一个存储单元表示要跳转的目标地址。这个目标地址存放在主存中连续的字单元中的，低位字送IP寄存器，高位字送CS寄存器。<br>
MOV WORD PTR [BX]，1000H<br>
MOV WORD PTR [BX+2]，1500H<br>
JMP FAR [BX]；转移到1500H:1000H</p>
<h5 id="条件转移指令">条件转移指令</h5>
<p>条件转移指令是一组极其重要的转移指令，它根据标志寄存器中的一个（或多个）标志位来决定是否需要转移，这就为实现多功能程序提供了必要的手段。微机的指令系统提供了丰富的条件转移指令来满足各种不同的转移需要，在编程序时，要对它们灵活运用。<br>
基本格式：<br>
JXX    LABEL     ；条件满足，发生转移：IP←IP＋位移量<br>
；条件不满足，顺序执行。<br>
指定的条件XX如果成立，程序转移到由标号LABEL指定的目标地址去执行指令；条件不成立，则程序将顺序执行下一条指令。<br>
操作数LABEL是采用短转移，称为相对寻址方式。<br>
JXX指令不影响标志，但要利用标志。</p>
<p>根据单个条件标志的设置情况转移</p>
<table>
<thead>
<tr>
<th style="text-align:center">指令助记符</th>
<th style="text-align:center">转移条件</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">JC</td>
<td style="text-align:center">CF=1</td>
<td style="text-align:center">有进位转移</td>
</tr>
<tr>
<td style="text-align:center">JNC</td>
<td style="text-align:center">CF=0</td>
<td style="text-align:center">无进位转移</td>
</tr>
<tr>
<td style="text-align:center">JZ/JE</td>
<td style="text-align:center">ZF=1</td>
<td style="text-align:center">等于/为零转移</td>
</tr>
<tr>
<td style="text-align:center">JNZ/JNE</td>
<td style="text-align:center">ZF=0</td>
<td style="text-align:center">不等于/非零转移</td>
</tr>
<tr>
<td style="text-align:center">JO</td>
<td style="text-align:center">OF=1</td>
<td style="text-align:center">有符号数结果溢出转移</td>
</tr>
<tr>
<td style="text-align:center">JNO</td>
<td style="text-align:center">OF=0</td>
<td style="text-align:center">有符号数结果不溢出转移</td>
</tr>
<tr>
<td style="text-align:center">JP</td>
<td style="text-align:center">PF=1</td>
<td style="text-align:center">结果低8位奇偶校验为偶转移</td>
</tr>
<tr>
<td style="text-align:center">JNP</td>
<td style="text-align:center">PF=0</td>
<td style="text-align:center">结果低8位奇偶校验为奇转移</td>
</tr>
<tr>
<td style="text-align:center">JS</td>
<td style="text-align:center">SF=1</td>
<td style="text-align:center">结果为负时转移</td>
</tr>
<tr>
<td style="text-align:center">JNS</td>
<td style="text-align:center">SF=0</td>
<td style="text-align:center">结果为非负时转移</td>
</tr>
</tbody>
</table>
<p>无符号数的条件转移指令</p>
<p>无符号数的大小用高（Above）低（Below）表示利用CF确定高低、利用ZF标志确定相等（Equal）<br>
两数的高低分成4种关系：<br>
⑴  低于（不高于等于）：JB（JNAE）     CF=1, ZF=0<br>
⑵  不低于（高于等于）：JNB（JAE）     CF=0<br>
⑶  低于等于（不高于）：JBE（JNA）     CF=1或ZF=1<br>
⑷  不低于等于（高于）：JNBE（JA ）    CF=ZF=0</p>
<p>有符号数的条件转移指令</p>
<p>符号数的大（Greater）小（Less）需要组合OF、SF标志，并利用ZF标志确定相等（Equal）<br>
两数的大小分成4种关系：<br>
⑴ 小于（不大于等于）：JL（JNGE）   ZF=0 且 SF异或OF=1<br>
⑵ 不小于（大于等于）：JNL（JGE）   ZF=1 或 SF异或OF=0<br>
⑶ 小于等于（不大于）：JLE（JNG）   ZF=1 或 SF异或OF=1<br>
⑷ 不小于等于（大于）：JNLE（JG ）  ZF=0 且 SF异或OF=0</p>
<p>测试条件满足:SF 异或 OF=1时，A&lt;B<br>
测试条件满足:SF 异或 OF=0时，A&gt;=B</p>
<p>测试CX的值为0则转移指令</p>
<p>条件转移指令中还有一条较特殊的指令，因为CX寄存器通常在程序中用做计数器，JCXZ指令就可以用来判断计数是否为0。</p>
<p>格式：<br>
JCXZ         LABEL      ；CX＝0，发生转移：IP←IP＋位移量<br>
；CX≠0，顺序执行。</p>
<h5 id="循环指令">循环指令</h5>
<h6 id="循环指令-loop">循环指令 LOOP</h6>
<p>语句格式： LOOP  短标号<br>
执行过程：1）（CX）＝（CX）-1（不改变任何标志位）<br>
2)如果（CX）≠0，转向“标号”所指向的指令，否则，终止循环，执行该指令下面的指令。<br>
说明：LOOP指令可代替两条指令：<br>
DEC  CX<br>
JNE  短标号</p>
<h6 id="相等为零循环指令-loopeloopz">相等/为零循环指令  LOOPE/LOOPZ</h6>
<p>语句格式： LOOPE/ LOOPZ  短标号</p>
<p>执行过程：<br>
1）（CX）＝（CX）-1（不改变任何标志位）<br>
2）如果CX≠0且ZF=1，则程序转到循环体的第一条指令，否则，程序将执行该循环指令下面的指令。</p>
<h6 id="不相等不为零循环指令loopneloopnz">不相等/不为零循环指令LOOPNE/LOOPNZ</h6>
<p>语句格式： LOOPNE/ LOOPNZ  短标号</p>
<p>执行过程：<br>
1）（CX）＝（CX）-1（不改变任何标志位）<br>
2）如果CX≠0且ZF=0，则程序转到循环体的第一条指令，否则，程序将执行该循环指令下面的指令。</p>
<h4 id="子程序">子程序</h4>
<p>子程序是完成特定功能的一段程序。如果某程序段在源程序内反复出现，就可把该程序段定义为子程序。这样可以缩短源程序长度、节省目标程序的存储空间，也可提高程序的可维护性和共享性。<br>
当主程序（调用程序）需要执行这个功能时，采用 CALL 调用指令转移到该子程序的起始处执行；<br>
当运行完子程序功能后，采用 RET 返回指令回到主程序继续执行。</p>
<h5 id="子程序调用指令-call">子程序调用指令   CALL</h5>
<p>类似JMP指令， CALL指令分成4种类型：<br>
CALL label     ；段内调用、直接寻址（段内直接调用）<br>
CALL r16/m16；段内调用、间接寻址（段内间接调用）<br>
CALL far ptr label；段间调用、直接寻址（段间直接调用）<br>
CALL dword ptr mem；段间调用、间接寻址（段间间接调用）<br>
但不同于JMP指令，CALL指令需要保存返回地址：<br>
段内调用——入栈偏移地址IP：<br>
SP←SP－2，SS:SP←IP<br>
段间调用——入栈偏移地址IP和段地址CS：<br>
SP←SP－2，SS:SP←IP；<br>
SP←SP－2，SS:SP←CS。</p>
<p>段内直接调用<br>
格        式：CALL　DST<br>
执行步骤：<br>
① 将子程序的返回地址存入堆栈，以便子程序返回使用。<br>
即： （SP）←SP - 2；<br>
（SP）+1,（SP）←IP<br>
② 转移到子程序入口地址去继续执行子程序。指令中的DST在汇编格式指令作用子程序入口地址的符号地址（标号）。在机器语言中，它是一个16位的偏移量。即： （IP）←IP+ D16<br>
注：段内调用只改变IP，不改变CS的值。</p>
<p>段内间接调用<br>
格  式：CALL　DST<br>
此指令的执行步骤和段内直接调用大致相同，主要区别是子程序的入口地址DST的寻址方式不同而已。它可以是寄存器操作数和各种寻址方式的存储器操作数，当然不允许是立即数和段寄存器操作数。</p>
<p>段间直接调用<br>
格         式：CALL　DST<br>
执行操作：  ①  SP←SP - 2；  ② （SP）+1,（SP）←CS ；<br>
③ SP←SP - 2；  ④ （SP）+1,（SP）←IP ；<br>
⑤  IP ←偏移地址（指令的第2、3字节）；<br>
⑥ CS ←段地址（指令的第4、5字节）；</p>
<p>段间间接调用<br>
格         式：CALL　DST<br>
执行操作：  ①  SP←SP - 2；      ② （SP）+1,（SP）←CS ；<br>
③ SP←SP - 2；      ④ （SP）+1,（SP）←IP ；<br>
⑤  IP ←（EA）；  ⑥ CS ←（EA+2）；<br>
此指令的执行步骤和段间直接调用大致相同，主要区别是子程序的入口地址DST的寻址方式不同而已。它可以是寄存器操作数和各种寻址方式的存储器操作数，也即由各种寻址方式形成的有效地址EA和EA+1两个单元内容送入IP，EA+2和EA+3两个单元内容送入CS。</p>
<h5 id="返回指令-ret">返回指令  RET</h5>
<p>(1) 段内近返回：RET<br>
执行操作： （IP ）← （SP）+1,（SP）<br>
（SP）← SP + 2<br>
(2) 段内带立即数近返回：RET  EXP<br>
RET可以带有一个立即数，堆栈指针SP将增加，即SP←SP+EXP。这个特点使得程序可以方便地废除若干执行CALL指令以前入栈参数。<br>
(3) 段间远返回：RET<br>
执行操作：    （IP） ← （SP）+1,（SP）<br>
（SP）←（SP） + 2<br>
（CS）← （SP）+1,（SP）<br>
（SP）←（SP） + 2<br>
(4) 段间带立即数远返回：RET  EXP（同段内带立即数返回）</p>
<h4 id="中断">中断</h4>
<p>中断就是CPU暂停当前程序的执行，转而执行处理紧急事务的程序，并在该事务处理完后能自动恢复执行原先程序的过程。在此，称引起紧急事务的事件为中断源，称处理紧急事务的程序为中断服务程序或中断处理程序。</p>
<p>中断处理程序基本上是系统程序员编写好的，是为操作系统或用户程序服务的。为了在应用程序中使用中断服务程序，程序员必须能够在程序中有目的地安排中断的发生。为此，指令系统提供了各种引起中断的指令。</p>
<h5 id="中断向量表和中断服务程序">中断向量表和中断服务程序</h5>
<p>中断向量表是一个特殊的线性表，它保存着系统所有中断服务程序的入口地址（偏移量和段地址）。在微机系统中，该向量表有256个元素（0~0FFH），每个元素占4个字节，总共1K字节。</p>
<h5 id="中断指令-int">中断指令 INT</h5>
<p>一般格式：INT    TYPE<br>
其中：立即数TYPE是一个0~0FFH范围内的整数。<br>
指令执行的步骤：<br>
1）把标志寄存器压栈，清除标志位IF和TF；<br>
2）把代码段寄存器CS和指令指针寄存器IP的内容压栈；<br>
3）（IP） ←（TYPEx4），（CS） ←（TYPEx4+2）</p>
<h5 id="溢出指令-into">溢出指令 INTO</h5>
<p>当标志位OF为1时，引起中断。<br>
该指令的格式如下： INTO<br>
该指令影响标志位：IF和TF。</p>
<h5 id="中断返回指令-iret">中断返回指令 IRET</h5>
<p>当一个中断服务程序执行完毕时，CPU将恢复被中断的现场，返回到引起中断的程序中。为了实现此项功能，指令系统提供了一条专用的中断返回指令。</p>
<p>指令格式：  IRET</p>
<p>该指令执行的过程基本上是INT指令的逆过程，具体如下：<br>
1）从栈顶弹出内容送入IP；<br>
2）再从新栈顶弹出内容送入CS；<br>
3）再从新栈顶弹出内容送入标志寄存器；</p>
<h5 id="中断和子程序的比较">中断和子程序的比较</h5>
<p>中断和子程序调用之间有其相似和不同之处。它们的工作过程非常相似，即：暂停当前程序的执行，转而执行另一程序段，当该程序段执行完时，CPU都自动恢复原程序的执行。它们的主要差异有：<br>
1）子程序调用一定是程序员在编写源程序时事先安排好的，是可知的，而中断是由中断源根据自身的需要产生的，是不可预见的（用指令INT引起的中断除外）；<br>
2）子程序调用是用CALL指令来实现的，但没有调用中断的指令，只有发出中断请求的事件（指令INT是发出内部中断信号，而不要理解为调用中断服务程序）；<br>
3）子程序的返回指令是RET，而中断服务程序的返回指令是IRET。<br>
4）在通常情况下，子程序是由应用系统的开发者编写的，而中断服务程序是由系统软件设计者编写的。</p>
<h3 id="处理机控制和杂项指令">处理机控制和杂项指令</h3>
<h4 id="标志处理指令">标志处理指令</h4>
<p>CLC     进位位置0指令                     ； CF ← 0<br>
CMC    进位位求反指令                   ； CF ←/CF<br>
STC      进位位置1指令                     ；CF ← 1<br>
CLD     方向标志位置0指令             ；DF ← 0<br>
STD      方向标志位置1指令             ；DF ← 1<br>
CLI      中断标志位置0指令             ；IF ← 0<br>
STI       中断标志位置1指令             ；IF ← 1</p>
<h4 id="cpu控制类指令">CPU控制类指令</h4>
<h5 id="空操作指令-nopno-operation-instruction">空操作指令   NOP（No Operation Instruction）</h5>
<p>该指令不执行任何操作，但占用一个字节存储单元，空耗一个指令执行周期，常用于程序调试。<br>
例如：在需要预留指令空间时用NOP填充，代码空间多余时也可以用NOP填充，还可以用NOP实现软件延时。<br>
事实上，NOP和   XCHG AL，AL    的指令代码一样。</p>
<h5 id="暂停指令-hltenter-halt-state-instruction">暂停指令   HLT（Enter Halt State Instruction）</h5>
<p>在等待中断信号时，该指令使CPU处于暂停工作状态，CS:IP指向下一条待执行的指令。当产生了中断信号，CPU把CS和IP压栈，并转入中断处理程序。在中断处理程序执行完后，中断返回指令IRET弹出IP和CS，并唤醒CPU执行下条指令。</p>
<h5 id="换码指令esc">换码指令ESC</h5>
<p>把浮点指令交给浮点处理器执行。提高系统浮点运算能力的协处理器8087指令是与8086的整数指令组合在一起的，8086主存中存储8087的操作码及其所需的操作数。当8086发现是一条浮点指令时，就利用ESC指令将浮点指令交给8087执行。实际编写程序时，一般采用易于理解的浮点指令助记符格式。</p>
<p>ESC 6，[SI]               ；实数除法指令：FDIV dword ptr [SI]<br>
ESC 20H，AL；整数加法指令：FADD ST(0),ST</p>
<h5 id="等待指令-waitput-processor-in-wait-state-instruction">等待指令  WAIT（Put Processor in Wait State Instruction）</h5>
<p>该指令使CPU处于等待状态，直到协处理器（Coprocessor）完成运算，并用一个重启信号唤醒CPU为止。该指令执行不影响任何标志位。<br>
8086就是利用WAIT指令和测试引脚实现与8087同步运行的。浮点指令经由8086CPU处理发往8087，并与8086本身的整数指令在同一个指令序列；而8087执行浮点指令较慢，所以8086必须与8087保持同步。</p>
<h5 id="封锁数据指令locklock-bus-instruction">封锁数据指令LOCK（Lock Bus Instruction）</h5>
<p>这是一个指令前缀，可放在任何指令前。这个前缀使得在这个指令执行时间内，8086 处理器的封锁输出引脚有效，即把总线封锁，使别的控制器不能控制总线；直到该指令执行完后，总线封锁解除。</p>
<h1 id="第四章-汇编语言及其程序设计">第四章 汇编语言及其程序设计</h1>
<h1 id="第五章-存储器">第五章 存储器</h1>
<h1 id="第六章-中断技术">第六章 中断技术</h1>
<h1 id="第七章-io接口技术">第七章 I/O接口技术</h1>
<h1 id="第八章-da与ad转换器接口">第八章 D/A与A/D转换器接口</h1>
<h1 id="第九章-微机总线">第九章 微机总线</h1>
<h1 id="第十章-人机交互接口">第十章 人机交互接口</h1>
<h1 id="a-target_blank-hrefhttpmailqqcomcgi-binqm_sharetqm_mailmeemailk_h88fzp0_livfd8-g-styletext-decorationnone-意见反馈a"><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=k_H88fzp0_LivfD8-g" style="text-decoration:none;">✉ 意见反馈</a></h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[个人免费网站的创建]]></title>
        <id>https://roboz-up.github.io/post/ge-ren-wang-zhan-de-chuang-jian/</id>
        <link href="https://roboz-up.github.io/post/ge-ren-wang-zhan-de-chuang-jian/">
        </link>
        <updated>2020-03-20T08:57:58.000Z</updated>
        <content type="html"><![CDATA[<p>⏰最后更新时间：2020.5.1</p>
<p>📮基于Gridea和Github建立个人免费网站的经验分享。<br>
<img src="https://i.loli.net/2020/05/01/7HBlnMy392oZmYP.jpg" alt="" loading="lazy"></p>
<h1 id="环境搭建与准备">环境搭建与准备</h1>
<h2 id="下载安装-gridea">下载安装 Gridea</h2>
<pre><code>Gridea 官网：https://gridea.dev/
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2020/05/01/FaJkMCt2WngclN7.png" alt="" loading="lazy"></figure>
<h2 id="下载安装-git">下载安装 Git</h2>
<pre><code>Git 官网：https://git-scm.com/

网速慢的小可爱可以使用 淘宝NPM镜像
https://npm.taobao.org/mirrors/git-for-windows/
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2020/05/01/zFf2KyMdO36mrq4.png" alt="" loading="lazy"></figure>
<h2 id="注册github账号已经有账号的小可爱直接跳过即可">注册Github账号（已经有账号的小可爱直接跳过即可）</h2>
<pre><code>Github 官网： https://github.com/

注册Github账号教程
https://jingyan.baidu.com/article/86fae346e723303c49121abb.html/
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2020/05/01/C58cPHu7kaMeGxQ.png" alt="" loading="lazy"></figure>
<h1 id="配置gridea">配置Gridea</h1>
<h2 id="创建github仓库及其网站">创建Github仓库及其网站</h2>
<pre><code>登陆Github 新建仓库
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://i.loli.net/2020/05/01/cFToh1vkJVAt2KS.png" alt="" loading="lazy"></figure>
<h2 id="获取github私人token令牌">获取Github私人Token令牌</h2>
<pre><code>令牌获取教程
https://blog.csdn.net/ltstud/article/details/75949726/
</code></pre>
<h2 id="建立gridea远程连接">建立Gridea远程连接</h2>
<pre><code>打开Gridea 进行配置
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://i.loli.net/2020/05/01/dU5CbFgRMBZiO2T.png" alt="" loading="lazy"></figure>
<h1 id="应用gridea">应用Gridea</h1>
<pre><code>配置完成后，先测试远程连接是否正常
点击同步，进行网页美化与内容同步
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://i.loli.net/2020/05/01/aKNHxTOSCvAR9gb.png" alt="" loading="lazy"></figure>
<h1 id="a-target_blank-hrefhttpmailqqcomcgi-binqm_sharetqm_mailmeemailk_h88fzp0_livfd8-g-styletext-decorationnone-意见反馈a"><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=k_H88fzp0_LivfD8-g" style="text-decoration:none;">✉ 意见反馈</a></h1>
]]></content>
    </entry>
</feed>