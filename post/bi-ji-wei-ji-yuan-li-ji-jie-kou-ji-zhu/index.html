<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
<title>
    ROBOZ
</title>
<!--[if lt IE 9]><script src="//cdn.bootcss.com/html5shiv/r29/html5.js"></script><![endif]-->
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport" />
<meta http-equiv="x-dns-prefetch-control" content="on">
<link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
<meta name="author" content="ROBOZ">
<meta name="description" content="阿俊的平行空间">
<meta name="keywords" content="">
<script async src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/itjoker233/Gridea-theme-Chic/assets/media/css/style.min.css" />
<link rel="stylesheet" href="https://roboz-up.github.io/styles/main.css" />
<link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
<script type="text/javascript" src="https://apps.bdimg.com/libs/jquery/1.7.1/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/itjoker233/Gridea-theme-Chic/assets/media/script/tocbot.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/itjoker233/Gridea-theme-Chic/assets/media/script/script.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/itjoker233/Gridea-theme-Chic/assets/media/script/icon.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ITJoker233/ITJoker233.github.io@1.0.12/CDN/js/Card/prism.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ITJoker233/ITJoker233.github.io@1.0.12/CDN/css/Card/prism.min.css" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.js"></script>

    <!--点击特效-->
    <script src="https://cdn.jsdelivr.net/gh/ITJoker233/ITJoker233.github.io@latest/CDN/js/love.min.js"></script>
    
            <!--CDN样式-->
            <script src="https://cdn.jsdelivr.net/gh/ITJoker233/ITJoker233.github.io@latest/CDN/js/hit-kounter-lc-0.3.0.js"></script>
            <script src="https://cdn1.lncld.net/static/js/av-min-1.5.0.js"></script>
            
                <script>
                    (function() {
                        var bp = document.createElement('script');
                        var curProtocol = window.location.protocol.split(':')[0];
                        if (curProtocol === 'https') {
                            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
                        } else {
                            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                        }
                        var s = document.getElementsByTagName("script")[0];
                        s.parentNode.insertBefore(bp, s);
                    })();
                </script>
                
</head>

<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo">
                <a href="https://roboz-up.github.io">
                    ROBOZ
                </a>
            </div>

            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/">
                        首页
                    </a>
                    
                    <a class="menu-item" href="/archives">
                        列表
                    </a>
                    
                    <a class="menu-item" href="/tags">
                        分类
                    </a>
                    
                    <a class="menu-item" href="/post/about">
                        关于
                    </a>
                    
                        <input id="switch_default" type="checkbox" class="switch_default">
                        <label for="switch_default" class="toggleBtn"></label>
            </div>
            <form id="gridea-search-form" data-update="1589637852670" action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" autofocus="true" placeholder="Search...">
            </form>
        </div>
    </nav>

    
        <nav class="navbar-mobile" id="nav-mobile">
            <div class="container">
                <div class="navbar-header">
                    <div>
                        <a href="https://roboz-up.github.io">
                            ROBOZ
                        </a>
                        <!--en-->
                        <a id="mobile-toggle-theme-en" class="a en">&nbsp;Dark</a>
                        <!--zh-->
                        <a id="mobile-toggle-theme-zh" class="a zh">&nbsp;&#x6697;&#x9ED1;</a>
                    </div>
                    <form id="gridea-search-form" data-update="1589637852670" action="/search/index.html">
                        <input class="search-input" autocomplete="off" spellcheck="false" name="q" autofocus="true" placeholder="Search...">
                    </form>
                    <!--en-->
                    <div class="menu-toggle" id="menu-toggle-en" onclick="mobileBtn()">&#9776; Menu</div>
                    <!--zh-->
                    <div class="menu-toggle" id="menu-toggle-zh" onclick="mobileBtn()">&#9776; &#x83DC;&#x5355;</div>

                </div>
                <div class="menu" id="mobile-menu">
                    
                        <a class="menu-item" href="/">
                            首页
                        </a>
                        
                        <a class="menu-item" href="/archives">
                            列表
                        </a>
                        
                        <a class="menu-item" href="/tags">
                            分类
                        </a>
                        
                        <a class="menu-item" href="/post/about">
                            关于
                        </a>
                        
                </div>
            </div>
        </nav>
</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementById("menu-toggle-en");
        var toggleMenu_zh = document.getElementById("menu-toggle-zh");

        var mobileMenu = document.getElementById("mobile-menu");
        if (toggleMenu.display != "none") {
            if (toggleMenu.classList.contains("active")) {
                toggleMenu.classList.remove("active")
                mobileMenu.classList.remove("active")
            } else {
                toggleMenu.classList.add("active")
                mobileMenu.classList.add("active")
            }
        } else if (toggleMenu_zh.display != "none") {
            if (toggleMenu_zh.classList.contains("active")) {
                toggleMenu_zh.classList.remove("active")
                mobileMenu.classList.remove("active")
            } else {
                toggleMenu_zh.classList.add("active")
                mobileMenu.classList.add("active")
            }
        }

    }
</script>
            <div class="main">
                <div class="container">
                    <article class="post-wrap">
                        <header class="post-header">
                            <h1 class="post-title">
                                笔记：微机原理及接口技术
                            </h1>
                            
                                    <!--zh-->
                                    <div class="post-meta zh">
                                        &#x4F5C;&#x8005;:
                                        <a itemprop="author" rel="author" href="/">
                                            ROBOZ
                                        </a>
                                        <span class="post-time">&#x65E5;&#x671F;: <a href="#">2020-03-22</a></span>
                                        <span class="post-readtime">&#x9605;&#x8BFB;&#x65F6;&#x95F4;:<a
                                    href="#">103.2
                                    &#x5206;&#x949F;</a></span>
                                        <span class="post-words">&#x5B57;&#x6570;:<a href="#">28156</a></span>
                                        
                                            <span class="post-category">&#x5206;&#x7C7B;:
                                
                                <a href="https://roboz-up.github.io/tag/Y2pfBAN1G/">笔记</a>
                                
                            </span>
                                            
                                                阅读量:
                                                <span data-hk-page="current"> - </span>
                                                
                                    </div>
                                    
                        </header>
                        <div class="post-content">
                            <p>⏰最后更新时间：2020.5.1</p>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2020/05/01/gHNOETMRqb4yha1.png" alt="" loading="lazy"></figure>
<h1 id="预-备-知-识">预 备 知 识</h1>
<ul>
<li>
<h2 id="微处理器">微处理器</h2>
</li>
</ul>
<p>微处理器即为CPU（Central Processing Unit）又叫中央处理器。<br>
主要<strong>功能</strong>：运算和逻辑运算<br>
内部<strong>结构</strong>分为：控制单元、算术逻辑单元和存储单元等几个部分。<br>
按照其处理信息的字长可以分为：八位微处理器、十六位微处理器、三十二位微处理器以及六十四位微处理器等等。</p>
<ul>
<li>
<h2 id="微型计算机">微型计算机</h2>
</li>
</ul>
<p>微型计算机是以<strong>微处理器</strong>为核心，再配上<strong>存储器</strong>和<strong>接口电路</strong>等芯片构成的。</p>
<ul>
<li>
<h2 id="单片机">单片机</h2>
</li>
</ul>
<p>单片机(Microcontrollers)是一种集成电路芯片。<br>
采用超大规模集成电路技术把具有数据处理能力的<strong>中央处理器CPU</strong>、<strong>数据存储器RAM</strong>、<strong>程序存储器ROM</strong>、<strong>多种I/O口和中断系统</strong>、<strong>定时器/计数器</strong>等功能(可能还包括显示驱动电路、脉宽调制电路、模拟多路转换器、A/D转换器等电路)集成到一块硅片上构成的一个小而完善的<strong>微型计算机系统</strong>。</p>
<ul>
<li>
<h2 id="嵌入式系统包括">嵌入式系统包括</h2>
</li>
</ul>
<p>嵌入式微<strong>控制器</strong>(16位、8位、以及8位以下的CPU，典型代表就是单片机)<br>
嵌入式微<strong>处理器</strong>(32位，以及32位以上的称为处理器，典型为ARM核的处理器。)<br>
DSP(Digital Signal Processing，<strong>数字信号处理器</strong>)<br>
SOC(System on Chip， <strong>片上系统</strong>，就是把所有的 模块都做到一块芯片上)</p>
<h2 id="程序设计语言">程序设计语言</h2>
<p>程序设计语言通常分为三类：<strong>机器语言</strong>、<strong>汇编语言</strong>和<strong>高级语言</strong>。</p>
<ul>
<li>机器语言<br>
计算机能够直接识别的数据是由二进制数0和1组成的代码。<br>
机器指令就是用二进制代码组成的指令，一条机器指令控制计算机完成一个基本操作。<br>
用机器语言编写的程序是计算机惟一能够直接识别并执行的程序，而用其他语言编写的程序必须经过翻译才能变换成机器语言程序。<br>
所以，机器语言程序被称为<strong>目标程序</strong>。</li>
<li>汇编语言<br>
为了克服机器语言的缺点，人们采用助记符表示机器指令的操作码,用变量代替操作数的存放地址等，这样就形成了汇编语言。<br>
汇编语言是一种用符号书写的、基本操作与机器指令相对应的、并遵循一定语法规则的计算机语言。<br>
汇编语言是一种符号语言，比机器语言容易理解和掌握，也容易调试和维护。<br>
但是，汇编语言源程序要翻译成机器语言程序才可以由计算机执行。<br>
这个翻译的过程称为“汇编”，这种把汇编源程序翻译成目标程序的语言加工程序称为<strong>汇编程序</strong>。<br>
用汇编语言编写的程序称为<strong>汇编源程序</strong>。</li>
<li>面向机器的低级语言<br>
面向机器的低级语言，通常是为特定的计算机或计算机系列专门设计的。<br>
保持了机器语言的优点，具有直接和简捷的特点。<br>
可有效地访问、控制计算机的各种硬件设备,  如磁盘、存储器、CPU、I/O端口等。<br>
目标代码简短，占用内存少，执行速度快，  是高效的程序设计语言。<br>
经常与高级语言配合使用，应用十分广泛。</li>
<li>高级语言<br>
高级程序设计语言接近于人类自然语言的语法习惯，与计算机硬件无关，易被用户掌握和使用。</li>
</ul>
<h2 id="c语言与汇编语言的区别">C语言与汇编语言的区别</h2>
<ul>
<li><strong>汇编语言</strong>是<strong>低级语言</strong>，在编写程序的时候会把根据不同的情况指定使用不同的寻址方式，能够对内存和CPU里的通用寄存器直接操纵。不同的计算机系列会有不同的汇编语言。<strong>注重描述过程</strong>。</li>
<li><strong>C语言</strong>是<strong>高级语言</strong>，可以实现跨平台。编写程序无需指定CPU的指令执行情况，一段程序可以在不同体系结构的计算机上使用。<strong>注重描述结果</strong>。</li>
</ul>
<h2 id="汇编语言">汇编语言</h2>
<ul>
<li>汇编语言的<strong>特点</strong><br>
可直接<strong>控制硬件</strong>，充分发挥硬件功能。<br>
汇编语言程序代码<strong>质量高</strong>，占用内存<strong>空间少</strong>，执行<strong>速度快</strong>。</li>
<li>应用<strong>优势</strong><br>
对于解决某些领域的问题，如操作系统，实时控制和处理、加密/解密、软件调试、病毒分析及逆向工程等领域具有独特的优势。</li>
<li>实际应用中<br>
常常编写汇编语言子程序，解决如下的问题：<br>
（1）进行计算速度或代码长度优化<br>
（2）存取系统资源<br>
（3）直接访问硬件<br>
（4）为不兼容的代码（编程环境）提供接口</li>
<li><strong>缺点</strong>可移植性差、可读性差。</li>
</ul>
<h2 id="微机的性能指标">微机的性能指标</h2>
<ul>
<li>字长<br>
指CPU内部一次能够处理的二进制数的位数。</li>
<li>存储容量<br>
存储的二进制信息。一般以字节为单位来表示。<br>
常用单位：<br>
b（bit）比特：一位二进制<br>
B（byte）字节：8位二进制<br>
Word 字 = 2Byte = 16bit<br>
KB:2^10=1024B=1KB<br>
MB:2^20=1024KB=1MB<br>
GB:2^30=1024MB=1GB<br>
TB:2^40=1024GB=1TB</li>
<li>运算速度:<br>
主频：CPU的<strong>时钟频率</strong>,用来表示CPU的<strong>运算速度</strong><br>
外频：CPU的<strong>基准频率</strong>,是<strong>CPU</strong>与主板之间<strong>同步运行的速度</strong> ,也是<strong>内存</strong>与主板之间**同步运行的速度 **。<br>
倍频：指CPU外频与主频相差的倍数。<br>
三者关系是：主频=外频*倍频。</li>
<li>运算速度的计算方法：<br>
（1）MIPS方法:	以<strong>每秒能执行几百万条</strong>指令来衡量。<br>
（2）最短指令法: 以<strong>执行时间最短</strong>的指令为标准来计算<br>
（3）直接计算法 :根据<strong>主频和指令的执行所需的时钟周期</strong>直接计算指令执行的时间。</li>
<li>CPU内核和I/O工作电压<br>
内核电压的大小是根据CPU的生产工艺而定，一般制作工艺越小，内核工作电压越低。早期的CPU工作电压为5V,而奔腾可降到2V。<br>
I/O工作电压在1.6-3V。<br>
低电压能解决耗电过大和发热过高的问题。</li>
<li>扩展能力和外设配置</li>
<li>软件配置</li>
</ul>
<h1 id="第一章-微型计算机基础">第一章 微型计算机基础</h1>
<h2 id="11-计算机中数制与编码及其数的表示">1.1  计算机中数制与编码及其数的表示</h2>
<p>计算机内部的信息分为两大类：控制信息和数据信息。</p>
<ul>
<li>控制信息<br>
是一系列的控制命令，用于指挥计算机如何操作。</li>
<li>数据信息<br>
是计算机操作的对象，一般又可分为数值数据和非数值数据。</li>
</ul>
<h3 id="进位计数制">进位计数制</h3>
<table>
<thead>
<tr>
<th style="text-align:center">进制</th>
<th style="text-align:center">符号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">二进制</td>
<td style="text-align:center">B</td>
</tr>
<tr>
<td style="text-align:center">八进制</td>
<td style="text-align:center">O/Q</td>
</tr>
<tr>
<td style="text-align:center">十进制</td>
<td style="text-align:center">D</td>
</tr>
<tr>
<td style="text-align:center">十六进制</td>
<td style="text-align:center">H</td>
</tr>
</tbody>
</table>
<ul>
<li>计数制的书写规则<br>
为了区别不同的计数制，可采用下列两种方法：<br>
1.在数字后面加写相应的英文字母作为标识，英文字母不分大小写。<br>
2.在括号外面加数字下标。</li>
</ul>
<h3 id="数制之间的转换">数制之间的转换</h3>
<h4 id="十进制数与二进制数之间的转换">十进制数与二进制数之间的转换</h4>
<ul>
<li>十进制整数转换成二进制整数<br>
方法：除2取余法<br>
注意：第一次得到的余数为二进制数的最低位，最后得到的余数为二进制数的最高位。</li>
<li>十进制小数转换成二进制小数<br>
方法：乘2取整法<br>
注意：最后将每次得到的整数部分（必定是0或1）按先后顺序从左到右排列即得到所对应二进制小数。</li>
<li>一般的十进制数转换成二进制数<br>
为了将一个既有整数又有小数部分的十进制数转换成二进制数，可以将其整数部分和小数部分分别进行转换，然后再组合起来。</li>
<li>二进制数转换十进制数<br>
方法：按位权展开后相加。<br>
注意：用其各位所对应的系数，按“位权展开求和”的方法就可以得到，其基数为2。</li>
</ul>
<h4 id="十进制数与八进制数之间的转换">十进制数与八进制数之间的转换</h4>
<ul>
<li>十进制整数转换成八进制整数<br>
方法：除8取余法<br>
注意：采用基数8连续去除该十进制整数，直至商等于“0”为止，然后逆序排列所得到的余数。</li>
<li>十进制小数转换成八进制小数<br>
方法：乘8取整法<br>
注意：连续用基数8去乘以该十进制小数，直至乘积的小数部分等于“0”，然后顺序排列每次乘积的整数部分。</li>
<li>八进制数转换成十进制数<br>
方法：按位权展开后相加。<br>
用其各位所对应的系数，按“位权展开求和”的方法就可以得到，其基数为8。</li>
</ul>
<h4 id="十进制与十六进制之间的转换">十进制与十六进制之间的转换</h4>
<ul>
<li>十进制整数转换成十六进制整数<br>
方法：除16取余法<br>
注意：采用基数16连续去除该十进制整数，直至商等于“0”为止，然后逆序排列所得到的余数。</li>
<li>十进制小数转换成十六进制小数<br>
方法：乘16取整法<br>
注意：连续用基数16去乘以该十进制小数，直至乘积的小数部分等于“0”，然后顺序排列每次乘积的整数部分。</li>
<li>十六进制数转换十进制数<br>
方法：按位权展开后相加<br>
注意：用其各位所对应的系数，按“位权展开求和”的方法就可以得到，其基数为16。</li>
</ul>
<h4 id="二进制与八进制-十六进制数之间的转换">二进制与八进制、十六进制数之间的转换</h4>
<p>2^3=8，所以每三位二进制数对应一位八进制数；<br>
2^4=16，所以每四位二进制数对应一位十六进制。</p>
<ul>
<li>二进制数转换成八进制数<br>
从小数点所在位置分别向左向右每三位一组进行划分。<br>
若小数点左侧的位数不是3的整数倍，在数的最左侧补零。<br>
若小数点右侧的位数不是3的整数倍，在数的最右侧补零。<br>
然后将每三位二进制数转换成对应的一位八进制数，即为二进制数对应的八进制数。</li>
<li>八进制数转换成二进制数<br>
将每一位八进制数转换成对应的三位二进制数，即为八进制数对应的二进制数。</li>
<li>二进制数转换成十六进制数<br>
从小数点所在位置分别向左向右每四位一组进行划分。<br>
若小数点左侧的位数不是4的整数倍，在数的最左侧补零。<br>
若小数点右侧的位数不是4的整数倍，在数的最右侧补零 。<br>
然后将每四位二进制数转换成对应的一位十六进制数，即为二进制数对应的十六进制数。</li>
<li>十六进制数转换成二进制数<br>
将每一位十六进制数转换成对应的四位二进制数，即为十六进制数对应的二进制数。</li>
<li>十六进制和二进制的相互转换<br>
对于二进制整数，只要从右到左每4位组成一组，不足4位最左边补0，即可得到相应的十六进制。<br>
对于二进制小数，只要从左到右每4位组成一组，不足4位最右边补0，即可得到相应的十六进制。<br>
将十六进制转成二进制数，只要每一位十六进制数用四位二进制数表示即可。</li>
</ul>
<h3 id="常用的编码方法">常用的编码方法</h3>
<p>计算机中数值型数据是用二进制数来表示的，而非数值型数据包括英文字母、标点符号、专用符号、汉字等，也是用二进制数来编码的。</p>
<h4 id="十进制数的编码">十进制数的编码</h4>
<ul>
<li>BCD码<br>
BCD（Binary-Coded  Decimal）码又称为“二—十进制编码”，专门解决用二进制数表示十进数的问题。最常用的是8421编码，其方法是用4位二进制数表示1位十进制数，自左至右每一位对应的位权是8、4、2、1。</li>
<li>BCD码有两种格式：<br>
1.压缩BCD码格式（Packed BCD Format）<br>
用4个二进制位表示一个十进制位，就是用0000B-1001B来表示十进制数0-9。<br>
例如：十进制数4256的压缩BCD码表示为：<br>
0100 0010 0101 0110 B<br>
2.非压缩BCD码格式（Unpacked BCD Format）<br>
用8个二进制位表示一个十进制位，其中，高四位无意义，我们一般用xxxx表示，低四位和压缩BCD码相同。<br>
例如：十进制数4256的非压缩BCD码表示为：<br>
xxxx0100 xxxx0010 xxxx0101 xxxx0110 B</li>
</ul>
<h4 id="非数值型数据的编码">非数值型数据的编码</h4>
<h5 id="字符编码">字符编码</h5>
<ul>
<li>ASCII字符编码<br>
即美国标准信息交换代码(American Standard Code for Information Interchance)</li>
<li>ASCII码<br>
用一个字节来表示一个字符，低7位为字符的ASCII值，最高位一般用作校验位。</li>
<li>ASCII码表有以下几个特点：<br>
每个字符用7位基2码表示，其排列次序为B6 B5 B4 B3 B2 B1 B0。</li>
<li>ASCII码共编码了128个字符,它们分别是：<br>
32个控制字符，主要用于通信中的通信控制或对计算机设备的功能控制，编码值为0～31（十进制）。<br>
间隔字符（也称空格字符）SP，编码值为20H。<br>
删除控制码DEL，编码值为7FH。<br>
94个可印刷字符（或称有形字符）。</li>
</ul>
<h5 id="汉字的编码">汉字的编码</h5>
<p>计算机在处理汉字时，汉字字符也必须用基2码编码表示，一般汉字编码采用两个字节即16位二进制数。但由于汉字的特殊性，在汉字的输入、存储、输出过程中所使用的汉字编码是不一样的，输入时有输入编码，存储时有汉字机内码，输出时有汉字字形码。</p>
<ul>
<li>汉字输入编码<br>
为了能把汉字这种象形文字通过西文标准键盘输入到计算机内，就必须对汉字用键盘已有的字符设计编码，这种编码称为汉字的输入编码，又称为汉字外部码，简称外码。使用较多的有以下4类：<br>
①顺序码：如区位码、电报码等。<br>
②音码：如拼音码、自然码等。<br>
③形码：如五笔字型、大众码等。<br>
④音形码：如双拼码、五十字元等。</li>
<li>汉字机内码<br>
汉字机内码也称汉字内部码，简称内码。它是机器存储和处理汉字时采用的统一编码。每个汉字的机内码是惟一的，用两个字节表示。为了避免与西文字符的ASCII码之间产生二义性，汉字机内码中两个字节的最高位均规定为“1”。</li>
<li>汉字字形码<br>
汉字字形码也叫汉字字模点阵码，是汉字输出时的字形点阵代码，是一串基2码编码。</li>
</ul>
<h5 id="逻辑数据的编码">逻辑数据的编码</h5>
<ul>
<li>逻辑数据是用来表示“是”与“否”，或称“真”与“假”两个状态的数据。<br>
在计算机中，用“1”表示“真”或“是”，用“0”表示“假”或“否”。<br>
需要注意的是，这里的1和0没有数值和大小概念，只有逻辑意义。</li>
<li>对逻辑数据只能进行逻辑运算，例如逻辑非、逻辑加、逻辑乘等基本逻辑运算和由基本逻辑运算构成的各种组合逻辑运算，运算结果仍是逻辑数据。</li>
<li>逻辑运算（按位操作）<br>
“与”运算（AND）<br>
“或”运算（OR）<br>
“非”运算（NOT）<br>
“异或”运算（XOR）</li>
</ul>
<h3 id="计算机中数的表示">计算机中数的表示</h3>
<h4 id="真值与机器数">真值与机器数</h4>
<ul>
<li>计算机中正负数的表示<br>
最高位为符号位<br>
符号位 = 0正数、 = 1 负数</li>
</ul>
<h4 id="有符号数与无符号数">有符号数与无符号数</h4>
<ul>
<li>无符号整数的编码<br>
在某些情况下，计算机要处理的数据全是正数，此时机器数再保留符号位就没有意义了。这时，我们将机器数最高有效位也作为数值位处理。<br>
无符号整数的表示范围为：0≤N≤2^n –1。<br>
在计算机中最常见的无符号整数是地址。另外，双字长数据的低位字也是无符号整数。<br>
要注意的是，计算机本身不论是对有符号数还是无符号数，总是按照补码的运算规则做运算。</li>
</ul>
<h4 id="原码-反码-补码"><strong>原码  反码  补码</strong></h4>
<ul>
<li>原码表示法<br>
符号 + 绝对值</li>
<li>反码表示法<br>
正数的反码同原码<br>
负数的反码数值位与此负数原码数值位相反</li>
<li>补码（Two’s  Complement）表示法<br>
正数的补码： 同原码<br>
负数的补码：<br>
（1）写出与该负数相对应的正数的补码<br>
（2）按位求反<br>
（3）末位加一<br>
n位二进制补码的表数范围：   - 2^(n-1)  ≤  N ≤ 2^(n-1)-1</li>
<li>补码的加法和减法<br>
求补运算 ：对一个二进制数按位求反、末位加一<br>
加法规则：[X+Y]补码  =  [X]补码  +  [Y]补码<br>
减法规则：[X-Y]补码  =  [X]补码  +  [-Y]补码<br>
补码减法可转换为补码加法</li>
<li>进位和溢出<br>
进位: 由于运算结果超出了位数,最高有效位向前的进位，这一位自然丢失，一般不表示结果的对错。<br>
溢出：表示结果超出了字长允许表示的范围， 一般会造成结果出错。</li>
</ul>
<h2 id="12-微型计算机系统">1.2 微型计算机系统</h2>
<p>典型的微型计算机硬件主要由微处理器、存储器、系统总线、I/O接口电路和I/O设备组成。</p>
<h3 id="微处理器-2">微处理器</h3>
<p>微处理器也称中央处理器（CPU），是微型计算机的核心部件，芯片内集成了运算器、控制器和寄存器组，用来执行程序指令，完成所有的算术和逻辑运算及全机的控制工作。</p>
<h3 id="存储器">存储器</h3>
<p>存储器是微型计算机的重要组成部件，用来存放程序和数据。</p>
<ul>
<li>
<p>微型计算机的存储器分为“主存”和“辅存”两类。</p>
<p>主存也称内存，CPU可以通过总线直接存取，微型计算机的主存储器主要都是采用半导体存储器，按照读写方式的不同，分为只读存储器ROM（Read Only Memory）和随机存取存储器RAM（Random Access Memory）两种类型。</p>
<p>辅存也称外存，如磁盘、磁带、光盘等，CPU通过I/O接口对其进行存取，它的容量比内存大很多，但存取信息的速度要比内存慢得多。一般程序（包括数据）是存放在外存中的，只有当运行时，才把它从外存传送到内存的某个区域，再由CPU控制执行。</p>
</li>
</ul>
<h3 id="系统总线">系统总线</h3>
<p>总线是指传送信息的一组公共导线，是计算机各功能部件之间进行信息传输的通道。CPU、存储器和I/O接口电路之间通过DB（数据总线）、AB（地址总线）和CB（控制总线）相连，这三组总线统称为系统总线。</p>
<ul>
<li>数据总线<br>
数据总线是用来传送数据信息的。<br>
该总线是双向总线。<br>
数据总线的位数（也称宽度）决定了一次能够传送数据的位数。</li>
<li>地址总线<br>
地址总线是传送地址信息的。<br>
该总线是单向总线，用来输出CPU要访问的内存单元或I/O端口的地址。<br>
地址总线位数决定了CPU可以直接寻址的内存空间的大小，对于n条地址总线，可直接寻址的内存范围为<strong>2^n</strong>。</li>
<li>控制总线<br>
控制总线是用来传送控制信息的。<br>
这组信号线比较复杂，有的是微处理器送往存储器和I/O接口的控制信号，如读写控制信号、中断响应信号等；有的是将外界的请求或联络信号送往微处理器，如中断请求信号、准备就绪信号等。</li>
</ul>
<p>采用标准的总线结构是微型计算机系统的显著特点之一。采用了总线结构后，一个部件只要符合总线标准，就可以连接到采用这种总线标准的系统中，使系统的功能可以很方便地得以扩展。</p>
<h3 id="io接口电路和io设备">I/O接口电路和I/O设备</h3>
<p>I/O设备是指微型计算机配备的输入输出设备，也称外围设备（简称外设），是微型计算机必不可少的组成部分。对外设的管理是汇编语言的重要应用之一。<br>
由于微机的外部设备种类繁多、工作原理各异，它们不能直接连到微机系统总线上实现与主机通信，必须经过中间电路再与系统相连，通过该电路来完成数据缓冲、信号变换及与CPU联络等工作，这部分电路被称为I/O接口电路。</p>
<h4 id="io接口电路一般由三种寄存器组成">I/O接口电路一般由三种寄存器组成</h4>
<ul>
<li>数据寄存器：用来保存I/O设备和主机之间传送的数据。</li>
<li>状态寄存器：用来保存I/O设备或接口电路的状态信息，以便CPU在需要时可从中读取外设的状态，了解外设的工作情况。</li>
<li>控制寄存器：保存CPU给外设或接口电路的命令。CPU向控制寄存器写入命令，选择接口电路的工作方式或控制外设进行有关操作。</li>
</ul>
<p>为便于主机访问外设，将I/O接口电路中每个寄存器统一编号，称为I/O端口地址或端口号。<br>
<strong>8086的I/O地址空间为64KB，可寻址65536个不同的I/O地址，端口地址的范围是0000H~FFFFH。</strong></p>
<h3 id="软件">软件</h3>
<p>没有配置软件的计算机,什么工作也不能做，软件是计算机系统的重要组成部分。</p>
<ul>
<li>
<p>微型计算机的软件分为系统软件和应用软件两大类。</p>
<p>系统软件是面向所有用户的一类软件，通常包括：操作系统（DOS、Windows、Linux等）、语言翻译程序、诊断调试程序、I/O驱动程序等。<br>
系统软件的核心是操作系统，所有应用的程序都是在操作系统构筑的平台上运行的。</p>
<p>应用软件主要是指用户围绕某项应用编写的各种程序。</p>
</li>
</ul>
<h4 id="系统软件">系统软件</h4>
<p>核心为操作系统，包括：I/O驱动程序、文件管理程序、文本编辑程序等。<br>
应用程序是建立在操作系统之上的，我们采用DOS（MS-DOS 6.22 或 Windows 的MS-DOS环境）</p>
<ul>
<li>开发汇编语言程序涉及到<br>
文本编辑器<br>
汇编程序<br>
连接程序<br>
调试程序</li>
</ul>
<h2 id="13-微型计算机发展概述">1.3  微型计算机发展概述</h2>
<h3 id="双核技术">双核技术</h3>
<ul>
<li>线程：程序由多个执行线程组成，这些线程是一系列相关指令。</li>
<li>超线程技术：专用于浮点和整数数学的逻辑。利用特殊的硬件指令，把两个逻辑内核模拟成两个物理片，让单个处理器都能使用线程级并行计算，进而兼容多线程操作系统和软件，减少了CPU的闲置时间，提高CPU的运行效率。</li>
</ul>
<p>Intel双核采用多个核心共享前端总线的方式。Intel的架构会遇到多个内核争用总线资源的瓶颈问题。</p>
<p>AMD从一开始设计时就考虑到了对多核心的支持。所有组件都直接连接到CPU，消除系统架构方面的挑战和瓶颈。两个处理器核心直接连接到同一个内核上，核心之间以芯片速度通信，进一步降低了处理器之间的延迟。</p>
<p>AMD将两个内核做在一个Die（晶元）上，通过直连架构连接起来，集成度更高。Intel则是将放在不同Die（晶元）上的两个内核封装在一起。因此有人将Intel的方案称为“双芯”，认为 AMD的方案才是真正的“双核”。</p>
<h1 id="第二章-微处理器的结构">第二章 微处理器的结构</h1>
<h2 id="80868088cpu的内部结构">8086/8088CPU的内部结构</h2>
<p>8086微处理器——16位</p>
<ul>
<li>特点：<br>
<strong>内部结构和外部数据总线都是16位的</strong>，可进行8位（字节）和16位（字）算术运算和逻辑运算；<br>
<strong>地址总线20位，可寻址1MB存储空间和64KB的I/O端口；</strong><br>
时钟频率为5MHz~8MHz；<br>
支持单任务单用户操作：只允许登陆一个用户，同时只能运行一个程序。</li>
</ul>
<h3 id="80868088cpu功能结构">8086/8088CPU功能结构</h3>
<h4 id="总线接口部件biu">总线接口部件BIU</h4>
<ul>
<li>组成：<br>
段寄存器、指令指针寄存器、地址加法器、指令队列和输入输出控制电路</li>
<li>功能：<br>
取指令、指令排队、读/写操作数、地址转换、总线控制</li>
</ul>
<h5 id="段寄存器">段寄存器</h5>
<p>4个16位的段寄存器，代码段寄存器CS、数据段寄存器DS、附加段寄存器ES和堆栈段寄存器SS。<br>
用于存放代码段、数据段、附加段、堆栈段起始地址的高16位（段基值）。</p>
<h5 id="指令指针寄存器ip">指令指针寄存器（IP）</h5>
<p>16位，用于存放下一条要执行指令在代码段中的偏移地址。</p>
<h5 id="地址加法器">地址加法器</h5>
<p>20位，用于将逻辑地址变成存储器的20位物理地址。</p>
<h5 id="指令队列">指令队列</h5>
<p>6字节，用于存放从内存中取来的指令，按照先进先出的方式工作，并按顺序送到EU中执行。<br>
其操作遵循下列原则：</p>
<ul>
<li>每当指令队列缓冲器中存满一条指令后，EU就立即开始执行</li>
<li>指令队列缓冲器只要有2个空字节时，BIU就会自动把指令取到指令队列中，直到填满为止。</li>
<li>在执行转移、调用或返回指令时，接下去要执行的指令不再是程序中紧接着排列的那条指令了，这样，指令队列中已经装入的指令就没用了，则要清除指令队列缓冲器，并要求BIU从新地址开始取指令填入指令队列缓冲器。</li>
</ul>
<h5 id="总线控制电路">总线控制电路</h5>
<p>将CPU的内部总线与系统总线相连，产生和输出对外部操作的地址信号、数据信号、总线控制信号，以实现CPU与I/O设备、存储器间的数据传递，是CPU与内存单元或I/O端口交换数据的必经之路。</p>
<h4 id="执行部件eu">执行部件EU</h4>
<ul>
<li>组成<br>
算术逻辑部件(ALU)、通用寄存器、标志寄存器、暂存器、控制器</li>
<li>功能<br>
指令的执行、数据的运算、指令译码</li>
</ul>
<h4 id="通用寄存器">通用寄存器</h4>
<p>4个16位的数据寄存器AX、BX、CX、DX，用于存放8位数据；<br>
4个16位的指针与变址寄存器SI、DI与SP、BP，用于存放偏移地址。</p>
<h5 id="标志寄存器fr">标志寄存器(FR)</h5>
<p>16位的寄存器，用于存放运算结果的状态标志和控制标志。</p>
<h5 id="算术逻辑部件alu">算术逻辑部件(ALU)</h5>
<p>用于完成8位或16位二进制算术和逻辑运算</p>
<h5 id="执行部件控制电路">执行部件控制电路</h5>
<p>负责从总线接口部件（BIU）的指令队列缓冲器中取指令，并对指令进行译码，根据指令要求向执行部件内部个部分发出控制命令以完成各条指令的功能。</p>
<h3 id="8086的寄存器结构">8086的寄存器结构</h3>
<h4 id="通用寄存器-2">通用寄存器</h4>
<p>8个16位寄存器AX、BX、CX、DX、BP、SP、SI、DI<br>
8个8位寄存器AH、AL、BH、BL、CH、CL、DH、DL。<br>
数据寄存器共有4个寄存器AX、BX、CX、DX，用来保存操作数或运算结果等信息。</p>
<h4 id="ax-累加器">AX 累加器</h4>
<p>用于算术、逻辑运算以及与外设传送信息等。<br>
在有些指令中要求必须使用AX或AL（称为隐含寻址），如乘除法指令和I/O指令。</p>
<h4 id="bx-基址寄存器">BX 基址寄存器</h4>
<p>在存储器寻址中，常用于存放操作数的16位偏移地址。</p>
<h4 id="cx-计数器">CX 计数器</h4>
<p>一般作为循环或串操作等指令中的计数器。<br>
在位操作中，当移多位时，要用CL来指明移位的位数。</p>
<h4 id="dx-数据寄存器">DX 数据寄存器</h4>
<p>在乘除法指令中与AX配合存放运算结果；<br>
在I/O指令的间接寻址中，存放端口地址；<br>
其他场合存放16位数据。</p>
<h4 id="bp-基址指针寄存器">BP 基址指针寄存器</h4>
<p>用MOV指令读/写堆栈中的数据时，用BP寻址堆栈的16位偏移地址。</p>
<h4 id="sp-堆栈指针">SP 堆栈指针</h4>
<p>在堆栈操作指令PUSH和POP中，用SP指向栈顶的偏移地址。<br>
SP和BP通常和SS连用，可以对堆栈中的数据进行读/写操作。</p>
<h4 id="si-源变址寄存器">SI 源变址寄存器</h4>
<p>在串操作指令中，SI用于存放源操作数（源串）的偏移地址，并且SI的内容有自动加减修改功能；<br>
在存储器寻址中，SI通常与DS联用，为程序访问当前数据段提供操作数的段内偏移地址。</p>
<h4 id="di-目的变址寄存器">DI 目的变址寄存器</h4>
<p>在串操作指令中，DI用于存放目的操作数（目的串）的偏移地址，并且DI的内容有自动加减修改功能；<br>
在存储器寻址中，DI通常与DS联用，为程序访问当前数据段提供操作数的段内偏移地址。</p>
<h3 id="段寄存器-2">段寄存器</h3>
<p>段寄存器用来存储20位起始地址的高16位（段基址或段基值）。<br>
段寄存器是根据内存分段的管理模式而设置的。<br>
内存单元的<strong>物理地址</strong>由段寄存器的值和一个偏移量组合而成的，这样可用两个较少位数的值组合成一个可访问较大物理空间的内存地址。</p>
<h4 id="cs-代码段寄存器">CS 代码段寄存器</h4>
<p>用来存放程序的指令序列<br>
代码段寄存器CS存放代码段的段地址<br>
指令指针寄存器IP指示下条指令的偏移地址<br>
即BIU里面的指令列队存放着下一条要执行的指令，而该指令的地址由两部分组成，一个是段首址，另一个是偏移地址，段首址存放在段寄存器CS中，而偏移地址就是IP<br>
（段基址+偏移地址=逻辑地址）<br>
（物理地址=存储器中真实地址）<br>
CPU利用（CS:IP）取得下一条要执行的指令</p>
<h4 id="ds-数据段寄存器">DS 数据段寄存器</h4>
<p>存放运行程序所用的数据（地址）<br>
数据段寄存器DS存放数据段的段地址<br>
各种主存寻址方式（有效地址EA）得到存储器中操作数的偏移地址<br>
CPU利用（DS:EA）存取数据段中某一存储单元的地址</p>
<h4 id="ss-堆栈段寄存器">SS 堆栈段寄存器</h4>
<p>确定堆栈所在的主存区域<br>
堆栈段寄存器SS存放堆栈段的段地址<br>
堆栈指针寄存器SP指示堆栈栈顶的偏移地址<br>
CPU利用（SS:SP）操作堆栈顶的地址</p>
<h4 id="es-附加段寄存器">ES 附加段寄存器</h4>
<p>一个段的空间最大是64KB。<br>
要在2个相距超过64KB的单元传递数据，仅以DS为段址寄存器时，一般需要先设置DS为源数据单元所在的段址，读出数据后，再改变DS的值为接收数据的目的单元所在的段址，实现传递数据功能。如果不想频繁改变DS的值，可以使用ES。</p>
<h3 id="ip-指令指针寄存器">IP 指令指针寄存器</h3>
<p>16位寄存器<br>
用于存放将要执行的指令在现行代码段中的偏移地址。<br>
IP的内容是在启动程序执行时由系统自动设置的，程序在运行过程中，IP的内容由BIU自动修改，使IP始终指向下一条将要执行的指令地址。<br>
正常情况，程序不能修改IP内容，但跳转指令或者调用指令会使IP的内容发生改变。<br>
IP，它总是保存下一次将要从主存中取出指令的偏移地址，偏移地址的值为该指令到所在段段起始址的字节距离。</p>
<h3 id="fr-标识寄存器">FR 标识寄存器</h3>
<p>16位，在8086中只定义了9位。</p>
<h4 id="状态标志">状态标志</h4>
<p>用来记录程序运行结果的状态信息，许多指令的执行都将相应地设置它。<br>
状态标志：6个，用于表示运算结果特征，由CPU在运算过程中自动设置。</p>
<h5 id="of-溢出标志">OF  溢出标志</h5>
<p>运算结果是否超出及其所能表示的范围。溢出，OF=1，否则=0。<br>
只对判有符号数的运算结果产生溢出有意义。</p>
<h5 id="sf-符号标志">SF  符号标志</h5>
<p>运算结果最高位的状态。运算结果为负数，SF=1，否则=0。<br>
对于逻辑运算只表示结果的最高位是1或0，无实际意义。</p>
<h5 id="zf-零标志">ZF  零标志</h5>
<p>运算结果是否为零，为零，ZF=1，否则=0。</p>
<h5 id="cf-进位标志">CF  进位标志</h5>
<p>计算结果使最高位产生进位或借位情况时，CF=1，否则=0。</p>
<h5 id="af-辅助进位标志">AF  辅助进位标志</h5>
<p>运算结果低4位向高4位有进位或借位时，AF=1，否则=0。<br>
用于BCD码运算中的十进制调整指令。</p>
<h5 id="pf-奇偶标志">PF  奇偶标志</h5>
<p>运算结果中的低8位有偶数个1，PF=1，否则=0。</p>
<h4 id="控制标志">控制标志</h4>
<p>可由程序根据需要用指令设置，用于控制处理器执行指令的方式。<br>
控制标志：3个，用于控制CPU中断与执行方式，用户可以使用指令对这3位进行置位或清楚。</p>
<h5 id="df-方向标志">DF   方向标志</h5>
<p>决定操作数的地址是按递增方式修改还是递减方式修改。<br>
DF=0，则为递增方式，对于字节操作SI/DI自动加1，对于字操作SI/DI自动加2；<br>
DF=1，则为递减方式，对于字节操作SI/DI自动减1，对于字操作SI/DI自动减2。<br>
DF的状态由STD指令置位和CLD指令清除。</p>
<h5 id="i-f-中断允许标志">I F   中断允许标志</h5>
<p>控制INTR（屏蔽中断请求）输入引脚操作。<br>
IF=1，INTR请求被允许，CPU响应中断请求，转去执行中断处理程序。<br>
IF的状态由STI指令置位（开中断）和CLI指令清除（关中断）。</p>
<h5 id="tf-单步标志陷阱标志">TF   单步标志（陷阱标志）</h5>
<p>用于调试程序，以便找到错误或故障。<br>
TF=1，CPU单步执行，每执行完一条指令就自动产生一个内部中断，使用户可逐条跟踪程序进行调试。</p>
<h2 id="8086的存储器组织">8086的存储器组织</h2>
<h3 id="存储器组织与数据存储格式">存储器组织与数据存储格式</h3>
<h4 id="存储单元地址">存储单元地址</h4>
<p>8086系统中，为了标识和存取每一个存储单元，给每个存储单元规定一个编号。</p>
<h4 id="存储单元的内容">存储单元的内容</h4>
<p>一个存储单元中存放的信息称为该存储单元的内容。</p>
<p>8086的存储器空间为1MB，地址范围为00000H~FFFFFH。</p>
<ul>
<li>注意<br>
存储器以字节（8 bit）为编程单位<br>
每个字节单元都有唯一的地址编码<br>
地址用无符号整数来表示（编程用十六进制表示）<br>
一个字要占用相继的两个字节<br>
低位字节存入低地址，高位字节存入高地址<br>
字单元地址用它的低地址来表示</li>
</ul>
<h4 id="奇地址存储体和偶地址存储体">奇地址存储体和偶地址存储体</h4>
<p>将1MB存储空间分为两个512KB的存储体：奇地址存储体和偶地址存储体；<br>
偶地址存储体与数据线的D7~D0相连，每个存储单元的地址为偶数地址；<br>
奇地址存储体与数据线的D15~D8相连，每个存储单元的地址为奇数地址；<br>
CPU既可以单独对其中一个存储体读/写8位数据，也可以对两个存储体中相邻的两字节单元读/写16位数据。</p>
<h4 id="8086指令系统中字节和字两种操作指令">8086指令系统中，字节和字两种操作指令。</h4>
<ul>
<li>字节数据：一个数据占用一个存储单元，有一个对应的唯一地址。</li>
<li>字数据：一个数据占用相邻两个存储单元，低地址存放低8位，高地址存放高8位，两个地址中较小的作为字的地址。</li>
</ul>
<h3 id="存储器分段结构">存储器分段结构</h3>
<p>8086 CPU的地址总线是20位的，它最大可寻址空间为1MB，而8086的内部寄存器是16位寄存器，16位寄存器只能寻址2^16=64KB，为了能用16位寄存器来有效地访问1MB的存储空间，  8086 CPU采用了内存分段的管理模式。<br>
8086把1MB存储空间分成若干个逻辑段，每个逻辑段最大为64KB，这样段内地址可以用16位表示，这样，系统的整个存储空间可分为16个互不重叠的逻辑段。</p>
<h4 id="根据段内存放信息的不同分为">根据段内存放信息的不同分为</h4>
<p>代码段——存放程序<br>
数据段——存放数据<br>
堆栈段——存放需要保存的信息<br>
附加段——存放数据</p>
<h3 id="逻辑地址与物理地址的转换">逻辑地址与物理地址的转换</h3>
<p><strong>物理地址=段基值×10H + 偏移地址</strong></p>
<h4 id="物理地址">物理地址</h4>
<p>访问存储器的实际地址，一个存储单元对应唯一的一个物理地址。</p>
<h4 id="逻辑地址">逻辑地址</h4>
<p>对应逻辑段内的一种地址表示形式，由段基值和段内偏移地址组成，表示为段基值：<br>
偏移地址。其中，段基值由段寄存器提供，偏移地址由指令的寻址方式提供。</p>
<h4 id="段基值">段基值</h4>
<p>逻辑段20位起始地址中的高16位地址值。</p>
<p>起始地址=段基值+4个0</p>
<h2 id="8086的工作模式及引脚信号">8086的工作模式及引脚信号</h2>
<h3 id="8086的工作模式">8086的工作模式</h3>
<p>为了尽可能适应各种各样的使用场合，在设计8086 CPU芯片时， 使它们可以在两种模式下工作，即<strong>最小模</strong>式和<strong>最大模式</strong>。</p>
<h4 id="最小模式">最小模式</h4>
<p>系统中只有一个8086微处理器，所有的总线控制信号都由8086直接产生。</p>
<ul>
<li>MN/MX端接+5V，工作在最小模式；</li>
<li>有一片8284A，作为时钟信号发生器；</li>
<li>有三片8282或74LS273，用来作为地址信号的锁存器；</li>
<li>当系统中所连的存储器和外设端口较多时，需要增加数据总线的驱动能力，这时，需用2片8286/8287作为数据总线收发器。</li>
</ul>
<h4 id="最大模式">最大模式</h4>
<p>指系统中至少包含两个微处理器，其中一个为主处理器，即8086 CPU，其它的微处理器称之为协处理器，它们是协助主处理器工作的。</p>
<ul>
<li>该模式适用于大中型规模的微机应用系统。</li>
<li>最小模式所拥有的配置；</li>
<li>有一片8288总线控制器来对CPU发出的控制信号进行变换和组合，以得到对存储器或I/O 端口的读/写信号和对锁存器8282及数据总线收发器8286的控制信号。</li>
<li>有8259A（可选）用以对多个中断源进行中断优先级的管理，但如果中断源不多，也可以不用中断优先级管理部件。</li>
</ul>
<h4 id="8087">8087</h4>
<p>是一种专用于数值运算的协处理器，它能实现多种类型的数值运算，如高精度的整型和浮点型数值运算，超越函数（三角函数、对数函数）的计算等，引入8087协处理器，可以把软件功能硬件化，大大的提高了主处理器的运行速度。</p>
<h4 id="8089协处理器">8089协处理器</h4>
<p>在原理上有点象带有两个DMA通道的处理器，它有一套专门用于输入/输出操作的指令系统，但是8089又和DMA控制器不同，它可以直接为输入/输出设备服务，使主处理器不再承担这类工作。所以，在系统中增加8089协处理器之后，会明显提高主处理器的效率，尤其是在输入/输出操作比较频繁的系统中。</p>
<h3 id="8086的引脚信号">8086的引脚信号</h3>
<h4 id="ad15~ad0address-data-bus-2~16">AD15~AD0(Address Data Bus ，2~16)</h4>
<p>地址/数据分时复用总线，三态、双向。在总线周期的T1状态，输出访问存储器或I/O端口的地址信息；在T2~T3状态，传递数据信息。</p>
<h5 id="总线分时复用">总线分时复用</h5>
<p>总线分时复用就是同一总线在不同时间传输的是不同的信号，这些信号的作用是不同的。8086采用总线分时复用方法在不影响CPU功能的情况下，减少了CPU的引脚数目，使系统得到简化。</p>
<h5 id="三态">三态</h5>
<p>三态是指总线输出可以有三个状态：高电平、低电平和高阻状态。当处于高阻状态时，该总线在逻辑上与所有连接负载断开。</p>
<h4 id="a19s6~a16s3address-status-bus35~38">A19/S6~A16/S3(Address Status Bus，35~38)</h4>
<p>地址/状态分时复用线，三态输出。总线周期的T1状态，输出访问存储器的最高4位的地址，与AD15<sub>AD0一起构成20位地址码，访问I/O端口时A19</sub>A16无效。在总线周期的T2~T4用来输出状态信息。</p>
<ul>
<li>状态信息号S6~S3作用如下：<br>
S6恒为0，表示8086当前与总线相连。<br>
S5表明中断允许标志的当前设置。如果IF=1，则S5=1，表示允许可屏蔽中断请求；如果IF=0，则S5=0，表示禁止一切可屏蔽中断请求。<br>
S4和S3组合使用，用于指出当前正在使用哪个段寄存器。</li>
</ul>
<h5 id="可屏蔽中断">可屏蔽中断</h5>
<p>可屏蔽中断属于外中断，是CPU可以不响应的中断。即当这种中断发生时，CPU可以不予以理睬，继续埋头做正在做的事；但CPU是否响应可屏蔽中断，要看标志寄存器的IF位的设置。当CPU检测到可屏蔽中断信息时，如果IF=1，则CPU必须响应；如果IF=0，CPU就不理它了，等于被屏蔽掉了。</p>
<h4 id="bhes7bus-high-enablestatus34">BHE/S7（Bus High Enable/Status，34）</h4>
<p>S7在8086中未定义，作为备用状态信号。<br>
高8位数据总线允许/状态复用线，三态输出。BHE在总线周期的T1状态输出，低电平有效，用来表示当前高8位数据总线D15~D8上数据有效。该引脚和地址总线A0（16）配合表示数据总线上的状态。</p>
<h4 id="mnmxminimummaximum-model-control33">MN/MX(Minimum/Maximum Model Control，33)</h4>
<p>最小/最大模式控制信号，输入。当接高电平（接+5V）时，8086工作在最小模式，系统的控制信号全部由8086提供；当接低电平（接地）时，8086工作在最大模式，8086发出的控制信号经总线控制器进行变换和组合后作为系统的控制信号。</p>
<h4 id="rdread32">RD(Read，32）</h4>
<p>读信号，三态输出，低电平有效。低电平时，8086正在对存储器或I/O端口进行读操作。</p>
<h4 id="testtest23">TEST(Test，23)</h4>
<p>测试信号，输入，低电平有效。TEST与等待指令WAIT配合使用。8086执行WAIT指令后，8086处于空转等待状态。TEST=1，则8086继续处于空转等待状态；TEST=0，退出等待状态，继续执行下一条指令。TEST信号用于多处理器系统中，实现8086主CPU与其他协处理器之间的同步协调功能。</p>
<h4 id="readyready22">READY(Ready，22)</h4>
<p>准备就绪信号，输入，高电平有效。当READY为高电平时，表示内存或I/O设备的数据已准备就绪，可以立即进行一次数据传输。READY=1，则按正常时序进行读、写操作；READY=0，则表示存储器或I/O设备没有准备好数据，不能进行数据传输。</p>
<h4 id="resetreset21">RESET(Reset，21)</h4>
<p>复位信号，输入，高电平有效。复位后，8086内部寄存器初始化，除CS=FFFFH外，包括IP在内的其余寄存器的值均为0。复位后将从逻辑地址FFFFH：0000H处开始执行程序。一般在该地址放置一条转移指令，以转到程序真正的入口地址。</p>
<h4 id="clkclock19">CLK(Clock，19)</h4>
<p>系统时钟，输入。CLK提供8086和总线控制的基本定时脉冲。8086的系统时钟由时钟发生器8284产生。</p>
<h4 id="vcc40">VCC(40)</h4>
<p>电源线，输入。8086电源为5V±10%。</p>
<h4 id="gnd1-20">GND(1、20)</h4>
<p>地线，输入。</p>
<h4 id="nminon-maskable-interrupt17">NMI(Non-Maskable Interrupt，17)</h4>
<p>非屏蔽中断请求信号，输入，上升沿有效。NMI中断请求不受中断允许标志IF的控制，只要在该引脚有上升沿出现，在当前指令结束后8086立即进入非屏蔽中断请求处理。NMI中断通常用于系统紧急情况的处理，如系统电源掉电等。</p>
<h4 id="intrinterrupt-request18">INTR(Interrupt Request，18)</h4>
<p>可屏蔽中断请求信号，输入，高电平有效。IF=1，且INTR接+5V时，8086在当前指令周期结束后进行INTR中断处理。</p>
<h5 id="可屏蔽中断和非屏蔽中断的区别">可屏蔽中断和非屏蔽中断的区别</h5>
<p>可屏蔽中断和不可屏蔽中断都属于外部中断，是由外部中断源引起的；但它们也有区别：可屏蔽中断是通过CPU的INTR引脚引入，当中断标志IF＝1时允许中断，当IF=0时禁止中断，不可屏蔽中断是由NMI引脚引入，不受IF标志的影响。</p>
<h4 id="最小模式下的24到31引脚">最小模式下的24到31引脚</h4>
<h5 id="intainterrupt-acknowledge24">INTA(Interrupt Acknowledge，24）</h5>
<p>中断响应信号，三态输出，低电平有效。INTA是对可屏蔽中断请求信号INTR的响应信号。INTR=1且IF=1时，8086响应INTR请求，向请求设备发送连续的两个INTA中断响应周期信号，表明8086进入了INTR中断处理过程。</p>
<h5 id="aleaddress-lock-enable25">ALE(Address Lock Enable，25)</h5>
<p>地址锁存允许信号，三态输出，高电平有效。当地址/数据线上传送的是地址信息时，ALE信号有效，将地址/数据线上输出的地址信息所存。</p>
<h5 id="dendata-enable26">DEN(Data Enable，26)</h5>
<p>数据允许信号，三态输出，低电平有效。当地址/数据线上传送的是数据信息时，DEN信号有效。</p>
<h5 id="dtrdata-transmitreceive27">DT/R(Data Transmit/Receive，27)</h5>
<p>数据发送/接受控制信号，三态输出。用来控制数据总线上数据传送的方向，通常作为数据总线缓冲器的控制信号。当DT/R为高电平时，8086向存储器或I/O设备发送数据；当DT/R为低电平时，8086从存储器或I/O设备接受数据。</p>
<h5 id="miomemoryinput-output28">M/IO(Memory/Input &amp;Output，28)</h5>
<p>存储器和I/O设备的选择信号，三态输出。数据传送时自动产生的输出信号，用来表示当前是访问存储器还是访问I/O设备。当M/IO为高电平时，表示与存储器传送数据；当M/IO为低电平时，表示与I/O设备传送数据。</p>
<h5 id="wr-write29三态">WR (Write，29，三态)</h5>
<p>写信号，三态输出，低电平有效。低电平时，8086正在度存储器或I/O端口进行写操作。</p>
<h5 id="holdhold-reqest31">HOLD(Hold Reqest，31)</h5>
<p>总线保持请求信号，输入，高电平有效。在最小工作模式中，当除8086 CPU以外的其他总线控制器要求占用总线时，可通过此引脚向CPU发送请求占用总线的信号。例如，系统中的DMA控制器就是通过此引脚向CPU申请使用系统总线的。</p>
<h5 id="hlda-hold-acknowledge30">HLDA (Hold Acknowledge，30)</h5>
<p>总线保持响应信号，输出，高电平有效。该信号是对HOLD的响应信号。当CPU检测到总线请求信号HOLD为高电平时，且CPU允许其他设备占用总线时，则在当前总线周期结束时，输出HLDA信号，作为对总线保持请求信号HOLD的响应，并立即使总线置为高阻状态，CPU放弃对总线的控制权。当获得总线使用权的控制器用完总线后，使HOLD信号变为低电平，表示放弃对总线的控制权。8086CPU检测到HOLD变为低电平后，会使HLDA变为低电平，恢复对总线的控制。</p>
<h4 id="最大工作模式下的引脚信号">最大工作模式下的引脚信号</h4>
<h5 id="rqgtrequestgrant30-31">RQ/GT(Request/Grant，30、31)</h5>
<p>总线请求输入/总线请求允许输出信号，双向，低电平有效。这两个信号是在最大模式系统中主CPU和其他协处理器(如8087、8089）之间交换总线使用权的联络控制信号。RQ为总线请求输入信号，GT为总线请求允许输出信号。</p>
<h5 id="lock">LOCK</h5>
<p>总线封锁信号，三态输出，低电平有效。当LOCK为低电平时，CPU不允许其他总线主控设各占用总线。LOCK信号由指令前缀LOCK产生。在8086CPU处于2个INTA中断响应周期期间，LOCK信号会自动变为有效的低电平，以防止其他总线控制器在中断响应过程中占用总线而使一个完整的中断响应过程被间断。</p>
<h5 id="s2-s1-s0bus-cycles-status">S2、S1、S0(Bus Cycles Status)</h5>
<p>总线周期状态信号，三态输出，低电平有效。</p>
<h5 id="qs1qs0-instruction-queue-status">QS1,QS0 (Instruction Queue Status)</h5>
<p>指令队列状态信号，输出。</p>
<h2 id="8086的总线操作时序">8086的总线操作时序</h2>
<h3 id="时钟周期clock-cycle">时钟周期（Clock Cycle）</h3>
<p>微处理器执行指令的最小时间单位，又称T状态。<br>
例如，8086主频为5MHz，则1个时钟周期为200ns。</p>
<h3 id="指令周期instruction-cyclefetch-decode-execute-cycle">指令周期（Instruction Cycle，fetch-decode-execute cycle）</h3>
<p>CPU执行一条指令所需的时间。</p>
<h3 id="总线周期bus-cycle">总线周期（Bus Cycle）</h3>
<p>CPU对存储器或I/O端口完成一次读/写操作所需时间。</p>
<ul>
<li>振荡周期=1/振荡频率</li>
<li>机器周期=12*振荡周期</li>
</ul>
<h3 id="总线操作步骤">总线操作步骤</h3>
<h4 id="总线操作">总线操作</h4>
<p>通过总线完成存储器读写、I/O读写等的一系列操作。</p>
<h4 id="一个总线周期通常分为四个阶段">一个总线周期通常分为四个阶段</h4>
<h5 id="总线请求和仲裁阶段">总线请求和仲裁阶段</h5>
<p>当有多个模块提出总线请求时，必须由仲裁机构仲裁，确定将总线的使用权分配给哪个模块。</p>
<h5 id="寻址阶段">寻址阶段</h5>
<p>取得使用总线权的模块经总线发出本次要访问的M或I/O端口的地址和有关命令。</p>
<h5 id="传送数据阶段">传送数据阶段</h5>
<p>主模块（指取得总线控制权的模块）与其它模块之间进行数据的传送。</p>
<h5 id="结束阶段">结束阶段</h5>
<p>主从模块将有关信息从总线上撤除，主模块交出总线的控制权。</p>
<h3 id="8086的总线操作时序-2">8086的总线操作时序</h3>
<h4 id="总线操作-2">总线操作</h4>
<p>通过总线完成存储器读写、I/O读写等的一系列操作。</p>
<h4 id="总线时序">总线时序</h4>
<p>与完成总线操作有关的地址线、数据线、控制线及时钟信号相互之间的先后关系，一般用时序图表示。</p>
<h5 id="最小模式下的读总线周期">最小模式下的读总线周期</h5>
<p>一个总线读周期由4个时钟周期T1~T4组成，每个时钟周期称为状态周期。</p>
<h5 id="最小模式下的写总线周期">最小模式下的写总线周期</h5>
<h5 id="空闲周期">空闲周期</h5>
<p>只有BIU与内存或I/O端口交换数据，以及填充指令队列时，BIU才执行总线周期。除此之外，既不需要填充指令队列，EU也没有向BIU发出总线周期请求时，系统总线就处于空闲状态，进入空闲周期，空闲周期由一个或几个TI状态组成。</p>
<ul>
<li>在8086中，一个基本的总线周期由4个时钟周期组成。</li>
</ul>
<h1 id="第三章-指令系统">第三章 指令系统</h1>
<h2 id="指令格式">指令格式</h2>
<p>指令是计算机能够识别和执行的操作命令，由二进制数“0”、“1”组成。每条指令的编码格式由机器指令系统规定。机器指令的集合称为指令系统。指令由操作码和操作数两部分组成。</p>
<ul>
<li>操作码  ：说明指令操作的性质和功能，如传送、运算、移位、跳转等操作，它是指令中不可缺少的组成部分。常用OP表示。</li>
<li>操作数  ： 用于提供指令中要处理的数据或数据所在的地址信息。是指令执行的参与者，即各种操作的对象。<br>
一条指令常由6个字段组成，字段1为前缀字段，字段2~6为基本字段。指令长度超过16字节为非法指令。</li>
</ul>
<h3 id="前缀字段">前缀字段</h3>
<p>前缀字段用于修改指令操作的某些属性，为可选字段。<br>
（1）段超越前缀：用于指明某个段寄存器取代指令中默认的段寄存器。<br>
（2）操作数宽度前缀：用于改变当前操作数的默认宽度值。<br>
（3）地址宽度前缀：用于改变当前地址的默认宽度值。<br>
（4）重复前缀：用于重复串的操作。<br>
（5）总线锁定前缀：用于产生LOCK信号，防止其他设备中断CPU在总线上的操作。</p>
<h3 id="操作码字段1~2字节">操作码字段(1~2字节)</h3>
<p>规定了指令的操作性质和功能。此字段不可省略。</p>
<h3 id="寻址方式字段2字节">寻址方式字段（2字节）</h3>
<p>规定了操作数的寻址方式，包括操作数长度、采用的寻址方式、操作数的存放位置。</p>
<h3 id="位移量字段1-2或4字节">位移量字段（1、2或4字节）</h3>
<p>当寻址方式中有位移量时，指令中将出现此字段。通常用带符号数(补码)表示。</p>
<h3 id="立即数字段12或4字节">立即数字段(1，2或4字节)</h3>
<p>当寻址方式是立即数寻址时，需用此字段。立即数为带符号数，以补码形式存储。</p>
<p>操作码字段是必选字段，其它各字段可根据不同的寻址方式选用。</p>
<h2 id="寻址方式">寻址方式</h2>
<ul>
<li>寻址：寻找操作数的地址。</li>
<li>寻址方式：寻找操作数/操作数地址的方法。</li>
</ul>
<p>根据操作数存放位置不同，指令中操作数分为：<br>
（1）立即操作数：操作数包含在指令中，存放在代码段，其取指令的同时，操作数也随着取出，称这种操作数为立即操作数，寻址方式为立即寻址。<br>
（2）寄存器操作数：这种操作数存放在CPU内部的某个寄存器中，在指令中提供存放操作数的寄存器名。CPU执行指令时，在指定的寄存器中存取操作数，寻址方式为寄存器寻址。<br>
（3）存储器操作数：操作数存放在内存储器中，如数据段和附加段。CPU对存储器操作数进行操作时，指令中提供操作数在寄存器中存放的地址，这种寻址方式为存储器寻址。<br>
（4）I/O端口操作数：操作数存放在I/O接口的端口中，CPU通过I/O接口与输入输出设备交换信息，这种寻址方式为I/O寻址。</p>
<p>速度由快到慢：立即寻址、寄存器寻址、存储器寻址和I/O寻址。</p>
<p>在80X86微机系统中，程序中采用的是逻辑地址方式，即内存单元的地址由段基值和偏移地址两部分组成。在实模式工作方式下，段基值由段寄存器提供，偏移地址由指令提供。</p>
<p>物理地址=段基值×10H+偏移地址</p>
<ul>
<li>段基值在段定义之后便可确定，通常由系统分配。</li>
<li>偏移地址由指令中的寻址方式确定，由下列元素组成：基址寄存器、变址寄存器、比例因子、位移量，这4部分称为偏移地址4元素。</li>
</ul>
<p>由偏移地址4种元素按某种计算方法组合形成的偏移地址称为有效地址EA（Effective Address）。</p>
<p>计算方法：EA=基址+（间址×比例因子）+位移量</p>
<ul>
<li>采用16位寻址：用BX和BP作基址寄存器，SI和DI作变址寄存器，比例因子为1（省略），位移量是8位或16位。</li>
<li>采用32位寻址： 32位的通用寄存器都可作基址寄存器或变址寄存器（ESP不用于变址），可采用2、4、8几种比例因子，可使用8位、16位和32位的位移量。</li>
</ul>
<h3 id="11种寻址方式及对应的有效地址">11种寻址方式及对应的有效地址</h3>
<table>
<thead>
<tr>
<th style="text-align:center">寻址方式</th>
<th style="text-align:center">有效地址EA</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">立即</td>
<td style="text-align:center">imm</td>
<td style="text-align:center">操作数在代码段</td>
</tr>
<tr>
<td style="text-align:center">寄存器</td>
<td style="text-align:center">通用寄存器</td>
<td style="text-align:center">操作数在CPU内部</td>
</tr>
<tr>
<td style="text-align:center">直接</td>
<td style="text-align:center">EA=直接地址</td>
<td style="text-align:center">(1)</td>
</tr>
<tr>
<td style="text-align:center">寄存器间接</td>
<td style="text-align:center">EA=(基址或变址)</td>
<td style="text-align:center">(1)</td>
</tr>
<tr>
<td style="text-align:center">寄存器相对</td>
<td style="text-align:center">EA=(基址或变址)+位移量</td>
<td style="text-align:center">(1)</td>
</tr>
<tr>
<td style="text-align:center">基址加变址</td>
<td style="text-align:center">EA=(基址+变址)</td>
<td style="text-align:center">(1)</td>
</tr>
<tr>
<td style="text-align:center">带位移的基址加变址</td>
<td style="text-align:center">EA=(基址+变址)+位移量</td>
<td style="text-align:center">(1)</td>
</tr>
<tr>
<td style="text-align:center">比例变址</td>
<td style="text-align:center">EA=(变址) x 比例因子</td>
<td style="text-align:center">(1)、(2)</td>
</tr>
<tr>
<td style="text-align:center">带位移的比例变址</td>
<td style="text-align:center">EA=(变址) x 比例因子+位移量</td>
<td style="text-align:center">(1)、(2)</td>
</tr>
<tr>
<td style="text-align:center">基址加比例变址</td>
<td style="text-align:center">EA=(基址)+(变址) x 比例因子</td>
<td style="text-align:center">(1)、(2)</td>
</tr>
<tr>
<td style="text-align:center">带位移的基址加比例变址</td>
<td style="text-align:center">EA=(基址)+(变址) x 比例因子+位移量</td>
<td style="text-align:center">(1)、(2)</td>
</tr>
</tbody>
</table>
<p>(1)操作数在内存的数据段、附加段、堆栈段。<br>
(2)只适用于32位寻址。</p>
<h3 id="寻址方式分类">寻址方式分类</h3>
<p>(1)与数据有关的寻址方式：确定内存单元的地址<br>
(2)与转移地址有关的寻址方式：确定转移地址</p>
<h3 id="立即寻址方式">立即寻址方式</h3>
<p>指定的操作数紧跟在操作码之后，直接存放在代码段中操作数可以是8位、16位。<br>
立即数在指令中表示一个常数。只能作为源操作数给目标单元（寄存器或存储单元）赋值。<br>
如：MOV  AL，20H                 ；AL ←20H<br>
MOV  AX，1234H             ；AX ←1234H</p>
<p>立即数作为指令的一部分直接从指令预取单元中取出，不需要再次访问存储器，因此这种寻址方式执行速度快。</p>
<h3 id="直接寻址方式">直接寻址方式</h3>
<p>操作数有效地址（16位或32位）直接包含在指令中，它位于操作码之后，存放在代码段中，按低地址存放低字节，高地址存放高字节。</p>
<p>两种表示形式：<br>
一种以常数形式给出有效地址（数值地址），用方括号表示；<br>
一种用符号地址代替数值地址，方括号可有可无，符号地址必须在程序中定义（变量定义语句）。</p>
<p>例如：MOV AX, [2000H]<br>
MOV BX, VALUE     或    MOV BX, [VALUE]</p>
<p>8086指令中有效地址（EA）由以下3部分组成：<br>
EA=基址＋变址＋位移量</p>
<ul>
<li>位移量（displacement）：存放在指令中的一个8位或16位的数，但它不是立即数，而是一个地址；</li>
<li>基址（base）：存放在基址寄存器（BX、BP）中的内容。它是有效地址中的基址部分，通常用于指向数据段中数组或字符串的首地址。</li>
<li>变址（index）：存放在变址寄存器（SI、DI）中的内容。通常用来指向数组中某个元素或字符串的某个字符。</li>
</ul>
<p>根据有效地址中含有的成分不同，分别构成不同的寻址方式 。<br>
在执行指令时，先由段寄存器给给出的段基值和指令给出的有效地址算出操作数的物理地址，然后到该物理单元中存取数据。</p>
<p>MOV  BL,[1020H]   ; 将数据段（DS）×10H+1020H中的8位数传送到BL中<br>
MOV  AX,[10A0H]  ; 将数据段（DS）×10H+10A0H中的16位数传送到AX中<br>
MOV  BH,ES:[0010H]  ; 将附加段（ES）×10H+0010H中的8位数传送到BH中<br>
MOV  [0060H],1234H  ; 将立即数1234H传送到数据段（DS）×10H+0060H单元中<br>
MOV  ES:[1000H],78H  ; 将立即数78H传送到附加段（ES）×10H+1000H单元中</p>
<ul>
<li>注意：<br>
直接寻址方式既可以用于源操作数，也可以用于目的操作数，但不允许在同一条指令中同时使用。</li>
</ul>
<h3 id="寄存器寻址方式">寄存器寻址方式</h3>
<p>操作数在寄存器中，CPU中的8位、16位通用寄存器都可以存放操作数。既能作为源操作数，也可以作为目的操作数，在指令中由寄存器的名称表示。<br>
功能：操作数直接存放在寄存器中。</p>
<p>如：<br>
MOV  BL,20H       ；BL ← 20H，目标为寄存器寻址<br>
MOV  AX，BX      ；AX ←（BX）</p>
<p>由于存取此类操作数在CPU内部进行，不需要访问存储器，所以执行速度较快。<br>
指令中可以引用的寄存器及其符号名称如下：<br>
8位寄存器有：AH、AL、BH、BL、CH、CL、DH和DL等；<br>
16位寄存器：AX、BX、CX、DX、SI、DI、SP、BP和段寄存器等。</p>
<ul>
<li>注意：<br>
如果指令中的源操作数和目的操作数都是寄存器寻址时，寄存器的类型要匹配。</li>
</ul>
<h3 id="寄存器间接寻址方式">寄存器间接寻址方式</h3>
<p>操作数存放在存储器中，操作数的有效地址EA存放在某个寄存器中。</p>
<p>（1）16位寻址：EA= (SI)、(DI)、 (BX)、(BP)<br>
前三个默认情况下，操作数在数据段，物理地址=（DS）×10H+（BX、SI、DI）；后面一个默认情况下，操作数在堆栈中，物理地址=（SS）×10H+（BP）。<br>
例如：<br>
MOV AX，[BX]        ； AX     ((DS)*10H+(BX))<br>
MOV AX，[BP]         ； AX     ((SS)*10H+(BP))<br>
MOV AX，ES：[BX]； AX     ((ES)*10H+(BX))<br>
MOV AX，DS：[BP]； AX     ((DS)*10H+(BP))<br>
（2）32位寻址：EA= (EAX)、(EBX)、 (ECX)、(EDX)、(ESP)、(EBP) 、(ESI)、(EDI)<br>
ESP、EBP默认操作数存放在堆栈段，其它默认操作数存放在数据段。<br>
举例：<br>
MOV  AL,[BX]   ；将数据段（DS）×10H+（BX）中８位数据传送到AL<br>
MOV  AX,[BP]　；将堆栈段（SS）×10H+（BP）中１６位数据传送到AX<br>
MOV  CH,ES:[BX]　；将附加段（ES）×10H+（BX）中８位数据传送到AX<br>
MOV  [SI],1234H　；将立即数1234H传送到数据段（DS）×10H+（SI）<br>
MOV  ES:[DI],78H ；将立即数78H传送到附加段（ES）×10H+（DI）</p>
<p>在寄存器间接寻址中，用基址寄存器BX和BP间接寻址的，又称为基址寻址。<br>
用变址寄存器SI和DI间接寻址的称为变址寻址。</p>
<ul>
<li>注意：<br>
寄存器间接寻址和寄存器寻址的区别是，前者寄存器中存放的是操作数的有效地址，后者寄存器中存放的是操作数。<br>
寄存器间接寻址既可以用于源操作数，也可以用于目的操作数，但不可以在一条指令中同时使用。</li>
</ul>
<h3 id="寄存器相对寻址方式">寄存器相对寻址方式</h3>
<p>寄存器的内容与位移量之和形成操作数的有效地址。<br>
即： EA=(寄存器)+位移量。位移量是一个带符号的数，可以是8位、16位或32位。</p>
<p>(1) 16位寻址：EA={(BX)、(BP)、(SI)、(DI)}+位移量(带符号8或16位整数)，BX默认段寄存器DS，BP默认段寄存器SS。<br>
8位位移量范围：-128~+127<br>
16位位移量范围：-32768~+32767<br>
举例：<br>
MOV  AL,[BX+10H] ；源操作数在数据段， EA=（BX）+10H<br>
MOV  AX,[BP+30H] ；源操作数在堆栈段， EA=（BP）+30H<br>
MOV  [DI+34H],1234H  ；目的操作数在数据段， EA=（DI）+34H<br>
MOV  ES:[DI+20H],78H  ; 目的操作数在附加段， EA=（DI）+20H<br>
(2) 32位寻址：EA=(8个32位通用寄存器)+位移量(带符号8、16或32位整数)</p>
<ul>
<li>注意：指令格式中的位移量既可以是常数，也可以是符号地址；允许和寄存器一起写在方括号内（“+”不能省略），也允许单独卸载方括号外（“+”可省略）。</li>
</ul>
<p>例：MOV  AX,[SI+10H]    =      MOV  AX,10H [SI]<br>
MOV  BX,[DI+COUNT]     =     MOV  BX,COUNT [DI]<br>
MOV AX，2040H[BX]  =    MOV AX，[BX+2040H]；DS段(DS)*10H+(BX)+2040H中的字数据送AX<br>
MOV AX，2040H[SI]   =   MOV AX，[SI+2040H]；DS段(DS)*10H+(SI)+2040H中的字数据送AX</p>
<p>对一维数组的操作寻址非常方便</p>
<h3 id="基址加变址寻址方式">基址加变址寻址方式</h3>
<p>EA=(基址寄存器)+(变址寄存器) ，由基址寄存器来决定默认的段寄存器（段基址寄存器）</p>
<p>举例：<br>
MOV  AL,[BX+SI] ;将数据段（DS）×10H+（BX）＋（SI）中的数据传送到AL<br>
MOV  AX,[BP+DI] ;将堆栈段（SS）×10H+（BP）＋（DI）中的数据传送到AX<br>
MOV  CH,ES:[BX+SI] ;将附加段（ES）×10H+（BX）＋（SI）中的数据传送到CH<br>
MOV  [BX+DI],34H ;将立即数34H传送到数据段（DS）×10H+（BX）＋（DI）</p>
<p>对于二维数组的操作处理很方便</p>
<h3 id="带位移的基址加变址寻址方式">带位移的基址加变址寻址方式</h3>
<p>EA=(变址寄存器)+(基址寄存器)+偏移量</p>
<h3 id="比例变址寻址">比例变址寻址</h3>
<p>EA=（变址寄存器）×比例因子，比例因子可取2、4或8<br>
例如：MOV EAX, [ESI*4]</p>
<h3 id="带位移的比例变址寻址">带位移的比例变址寻址</h3>
<p>EA=(变址寄存器) ×比例因子+位移量<br>
例如：<br>
MOV  EAX，1200H[ESI<em>4]<br>
MOV  EAX, TABLE[ESI</em>4]</p>
<h3 id="基址加比例变址寻址32位寻址">基址加比例变址寻址（32位寻址）</h3>
<p>EA= (基址寄存器) +(变址寄存器)<em>比例因子<br>
如：MOV  AX，[ESI+EBX</em>4]（默认段DS）</p>
<h3 id="带位移的基址加比例变址寻址">带位移的基址加比例变址寻址</h3>
<p>EA =(基址寄存器)+(变址寄存器)<em>比例因子+位移量<br>
如：MOV AX，[EBX+EDI</em>8+40H]<br>
MOV ECX，2000H[EDX*4][EAX]</p>
<ul>
<li>比例变址寻址、带位移的比例变址寻址、基址加比例变址寻址、带位移的基址加比例变址寻址只适用于32位寻址方式。</li>
</ul>
<h3 id="寄存器间接寻址的默认段">寄存器间接寻址的默认段</h3>
<table>
<thead>
<tr>
<th style="text-align:center">段寄存器</th>
<th style="text-align:center">16位寄存器</th>
<th style="text-align:center">32位寄存器</th>
<th style="text-align:center">寄存器寻址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CS</td>
<td style="text-align:center">IP</td>
<td style="text-align:center">EIP</td>
<td style="text-align:center">代码段</td>
</tr>
<tr>
<td style="text-align:center">SS</td>
<td style="text-align:center">SP或BP</td>
<td style="text-align:center">ESP或EBP</td>
<td style="text-align:center">堆栈段</td>
</tr>
<tr>
<td style="text-align:center">DS</td>
<td style="text-align:center">BX、DI、SI</td>
<td style="text-align:center">EAX、EBX、ECX、EDX、EDI、ESI</td>
<td style="text-align:center">数据段</td>
</tr>
<tr>
<td style="text-align:center">ES</td>
<td style="text-align:center">串指令的DI</td>
<td style="text-align:center">串指令的EDI</td>
<td style="text-align:center">附加段</td>
</tr>
<tr>
<td style="text-align:center">FS</td>
<td style="text-align:center">无默认值</td>
<td style="text-align:center">无默认值</td>
<td style="text-align:center">附加段</td>
</tr>
<tr>
<td style="text-align:center">GS</td>
<td style="text-align:center">无默认值</td>
<td style="text-align:center">无默认值</td>
<td style="text-align:center">附加段</td>
</tr>
</tbody>
</table>
<h2 id="指令系统">指令系统</h2>
<p>8086的指令系统分为整数指令、浮点数指令和操作系统指令。</p>
<ul>
<li>整数指令：数据传送类、算术运算类、逻辑运算类、串操作类、控制转移类、处理器控制类指令等。</li>
<li>浮点数指令：数据传送、算术运算、比较、超越函数、常量、控制等指令。</li>
</ul>
<h3 id="指令操作数符号说明">指令操作数符号说明：</h3>
<p>ac: 累加器(AL, AX)<br>
reg  ：通用寄存器。长度可以是8位、16位<br>
reg8、reg16：8位、16位通用寄存器<br>
seg  ：段寄存器<br>
mem   ：存储器。长度可以是8位、16位<br>
mem8、mem16 ：8位、16位存储器<br>
imm   ：立即数。长度可以是8位、16位<br>
imm8、imm16：8位、16位<br>
Port: I/O端口<br>
src：源操作数<br>
dst：目标操作数<br>
OP1，OP2，OP3：操作数<br>
exp: 表达式</p>
<h3 id="与运算有关的标志">与运算有关的标志</h3>
<p>标志寄存器FR中存放运算结果的属性。<br>
CF：进位/借位标志。加、减运算最高位产生进位/借位时置1。<br>
AF：辅助进位/借位标志。加、减运算时低半字节位产生进位<br>
/借位时置1。<br>
OF：溢出标志。有符号数二进制加、减运算结果超出范围时<br>
置1。<br>
ZF：零标志。结果为零时置1。<br>
SF：符号标志。结果为负时置1。<br>
PF：奇偶标志。结果“1”的个数为偶数时置1。</p>
<h3 id="指令执行对标志位影响的符号说明">指令执行对标志位影响的符号说明：</h3>
<p>x ：表示相应标志位状态依运算或操作结果决定<br>
0 : 表示相应标志位无条件清“0”<br>
1 ：表示相应标志位无条件置“1”<br>
u : 表示相应标志位状态未定义,状态随机</p>
<ul>
<li>: 表示相应标志位状态不受影响,保持原状态<br>
r ： 恢复原来保存的值 （如执行POPF）</li>
</ul>
<h3 id="数据传送指令">数据传送指令</h3>
<p>数据传送指令负责把数据、地址或立即数传送到寄存器、存储器或端口号寄存器。它相对于高级语言里的赋值语句。<br>
通用数据传送：MOV    PUSH     POP    XCHG<br>
累加器专用传送（输入输出）：  IN    OUT    XLAT<br>
地址传送：  LEA   LDS    LES<br>
标志寄存器传送：  LAHF    SAHF      PUSHF     POPF<br>
类型转换指令：CBW   CWD</p>
<ul>
<li>这类指令一般不影响标志位</li>
</ul>
<h3 id="通用数据传送指令">通用数据传送指令</h3>
<h4 id="mov传送指令">MOV传送指令</h4>
<p>格式： MOV    Seg/Reg/Mem， Seg/Reg/Mem/Imm<br>
其中：Seg—（段寄存器），Reg—Register（通用寄存器），Mem—Memory（存储器），Imm—Immediate（立即数），它们可以是8位、16位。<br>
功能：指令的功能是把源操作数（第二操作数）的值传给目的操作数（第一操作数）。指令执行后，目的操作数的值被改变，而源操作数的值不变。在存储单元是该指令的一个操作数时，该操作数的寻址方式可以是任意一种存储单元寻址方式。</p>
<ul>
<li>注意：对MOV指令有以下几条具体规定，其中有些规定对其它指令也同样有效。<br>
1）两个操作数的数据类型要相同，要同为8位、16位<br>
2）两个操作数不能同时为段寄存器<br>
3）代码段寄存器CS不能为目的操作数，但可作为源操作数<br>
4）立即数不能直接传给段寄存器<br>
5）立即数不能作为目的操作数<br>
6）指令指针IP，不能作为MOV指令的操作数<br>
7）两个操作数不能同时为存储单元</li>
</ul>
<h4 id="xchg数据交换指令">XCHG数据交换指令</h4>
<p>指令的格式为：XCHG	reg/mem，reg/mem<br>
功能：将源操作数与目的操作数相交换。 （字节或字）<br>
说明：交换能在通用寄存器之间、通用寄存器与存储器之间进行。但段寄存器和立即数不能作为操作数。存储器之间不能直接进行数据交换。</p>
<h4 id="堆栈指令">堆栈指令</h4>
<p>堆栈是一个特殊的存储区域，用于存储在程序执行过程中需要保存的信息，如在子程序调用过程中的“断点”和“现场”等。<br>
堆栈采用的是“后进先出”向低地址方向生成的数据结构，即栈底为高地址方向，栈顶为低地址方向。由堆栈指针SP指示栈顶的数据，当堆栈为空时，SP指向栈底。堆栈以字、双字为单位存取数据（不允许字节数据）。<br>
它主要有两大类操作：进栈操作和出栈操作。</p>
<h5 id="入栈指令push">入栈指令PUSH</h5>
<p>指令格式：PUSH　Seg/Reg/Mem<br>
一个字进栈，系统自动完成两步操作：SP←SP-2，（SP）←操作数；<br>
功能：将寄存器、段寄存器或存储器中的一个字数据压入堆栈，堆栈指针减2。</p>
<h5 id="出栈指令pop">出栈指令POP</h5>
<p>指令格式：POP　Seg/Reg/Mem<br>
弹出一个字，系统自动完成两步操作： 操作数←（SP)，SP←SP+2；<br>
功能：将栈顶元素弹出送至某一寄存器、段寄存器（除CS外）或存储器，堆栈指针加2。</p>
<h4 id="其他堆栈操作指令">其他堆栈操作指令</h4>
<h5 id="所有寄存器进栈指令pusha">所有寄存器进栈指令PUSHA</h5>
<p>指令的格式为：PUSHA<br>
功能：16位通用寄存器依次进栈，次序为AX、CX、DX、BX，指令执行前的SP、BP、SI、DI。指令执行后(SP)-16→(SP)仍指向栈顶。</p>
<h5 id="所有寄存器出栈指令popa">所有寄存器出栈指令POPA</h5>
<p>指令的格式为：POPA<br>
功能：16位通用寄存器依次出栈，次序为DI、SI、BP、SP，指令执行前的BX、DX、CX、AX。指令执行后(SP)+16→(SP) 仍指向栈顶。需要说明的是：SP出栈只是修改了指针使其后的BX能够出栈，而堆栈中原先由PUSHA指令存入的SP的原始内容被丢弃，并未真正送到SP寄存器中。</p>
<ul>
<li>上述两条堆栈指令均不影响标志位</li>
</ul>
<h4 id="累加器专用传送指令">累加器专用传送指令</h4>
<h5 id="xlat-查表转换指令">XLAT   查表转换指令</h5>
<p>转换指令有两个隐含操作数BX和AL。<br>
格式：XLAT    OPR 或  XLAT<br>
执行操作： AL←（（BX）+（AL））<br>
功能：BX指向表的首地址(DS段内)，AL装入要转换的代码在表中的序号，并将XLAT指令执行的结果存于AL中。 （查表得到字节数据送入AL中。）</p>
<h4 id="io数据传送指令">I/O数据传送指令</h4>
<p>这组指令仅限于使用累加器AX或AL传送信息。</p>
<p>8086中，所有I/O端口与CPU之间的通信都由IN和OUT指令来完成。其中IN指令完成从I/O端口到CPU的数据传送（输入），OUT指令完成从CPU到I/O端口的数据传送（输出）。外部设备最多有216个I/O端口，端口号为0000～0FFFFH。其中前256个端口（00～0FFH）可以直接在指令中指定，这就是所谓的长格式。当端口号≥256时，只能使用短格式，此时必须先将端口号放到DX寄存器中（端口号为0000～0FFFFH），然后再用IN和OUT指令来传送信息。<br>
（注意：这里的端口号或DX的内容均为地址，而传送的是端口中的信息，在使用短格式时，DX内容就是端口号本身）。</p>
<h5 id="输入指令in将端口的数据送入cpu累加器">输入指令IN（将端口的数据送入CPU累加器）</h5>
<p>输入指令用来从指定的外设寄存器取信息送入累加器。它有几种形式：</p>
<p>长格式：         IN   AL, PORT （字节）<br>
（00H~FFH）      IN   AX, PORT  （字）<br>
执行操作：（AL）← （PORT）                  （字节）<br>
（AX） ←（PORT+1,  PORT）（字）</p>
<p>短格式：      IN   AL, DX   （字节）<br>
（大于00FFH）  IN   AX, DX   （字）<br>
执行操作：（AL）←（（DX））               （字节）<br>
（AX）←（（DX）+1,（DX））（字）</p>
<ul>
<li>注意：该指令的作用是从端口中读入一个字节或字，并保存在寄存器AL或AX中。如果某输入设备的端口地址在0 ~ 255（00H ~ FFH）范围之内，那么，可在指令IN中直接给出，否则，要把该端口地址先存入寄存器DX中，然后在指令中由DX来给出其端口地址。</li>
</ul>
<p>例如：<br>
IN   AL， 60H  ；从端口60H读入一个字节到AL中<br>
IN   AX，20H  ；把端口20H、21H按“高高低低”组成的字读入AX<br>
MOV   DX，2F8H<br>
IN    AL，DX ；从端口2F8H读入一个字节到AL中<br>
IN    AX，DX；把端口2F8H、2F9H按“高高低低”组成的字读入AX<br>
IN  AL，0FAH   ；从端口0FAH读一个字节到AL<br>
MOV DX，3AEH；  I/O地址大于255时．应通过DX间接寻址，不允许加放括号<br>
IN  AX，DX   ；从DX指定的端口读入一个字到AX</p>
<h5 id="out输出指令将cpu累加器中数据写入端口">OUT输出指令（将CPU累加器中数据写入端口）</h5>
<p>输出指令用来把累加器的内容送往指定的外设存储器，它有几种形式：</p>
<p>长格式：       OUT   PORT, AL  （字节）<br>
（00H~FFH）    OUT   PORT, AX  （字）<br>
执行操作：（PORT）←（AL）                 （字节）<br>
（PORT+1, PORT）←（AX）（字）</p>
<p>短格式：        OUT   DX, AL  （字节）<br>
（大于00FFH）    OUT   DX, AX  （字）<br>
执行操作：（（DX））←（AL）               （字节）<br>
（（DX）+1,（DX））←（AX）（字）</p>
<ul>
<li>注意：该指令的作用是把寄存器AL或AX的内容输出到指定端口。如果某输出设备的端口地址在0~255范围之内，那么，可在指令OUT中直接给出，否则，要把该端口地址先存入寄存器DX中，然后在指令中由DX来给出其端口地址。</li>
</ul>
<p>例如：<br>
OUT   61H，AL；把AL的内容输出到端口61H中<br>
OUT   20H，AX；把AX的内容输出到端口20H、21H中<br>
MOV  DX， 3C0H<br>
OUT   DX，AL；把AL的内容输出到端口3C0H中<br>
OUT   DX，AX；把AX的内容输出到端口3C0H、3C1H中</p>
<h4 id="地址传送指令">地址传送指令</h4>
<p>这一组指令完成将地址送到指定的寄存器的功能。</p>
<h5 id="有效地址送寄存器指令lea-load-effective-address">有效地址送寄存器指令LEA (Load Effective Address)</h5>
<p>指令的格式为：LEA	dst，src<br>
功能：将源操作数的有效地址送到指定的寄存器中。<br>
说明：①源操作数必须是一个内存操作数；②目的操作数必须是一个16位的通用寄存器。这条指令通常用来建立串操作指令所须的寄存器指针。</p>
<h5 id="指针送寄存器及相应段寄存器指令lds和les">指针送寄存器及相应段寄存器指令LDS和LES</h5>
<h6 id="lds-load-pointer-into-ds">LDS (Load pointer into DS)</h6>
<p>指令的格式为： LDS  REG，OPS<br>
功能：完成一个地址指针的传送。地址指针包括段地址部分和偏移量部分。指令将段地址（EA+2）送入DS，偏移量部分(EA)送入一个16位的基址寄存器或变址寄存器。<br>
要求：源操作数必须是存储器寻址，目的操作数是16位通用寄存器。<br>
例如：LDS  SI，[BX] ；将把BX所指的32位地址指针的段地址部分送入DS，偏移量部分送入SI。<br>
本组指令的目的寄存器不允许使用段寄存器，且不影响标志位。</p>
<h6 id="les-load-pointer-into-es">LES (Load pointer into ES)</h6>
<p>指令的格式为： LES  REG，OPS<br>
这条指令除将地址指针的段地址部分送入ES外，与LDS类似。<br>
例如： LES  DI，[BX+COUNT]</p>
<h4 id="标志寄存器传送指令">标志寄存器传送指令</h4>
<h5 id="标志送ah指令-lahf">标志送AH指令： LAHF</h5>
<p>执行操作：（AH）←（FLAGS的低八位，只送状态位进入对应位置，其余位空着）</p>
<h5 id="ah送标志寄存器指令sahf">AH送标志寄存器指令：SAHF</h5>
<p>执行操作：   （FLAGS的低八位）←（AH）</p>
<h5 id="标志进栈指令pushf">标志进栈指令：PUSHF</h5>
<p>执行操作： （SP）←（SP） - 2<br>
（（SP）+1,  （SP））←（FLAGS）</p>
<h5 id="标志出栈指令popf">标志出栈指令：POPF</h5>
<p>执行操作： （FLAGS）←（（SP）+1,（SP））<br>
（SP）←（SP）+ 2</p>
<h3 id="算术运算指令">算术运算指令</h3>
<p>算术运算指令是反映CPU计算能力的一组指令，也是编程时常使用的一组指令。它包括：加、减、乘、除及其相关的辅助指令。</p>
<p>该组指令的操作数可以是8位、16位,也可以是压缩、非压缩BCD码。算术运算指令一般会影响FR 寄存器中的状态标志位。</p>
<p>加法指令      ADD、ADC、INC<br>
减法指令      SUB、SBB、DEC、NEG、CMP<br>
乘法指令      MUL、IMUL<br>
除法指令      DIV、IDIV<br>
十进制调整指令      DAA、DAS、 AAA、AAS、AAM、AAD</p>
<h4 id="加法指令">加法指令</h4>
<h5 id="不带进位的加法指令-add-dstsrc">不带进位的加法指令：    ADD  DST，SRC</h5>
<p>功能：将目的操作数与源操作数相加，结果存入目的地址中，源地址的内容不改变。<br>
执行操作：（DST）← （SRC）+（DST）</p>
<h5 id="带进位加法指令-adc-dstsrc">带进位加法指令：  ADC  DST，SRC</h5>
<p>功能：将目的操作数加源操作数再加低位进位，结果送目的地址。执行操作：（DST） （SRC）+（DST）+ CF</p>
<h5 id="加1指令-inc-dst">加1指令：        INC  DST</h5>
<p>功能：将目的操作数加1，结果送目的地址。<br>
执行操作：  （DST）← （DST）+ 1<br>
注意:  除INC指令不影响CF标志外，均对条件(状态)标志位有影响。<br>
INC常用于: 寄存器或存储器单元自增，修改计数器或地址, 比加法指令简便、效率高。</p>
<h4 id="减法指令">减法指令</h4>
<h5 id="减法指令-sub-dstsrc">减法指令： SUB  DST，SRC</h5>
<p>功能：目的操作数减去源操作数，结果存于目的地址，源地址的内容不变。<br>
执行操作：  （DST）←（DST）- （SRC）</p>
<h5 id="带借位减法指令-sbb-dstsrc">带借位减法指令： SBB  DST，SRC</h5>
<p>功能：目的操作数减源操作数再减低位借位CF，结果送目的地址<br>
执行操作：  （DST）←（DST） - （SRC）- CF</p>
<h5 id="减1指令-dec-opr">减1指令： DEC  OPR</h5>
<p>功能：将目的操作数减1，结果送目的地址。<br>
执行操作：   （OPR） ← （OPR） - 1</p>
<h5 id="求补指令-neg-opr">求补指令： NEG  OPR</h5>
<p>功能：将目的操作数的每一位求反（包括符号位）后加1，结果送目的地址。<br>
（正变负，用补码表示；负变正，用源码表示。）<br>
执行操作：（OPR） ←  - （OPR）<br>
NEG指令的功能:改变操作数的符号可用于取操作数的绝对</p>
<h5 id="比较指令-cmp-opr1-opr2">比较指令： CMP  OPR1, OPR2</h5>
<p>功能：目的操作数减源操作数，结果只影响标志位，不送入目的地址。比较指令执行后，源操作数和目的操作数都保持不变，程序通过测试CMP指令执行后形成的标志位来判断两数的大小。<br>
执行操作：（OPR1） - （OPR2）</p>
<p>注意:  除DEC指令不影响 CF标志外，均对状态标志位有影响。</p>
<table border=0 cellpadding=0 cellspacing=0 width=448 style='border-collapse:
 collapse;table-layout:fixed;width:336pt'>
 <col width=64 span=7 style='width:48pt'>
 <tr height=18 style='height:13.8pt'>
  <td colspan=3 height=18 class=xl6329631 width=192 style='height:13.8pt;
  width:144pt'>标志位</td>
  <td class=xl6329631 width=64 style='border-left:none;width:48pt'>CF</td>
  <td class=xl6329631 width=64 style='border-left:none;width:48pt'>ZF</td>
  <td class=xl6329631 width=64 style='border-left:none;width:48pt'>SF</td>
  <td class=xl6329631 width=64 style='border-left:none;width:48pt'>OF</td>
 </tr>
 <tr height=18 style='height:13.8pt'>
  <td colspan=3 height=18 class=xl6329631 style='height:13.8pt'>A = B</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>1</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
 </tr>
 <tr height=18 style='height:13.8pt'>
  <td colspan=2 rowspan=2 height=36 class=xl6329631 style='height:27.6pt'>无符号数</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>A&gt;B</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>-</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>-</td>
 </tr>
 <tr height=18 style='height:13.8pt'>
  <td height=18 class=xl6329631 style='height:13.8pt;border-top:none;
  border-left:none'>A&lt;B</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>1</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>-</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>-</td>
 </tr>
 <tr height=18 style='height:13.8pt'>
  <td rowspan=6 height=108 class=xl6329631 style='height:82.8pt;border-top:
  none'>有符号数</td>
  <td rowspan=2 class=xl6329631 style='border-top:none'>A、B同号</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>A&gt;B</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>-</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
 </tr>
 <tr height=18 style='height:13.8pt'>
  <td height=18 class=xl6329631 style='height:13.8pt;border-top:none;
  border-left:none'>A&lt;B</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>-</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>1</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
 </tr>
 <tr height=18 style='height:13.8pt'>
  <td rowspan=4 height=72 class=xl6329631 style='height:55.2pt;border-top:none'>A、B异号</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>A&gt;B</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>-</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
 </tr>
 <tr height=18 style='height:13.8pt'>
  <td height=18 class=xl6329631 style='height:13.8pt;border-top:none;
  border-left:none'>A&lt;B</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>-</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>1</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
 </tr>
 <tr height=18 style='height:13.8pt'>
  <td height=18 class=xl6329631 style='height:13.8pt;border-top:none;
  border-left:none'>A&gt;B</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>-</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>1</td>
 </tr>
 <tr height=18 style='height:13.8pt'>
  <td height=18 class=xl6329631 style='height:13.8pt;border-top:none;
  border-left:none'>A&lt;B</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>-</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>0</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>1</td>
  <td class=xl6329631 style='border-top:none;border-left:none'>1</td>
 </tr>
 <![if supportMisalignedColumns]>
 <tr height=0 style='display:none'>
  <td width=64 style='width:48pt'></td>
  <td width=64 style='width:48pt'></td>
  <td width=64 style='width:48pt'></td>
  <td width=64 style='width:48pt'></td>
  <td width=64 style='width:48pt'></td>
  <td width=64 style='width:48pt'></td>
  <td width=64 style='width:48pt'></td>
 </tr>
 <![endif]>
</table>
<p>说明：<br>
（1）无论A和B是有符号数还是无符号数，若ZF=1且CF=SF=OF=0.则A=B。<br>
（2）A、B为无符号数，判断他们的大小，使用CF和ZF。若CF=0且ZF=0，则A&gt;B；若CF=1且ZF=0，则A&lt;B。<br>
（3）A、B为有符号数，判断他们的大小，使用SF、OF和ZF。当A、B同号或异号时，SF和OF形成的标志位有区别，若ZF=0且OF⊕SF=1，则A&lt;B；若ZF=0且OF⊕SF=0，则A&gt;B。</p>
<h4 id="乘法指令">乘法指令</h4>
<p>乘法指令影响OF和CF标志：<br>
MUL指令——若乘积的高一半（AH或DX）为0，则OF=CF=0；否则OF=CF=1。（用来检查字节相乘的结果是字节还是字，或字相乘的结果是字还是双字）<br>
IMUL指令——若乘积的高一半是低一半的符号扩展，则OF=CF=0；否则均为1。</p>
<p>乘法指令对其他状态标志没有定义：<br>
指令执行后这些标志是任意的、不可预测（就是谁也不知道是0还是1）。<br>
对标志没有影响是指令的执行不改变标志的状态。<br>
注意:乘法指令中的源操作数可以是除立即数以外的任何一种寻址方式.</p>
<h5 id="无符号数乘法指令-mul-src">无符号数乘法指令：        MUL   SRC</h5>
<p>功能： 若是字节数据相乘，（AL）与SRC相乘得到字数据存入AX中；若是字数据相乘，则（AX）与SRC相乘得到双字数据，高字存入DX、低字存入AX中。</p>
<p>执行操作：字节操作数  （AX）←（AL） ×（SRC）<br>
字操作数      （DX，AX）←（AX） × （SRC）</p>
<h5 id="有符号数乘法指令-imul-src">有符号数乘法指令：        IMUL  SRC</h5>
<p>注：IMUL指令除计算对象是带符号二进制数外，其他都与MUL一样，但计算结果不同。</p>
<h4 id="除法指令">除法指令</h4>
<p>当被除数远大于除数时，所得的商就有可能超出它所能表达的范围。如果存放商的寄存器AL/AX不能表达，便产生溢出，8086CPU中就产生编号为0的内部中断——除法错中断。</p>
<p>说明：<br>
1）对DIV指令，除数为0，或者在字节除时商超过8位，或者在字除时商超过16位，则发生除法溢出。<br>
2）对IDIV指令，除数为0，或者在字节除时商不在-128～127范围内，或者在字除时商不在-32768～32767范围内，则发生除法溢出。</p>
<h5 id="无符号数除法指令-div-src">无符号数除法指令：   DIV  SRC</h5>
<h5 id="带符号数除法指令-idiv-src">带符号数除法指令：   IDIV  SRC</h5>
<p>执行操作：<br>
字节操作  （AL）←（AX）/（SRC）的商<br>
（AH）←（AX）/（SRC） 的余数</p>
<p>字操作      （AX）←（DX：AX）/（SRC）的商<br>
（DX） ←（DX：AX）/（SRC） 的余数</p>
<p>注意：除法指令DIV和IDIV虽然对标志的影响未定义，但可产生溢出。</p>
<p>例：<br>
无符号除法：<br>
MOV AX，0400H      ；AX=400H=1024<br>
MOV BL，0B4H         ；BL=B4H=180<br>
DIV BL                          ；商AL＝05H＝5；余数AH＝7CH＝124</p>
<p>有符号除法：<br>
MOV AX，0400H      ；AX=400H=1024<br>
MOV BL，0B4H         ；BL=B4H=－76<br>
IDIV BL                         ；商AL＝F3H＝－13；余数AH＝24H＝36</p>
<p>注：带符号除法的余数符号和被除数符号相同。</p>
<h4 id="类型转换指令指令">类型转换指令指令</h4>
<h5 id="字节扩展为字指令-cbw-al-ax">字节扩展为字指令  CBW          AL ← AX</h5>
<p>执行操作： 若（AL）的最高有效位为0，则（AH)= 00H<br>
若（AL）的最高有效位为1，则（AH)= FFH</p>
<h5 id="字扩展成双字指令cwd-ax-dxax">字扩展成双字指令CWD         AX ← （DX,AX）</h5>
<p>执行操作：若（AX）的最高有效位为0，则（DX)= 0000H<br>
若（AX）的最高有效位为1，则（DX)= FFFFH</p>
<h4 id="十进制调整指令">十进制调整指令</h4>
<p>BCD码（8421码）：用二进制编码的十进制数，又称二--十进制数</p>
<p>压缩的BCD码（组合型）：用 4 位二进制数表示 1 位十进制数<br>
例： （59）<sub>10</sub> ＝（0101 1001）<sub>BCD</p>
<p>非压缩的BCD码（非组合型）：用 8 位二进制数表示 1 位十进制数<br>
例：（ 59 ）<sub>10</sub> ＝ （0000 0101   0000 1001 ）<sub>BCD</p>
<h5 id="压缩的bcd码调整指令">压缩的BCD码调整指令</h5>
<p>DAA      加法的十进制调整指令<br>
（将AL中的和调整为压缩BCD数）<br>
DAS      减法的十进制调整指令<br>
（将AL中的差调整为压缩BCD数）</p>
<h5 id="非压缩的bcd码调整指令">非压缩的BCD码调整指令</h5>
<p>AAA      加法的ASCII码调整指令<br>
（将AL中的和调整为非压缩BCD数）<br>
AAS      减法的ASCII码调整指令<br>
(将AL中的差调整为非压缩BCD数)<br>
AAM      乘法的ASCII码调整指令<br>
(将AL中的积调整为非压缩BCD)<br>
AAD      除法的ASCII码调整指令<br>
(调整AX中的被除数,相除的商即为非压缩BCD数)</p>
<h4 id="进位标志cfcarry-flag">进位标志CF（Carry Flag）</h4>
<p>当运算结果的最高有效位有进位（加法）或借位（减法）时，进位标志置1，即CF = 1；否则CF = 0。</p>
<p>例如：<br>
3AH + 7CH＝B6H，没有进位：CF = 0<br>
AAH + 7CH＝（1）26H，有进位：CF = 1</p>
<h4 id="零标志zfzero-flag">零标志ZF（Zero Flag）</h4>
<p>若运算结果为0，则ZF = 1，否则ZF = 0。<br>
例如：<br>
3AH + 7CH＝B6H，结果不是零：ZF = 0<br>
86H + 7CH＝（1）00H，结果是零：ZF = 1<br>
注意：ZF为1表示的结果是0。</p>
<h4 id="符号标志sfsign-flag">符号标志SF（Sign Flag）</h4>
<p>运算结果最高位为1，则SF = 1；否则SF = 0。<br>
例如：<br>
3AH + 7CH＝B6H，最高位D7＝1：SF = 1<br>
86H + 7CH＝（1）00H，最高位D7＝0：SF = 0</p>
<p>注意：有符号数据利用最高有效位表示数据的符号。所以，最高有效位就是符号标志的状态。</p>
<h4 id="奇偶标志pfparity-flag">奇偶标志PF（Parity Flag）</h4>
<p>当运算结果最低字节中“1”的个数为零或偶数时，PF = 1；否则PF = 0。<br>
例如：<br>
3AH + 7CH＝B6H＝10110110B，<br>
结果中有5个1，是奇数：PF = 0</p>
<p>注意：PF标志仅反映最低8位中“1”的个数是偶或奇，即使是进行16位字操作。</p>
<h4 id="辅助进位标志afauxiliary-carry-flag">辅助进位标志AF（Auxiliary Carry Flag）</h4>
<p>运算时D3位（低半字节）有进位或借位时，AF = 1；否则AF = 0。</p>
<p>例如：<br>
3AH + 7CH＝B6H，D3有进位：AF = 1</p>
<p>注意：这个标志主要由处理器内部使用，用于十进制算术运算指令中，用户一般不必关心。</p>
<h4 id="溢出标志ofoverflow-flag">溢出标志OF（Overflow Flag）</h4>
<p>若算术运算的结果有溢出，则OF=1；否则 OF＝0。<br>
例如：<br>
3AH + 7CH＝B6H，产生溢出：OF = 1<br>
AAH + 7CH＝（1）26H，没有溢出：OF = 0</p>
<h3 id="逻辑指令">逻辑指令</h3>
<p>逻辑指令包括逻辑运算指令和移位操作指令两大类。<br>
其中逻辑运算指令是一组重要的指令，它包括：逻辑与（AND）、逻辑或（OR）、逻辑非（NOT）和异或指令（XOR），逻辑运算指令也是经常使用的指令。<br>
移位操作指令是另一组经常使用的指令，它包括算术移位、逻辑移位、双精度移位、循环移位和带进位的循环移位等五大类。</p>
<h4 id="逻辑运算指令">逻辑运算指令</h4>
<p>AND(and)				逻辑与<br>
OR(or)				逻辑或<br>
NOT(not)				逻辑非<br>
XOR(exclusive or)	                        异或<br>
TEST(test)			            测试</p>
<p>除NOT外，都影响某些标志位(OF、CF、PF、SF、ZF)，对AF无影响或随机。</p>
<h5 id="逻辑与指令and-dstregmem-srcregmemimm">逻辑与指令：AND  DST（reg/mem）, SRC（reg/mem/imm）</h5>
<p>功 能：把源操作数中的每位二进制与目的操作数中的相应二进制进行逻辑“与操作”，操作结果存入目标操作数中。<br>
执行操作：   （DST）←（DST）与（SRC）<br>
用途：该指令用于清除目的操作数中与源操作数置0的对应位。（想让哪位为0，哪位与0作与运算）</p>
<h5 id="逻辑或指令or-dstregmem-srcregmemimm">逻辑或指令：OR  DST（reg/mem）, SRC（reg/mem/imm）</h5>
<p>功 能：把源操作数中的每位二进制与目的操作数中的相应二进制进行逻辑&quot;或操作&quot;，操作结果存入目标操作数中。<br>
执行操作：   （DST）←（DST）或（SRC）<br>
用途：该指令用于设置目的操作数中与源操作数置1的对应位。（想让哪位为1，哪位与1作或运算。）</p>
<h5 id="异或指令-xor-dstregmem-srcregmemimm">异或指令：    XOR  DST（reg/mem）, SRC（reg/mem/imm）</h5>
<p>功能：把源操作数中的每位二进制与目的操作数中的相应二进制进行逻辑“异或操作”，操作结果存入目标操作数中。<br>
执行操作：    （DST）← （DST） 异或 （SRC）<br>
用途：该指令用于将目的操作数中与源操作数置1的对应位取反。（想让哪位取反，哪位与1作异或运算。）</p>
<h5 id="逻辑非指令-not-opr-regmem">逻辑非指令： NOT  OPR （reg/mem）</h5>
<p>功能：将目的地址中的内容逐位取反后送入目的地址。<br>
执行操作：    （OPR）←   非（OPR）</p>
<h5 id="测试指令-test-opr1regopr2regmemimm">测试指令：    TEST  OPR1（reg），OPR2(reg/mem/imm)</h5>
<p>功能：把二个操作数进行逻辑“与”操作，并根据运算结果设置相应的标志位，但并不保存该运算结果，所以，不会改变指令中的操作数。<br>
执行操作： （OPR1） 与 （OPR2）</p>
<h4 id="移位指令">移位指令</h4>
<p>移位指令包括算术移位指令、逻辑移位指令和循环移位指令，分别进行左移和右移操作。这些指令均有统一的语句格式：<br>
操作符   OPR，1<br>
或    操作符   OPR，CL<br>
其功能为将目的操作数的所有位按操作符规定的方式移动1位或按寄存器CL规定的次数（0~255）移动，结果送入目的地址。目的操作数是8位（或16位）的寄存器数据或存储器数据。</p>
<h5 id="移位指令-2">移位指令</h5>
<p>①逻辑左移SHL（Shift Logical Left）<br>
②逻辑右移SHR（Shift Logical Right）<br>
它们的指令格式如下：<br>
SHL/SHR　OPR(reg/mem), CL/Imm8<br>
受影响的标志位：CF、OF、PF、SF和ZF（AF无定义）。<br>
逻辑左移/右移指令只有它们的移位方向不同，移位后空出的位都补0，移出位进入CF。看作无符号数进行移位。</p>
<p>逻辑移位指令常用于无符号数*2或/2</p>
<p>③ 算术左移指令SAL<br>
④ 算术右移指令SAR<br>
它们的指令格式如下：<br>
SAL/SAR　OPR(reg/mem), CL/Imm<br>
受影响的标志位：CF、OF、PF、SF和ZF（AF无定义）。<br>
功能：算术左移SAL把目的操作数的低位向高位移，空出的低位补0，最后移出位保存在CF中；算术右移SAR把目的操作数的高位向低位移，空出的高位补符号位，使数据性质不变，最后移出位保存在CF中。看作有符号数进行移位。</p>
<p>算术移位指令常用于带符号数*2或/2</p>
<h5 id="循环移位指令">循环移位指令</h5>
<p>① 循环左移指令ROL<br>
② 循环右移指令ROR<br>
ROL/ROR　OPR(reg/mem), CL/Imm<br>
循环左移/右移指令只是移位方向不同，不带CF的移位，但它们最后移出的位要进入CF，并且填补空出的位。</p>
<p>③ 带进位的循环左移指令RCL<br>
④ 带进位的循环右移指令RCR<br>
指令的格式：RCL/RCR　OPR(reg/mem), CL/Imm<br>
受影响的标志位：CF和OF<br>
带进位的循环左移／右移指令只有移位的方向不同，它们都用原CF的值填补空出的位，移出的位再进入CF。</p>
<h4 id="串操作指令">串操作指令</h4>
<p>存储器中的地址连续的若干单元的字符或数据称为字符串或数据串。<br>
串操作指令就是用来对串中每个字符或数据进行操作的指令。<br>
字符串操作指令的实质是对一片连续存储单元进行处理。<br>
串操作指令的操作数是主存中连续存放的数据串。（String）——即在连续的主存区域中，字节或字的序列。<br>
串操作指令的操作对象是以字（W）为单位的字串，或是以字节（B）为单位的字节串。每完成一个字节（或字）的操作后，能够自动修改指针，以便执行下一个字节（或字）的操作。<br>
串操作包括串传送（MOVSB/MOVSW）、串装入（LODSB/LODSW） 、串存储（STOSB/STOSW） 、串比较（CMPSB/CMPSW） 、串扫描（SCASB/SCAW）等。<br>
串指令可完成两个存储单元之间的传送和比较操作（也只有串指令才可以）。</p>
<p>源操作数用寄存器SI寻址，默认在数据段DS中，但允许段超越。DS:SI（寻址源串）<br>
目的操作数用寄存器DI寻址，默认在附加段ES中，不允许段超越。ES:DI （寻址目的串）<br>
每执行一次串操作指令，SI和DI将自动修改：<br>
±1（对于字节串）或±2（对于字串）<br>
执行指令CLD后，DF = 0，地址指针增1或2<br>
执行指令STD后，DF = 1，地址指针减1或2</p>
<h5 id="与-rep-配合工作的-movs-stos-lods的指令">与 REP 配合工作的 MOVS / STOS / LODS的指令</h5>
<p>REP MOVS：将数据段中的整串数据传送到附加段中。</p>
<p>源串（数据段）→ 目的串（附加段）<br>
执行 REP MOVS 之前，应先做好：<br>
1）   源串首地址（末地址）→ SI<br>
2）  目的串首地址（末地址）→ DI<br>
3）  串长度 → CX<br>
4）  建立方向标志<br>
（ CLD 使 DF=0，STD 使 DF=1 ）</p>
<h6 id="重复前缀指令rep">重复前缀指令REP</h6>
<p>重复前缀指令是重复其后的字符串操作指令，重复的次数由CX来决定。其一般格式为：<br>
REP　 MOVS / STOS / LODS<br>
重复前缀指令的执行步骤如下：<br>
1）判断：CX=0；<br>
2）如果CX=0，则结束重复操作，执行程序中的下一条指令；<br>
3）否则，CX=CX-1（不影响有关标志位），并执行其后的字符串操作指令，在该指令执行完后，再转到步骤1）。</p>
<h6 id="串传送指令move-string-instruction">串传送指令（Move String Instruction）</h6>
<p>指令的格式：<br>
MOVS  DST，SRC   （需在操作数中表明数据格式）<br>
MOVSB                  （字节）<br>
MOVSW                 （字）<br>
功能：将以SI为指针的源串中的一个字节（或字）存储单元中的数据传送至以DI为指针的目的地址中去，并自动修改指针，使之指向下一个字节（或字）存储单元。<br>
执行操作:<br>
①（DS：[SI]）→ES：[DI]<br>
② （SI)←(SI)±1，(DI)←(DI)±1      字节操作<br>
(SI)←(SI)±2，(DI)←(DI)±2     字  操  作</p>
<h6 id="串存储指令store-string-instruction">串存储指令（Store String Instruction）</h6>
<p>指令的格式：<br>
STOS  DST    （需在操作数中表明数据格式）<br>
STOSB          （字节）<br>
STOSW         （字）<br>
功能：将AL或AX中的数据送入ES：DI所指的目的串中的字节（或字）存储单元中。<br>
执行操作：<br>
字节操作：ES:[DI]←（AL），（DI）←（DI）±l<br>
字操作： ES:[DI] ←（AX），（DI）←（DI）±2</p>
<h6 id="串装入指令load-string-instruction">串装入指令（Load String Instruction）</h6>
<p>指令的格式：<br>
LODS  SRC （需在操作数中表明数据格式）<br>
LODSB          （字节）<br>
LODSW         （字）<br>
功能：将SI所指的源串中的一个字节（或字）存储单元中的数据取出来送入AL（或AX）中。<br>
执行操作：<br>
① 字节操作：（DS:[SI]）→AL，(SI) ±l → (SI)<br>
② 字操作：    （DS:[SI]）→AX，(SI) ±2 → (SI)</p>
<h6 id="串输入指令ins">串输入指令INS</h6>
<p>指令格式：<br>
INSB         ；字节串输入： ES:[DI] ←（（DX）），；DI←DI±1<br>
INSW          ；字串输入： ES:[DI] ← （（DX））， ；DI←DI±2</p>
<p>功能：将由DX寄存器指定的I/O端口中的字、字节传送到附加段中的目的串中，并根据DF和数据类型来改变目的变址寄存器的方向内容。</p>
<h6 id="串输出指令outs">串输出指令OUTS</h6>
<p>功能：将由源串中的字、字节传送到在DX寄存器指定的I/O端口中，并根据DF和数据类型来改变源变址寄存器的方向内容。</p>
<p>指令格式：<br>
OUTSB        ；字节串输出： （（DX））←DS：[SI] ；SI←SI±1<br>
OUTSW      ；字串串输出： （（DX））←DS：[SI] ；SI←SI±2</p>
<h5 id="与-repzrepnz配合工作的cmps-和-scas指令">与 REPZ（REPNZ）配合工作的CMPS 和 SCAS指令</h5>
<h6 id="相等重复前缀指令-reperepz">相等重复前缀指令 REPE/REPZ</h6>
<p>一般格式为：<br>
REPE/REPZ　CMPS/SCAS<br>
执行步骤如下：<br>
1）判断条件：CX≠0 且 ZF=1；<br>
2）如果条件不成立，则结束重复操作，执行程序中的下一条指令；<br>
3）否则，CX=CX-1（不影响有关标志位），并执行其后的字符串操作指令，在该指令执行完后，再转到步骤（1）。</p>
<h6 id="不等重复前缀指令-repnerepnz">不等重复前缀指令 REPNE/REPNZ</h6>
<p>一般格式为：<br>
REPNE/REPNZ　CMPS/SCAS</p>
<p>执行步骤如下：<br>
1）判断条件：CX≠0 且 ZF=0；<br>
2）如果条件不成立，则结束重复操作，执行程序中的下一条指令；<br>
3）否则，CX=CX-1（不影响有关标志位），并执行其后的字符串操作指令，在该指令执行完后，再转到步骤1）。</p>
<h6 id="串比较指令-cmps">串比较指令 CMPS</h6>
<p>语句格式：① CMPSB——字节串比较<br>
② CMPSW——字串比较<br>
功      能：将SI所指的源串中的一个字节（或字）存储单元中的数据与DI所指的目的串中的一个字节（或字）存储单元中的数据相减，并根据相减的结果设置标志，但结果并不保存。<br>
操作：①（DS:[SI]）－（ES:[DI]）。<br>
② 修改串指针，使之指向串中的下一个元素。<br>
当DF=0时，（SI）和（DI）增量。<br>
当DF=1时，（SI）和（DI）减量。</p>
<h6 id="串扫描指令-scas">串扫描指令 SCAS</h6>
<p>语句格式：① SCASB——字节串搜索<br>
② SCASW——字串搜索</p>
<p>功       能：AL（字节）或AX（字）中的内容与DI所指的目的串中的一个字节（或字）存储单元中的数据相减，根据相减结果设置标志位，结果不保存.<br>
操        作：<br>
① 字节操作：（AL）－（ES:[DI]），<br>
字操作：（AX）－（ES:[DI]）。<br>
② 修改指针使之指向串中的下一个元素。<br>
当DF=0时，（DI）增量。<br>
当DF=1时，（DI）减量。</p>
<h4 id="控制转移指令">控制转移指令</h4>
<p>转移指令是汇编语言程序员经常使用的一组指令。在高级语言中，时常有“尽量不要使用转移语句”的劝告，但如果在汇编语言的程序中也尽量不用转移语句，那么该程序要么无法编写，要么没有多少功能，所以，在汇编语言中，不但要使用转移指令，而且还要灵活运用，因为指令系统中有大量的转移指令。</p>
<p>转移指令分无条件转移指令和有条件转移指令两大类。<br>
无条件转移指令包括：JMP、子程序的调用和返回指令、中断的调用和返回指令等。<br>
条件转移指令又分三大类：基于无符号数的条件转移指令、基于有符号数的条件转移指令和基于特殊算术标志位的条件转移指令。</p>
<h5 id="jmp寻址方式">JMP寻址方式：</h5>
<p>段内转移：CS值不变，只给出地址偏移值（只改变IP）。<br>
短转移：在段内的短距离（-128~127）转移。<br>
近转移：转移的位移量为16位（-32768~32767）。</p>
<p>段间转移：CS和IP的值都发生改变的转移。</p>
<p>为明确表示标号或存储单元的类型，可在操作数前加SHORT、NEAR、FAR、WORD、DWORD、FWORD等修饰符来限定，默认近转移。</p>
<h5 id="无条件转移指令-jmp-op1regmem标号">无条件转移指令    JMP   OP1（reg/mem/标号）</h5>
<p>段内直接短转移：JMP    SHORT  OPR<br>
执行操作：（IP）← （IP）+ 8位位移量（带符号数）<br>
段内直接近转移：JMP    NEAR PTR  OPR<br>
执行操作：（IP）← （IP）+ 16位位移量（带符号数）<br>
段内间接转移：    JMP    WORD PTR  OPR<br>
执行操作：    （IP）← （EA）<br>
段间直接远转移：JMP    FAR PTR  OPR<br>
执行操作：（IP）← OPR 的段内偏移地址<br>
（CS）← OPR 所在段的段地址<br>
段间间接转移：     JMP    DWORD PTR  OPR<br>
执行操作：    （IP）← （EA）<br>
（CS）← （EA+2）</p>
<p>段内直接短转移：JMP    SHORT  OPR<br>
执行操作：（IP）← （IP）+ 8位位移量<br>
段内直接近转移：JMP    NEAR PTR  OPR<br>
执行操作：（IP）← （IP）+ 16位位移量<br>
位移量是紧接着JMP指令后的那条指令的偏移地址，到目标指令的偏移地址的地址位移。当向地址增大方向转移时，位移量为正；向地址减小方向转移时，位移量为负。</p>
<p>段内间接转移：    JMP    WORD PTR  OPR<br>
执行操作：    （IP）← （EA）<br>
将一个寄存器或主存字单元内容送入IP寄存器，作为新的指令指针，但不修改CS寄存器的内容。<br>
JMP    AX                            ；IP←AX<br>
JMP WORD PTR [2000H]；IP←[2000H]</p>
<p>段间直接远转移：JMP    FAR PTR  OPR<br>
执行操作：（IP）← OPR 的段内偏移地址<br>
（CS）← OPR 所在段的段地址<br>
将标号所在段的段地址作为新的CS值，标号在该段内的偏移地址作为新的IP值；这样，程序跳转到新的代码段执行。<br>
JMP  FAR PTR  OTHERSEG         ；远转移到代码段2的OTHERSEG</p>
<p>段间间接转移：    JMP    DWORD PTR  OPR<br>
执行操作：    （IP）← （EA）<br>
（CS）← （EA+2）<br>
用一个存储单元表示要跳转的目标地址。这个目标地址存放在主存中连续的字单元中的，低位字送IP寄存器，高位字送CS寄存器。<br>
MOV WORD PTR [BX]，1000H<br>
MOV WORD PTR [BX+2]，1500H<br>
JMP FAR [BX]；转移到1500H:1000H</p>
<h5 id="条件转移指令">条件转移指令</h5>
<p>条件转移指令是一组极其重要的转移指令，它根据标志寄存器中的一个（或多个）标志位来决定是否需要转移，这就为实现多功能程序提供了必要的手段。微机的指令系统提供了丰富的条件转移指令来满足各种不同的转移需要，在编程序时，要对它们灵活运用。<br>
基本格式：<br>
JXX    LABEL     ；条件满足，发生转移：IP←IP＋位移量<br>
；条件不满足，顺序执行。<br>
指定的条件XX如果成立，程序转移到由标号LABEL指定的目标地址去执行指令；条件不成立，则程序将顺序执行下一条指令。<br>
操作数LABEL是采用短转移，称为相对寻址方式。<br>
JXX指令不影响标志，但要利用标志。</p>
<p>根据单个条件标志的设置情况转移</p>
<table>
<thead>
<tr>
<th style="text-align:center">指令助记符</th>
<th style="text-align:center">转移条件</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">JC</td>
<td style="text-align:center">CF=1</td>
<td style="text-align:center">有进位转移</td>
</tr>
<tr>
<td style="text-align:center">JNC</td>
<td style="text-align:center">CF=0</td>
<td style="text-align:center">无进位转移</td>
</tr>
<tr>
<td style="text-align:center">JZ/JE</td>
<td style="text-align:center">ZF=1</td>
<td style="text-align:center">等于/为零转移</td>
</tr>
<tr>
<td style="text-align:center">JNZ/JNE</td>
<td style="text-align:center">ZF=0</td>
<td style="text-align:center">不等于/非零转移</td>
</tr>
<tr>
<td style="text-align:center">JO</td>
<td style="text-align:center">OF=1</td>
<td style="text-align:center">有符号数结果溢出转移</td>
</tr>
<tr>
<td style="text-align:center">JNO</td>
<td style="text-align:center">OF=0</td>
<td style="text-align:center">有符号数结果不溢出转移</td>
</tr>
<tr>
<td style="text-align:center">JP</td>
<td style="text-align:center">PF=1</td>
<td style="text-align:center">结果低8位奇偶校验为偶转移</td>
</tr>
<tr>
<td style="text-align:center">JNP</td>
<td style="text-align:center">PF=0</td>
<td style="text-align:center">结果低8位奇偶校验为奇转移</td>
</tr>
<tr>
<td style="text-align:center">JS</td>
<td style="text-align:center">SF=1</td>
<td style="text-align:center">结果为负时转移</td>
</tr>
<tr>
<td style="text-align:center">JNS</td>
<td style="text-align:center">SF=0</td>
<td style="text-align:center">结果为非负时转移</td>
</tr>
</tbody>
</table>
<p>无符号数的条件转移指令</p>
<p>无符号数的大小用高（Above）低（Below）表示利用CF确定高低、利用ZF标志确定相等（Equal）<br>
两数的高低分成4种关系：<br>
⑴  低于（不高于等于）：JB（JNAE）     CF=1, ZF=0<br>
⑵  不低于（高于等于）：JNB（JAE）     CF=0<br>
⑶  低于等于（不高于）：JBE（JNA）     CF=1或ZF=1<br>
⑷  不低于等于（高于）：JNBE（JA ）    CF=ZF=0</p>
<p>有符号数的条件转移指令</p>
<p>符号数的大（Greater）小（Less）需要组合OF、SF标志，并利用ZF标志确定相等（Equal）<br>
两数的大小分成4种关系：<br>
⑴ 小于（不大于等于）：JL（JNGE）   ZF=0 且 SF异或OF=1<br>
⑵ 不小于（大于等于）：JNL（JGE）   ZF=1 或 SF异或OF=0<br>
⑶ 小于等于（不大于）：JLE（JNG）   ZF=1 或 SF异或OF=1<br>
⑷ 不小于等于（大于）：JNLE（JG ）  ZF=0 且 SF异或OF=0</p>
<p>测试条件满足:SF 异或 OF=1时，A&lt;B<br>
测试条件满足:SF 异或 OF=0时，A&gt;=B</p>
<p>测试CX的值为0则转移指令</p>
<p>条件转移指令中还有一条较特殊的指令，因为CX寄存器通常在程序中用做计数器，JCXZ指令就可以用来判断计数是否为0。</p>
<p>格式：<br>
JCXZ         LABEL      ；CX＝0，发生转移：IP←IP＋位移量<br>
；CX≠0，顺序执行。</p>
<h5 id="循环指令">循环指令</h5>
<h6 id="循环指令-loop">循环指令 LOOP</h6>
<p>语句格式： LOOP  短标号<br>
执行过程：1）（CX）＝（CX）-1（不改变任何标志位）<br>
2)如果（CX）≠0，转向“标号”所指向的指令，否则，终止循环，执行该指令下面的指令。<br>
说明：LOOP指令可代替两条指令：<br>
DEC  CX<br>
JNE  短标号</p>
<h6 id="相等为零循环指令-loopeloopz">相等/为零循环指令  LOOPE/LOOPZ</h6>
<p>语句格式： LOOPE/ LOOPZ  短标号</p>
<p>执行过程：<br>
1）（CX）＝（CX）-1（不改变任何标志位）<br>
2）如果CX≠0且ZF=1，则程序转到循环体的第一条指令，否则，程序将执行该循环指令下面的指令。</p>
<h6 id="不相等不为零循环指令loopneloopnz">不相等/不为零循环指令LOOPNE/LOOPNZ</h6>
<p>语句格式： LOOPNE/ LOOPNZ  短标号</p>
<p>执行过程：<br>
1）（CX）＝（CX）-1（不改变任何标志位）<br>
2）如果CX≠0且ZF=0，则程序转到循环体的第一条指令，否则，程序将执行该循环指令下面的指令。</p>
<h4 id="子程序">子程序</h4>
<p>子程序是完成特定功能的一段程序。如果某程序段在源程序内反复出现，就可把该程序段定义为子程序。这样可以缩短源程序长度、节省目标程序的存储空间，也可提高程序的可维护性和共享性。<br>
当主程序（调用程序）需要执行这个功能时，采用 CALL 调用指令转移到该子程序的起始处执行；<br>
当运行完子程序功能后，采用 RET 返回指令回到主程序继续执行。</p>
<h5 id="子程序调用指令-call">子程序调用指令   CALL</h5>
<p>类似JMP指令， CALL指令分成4种类型：<br>
CALL label     ；段内调用、直接寻址（段内直接调用）<br>
CALL r16/m16；段内调用、间接寻址（段内间接调用）<br>
CALL far ptr label；段间调用、直接寻址（段间直接调用）<br>
CALL dword ptr mem；段间调用、间接寻址（段间间接调用）<br>
但不同于JMP指令，CALL指令需要保存返回地址：<br>
段内调用——入栈偏移地址IP：<br>
SP←SP－2，SS:SP←IP<br>
段间调用——入栈偏移地址IP和段地址CS：<br>
SP←SP－2，SS:SP←IP；<br>
SP←SP－2，SS:SP←CS。</p>
<p>段内直接调用<br>
格        式：CALL　DST<br>
执行步骤：<br>
① 将子程序的返回地址存入堆栈，以便子程序返回使用。<br>
即： （SP）←SP - 2；<br>
（SP）+1,（SP）←IP<br>
② 转移到子程序入口地址去继续执行子程序。指令中的DST在汇编格式指令作用子程序入口地址的符号地址（标号）。在机器语言中，它是一个16位的偏移量。即： （IP）←IP+ D16<br>
注：段内调用只改变IP，不改变CS的值。</p>
<p>段内间接调用<br>
格  式：CALL　DST<br>
此指令的执行步骤和段内直接调用大致相同，主要区别是子程序的入口地址DST的寻址方式不同而已。它可以是寄存器操作数和各种寻址方式的存储器操作数，当然不允许是立即数和段寄存器操作数。</p>
<p>段间直接调用<br>
格         式：CALL　DST<br>
执行操作：  ①  SP←SP - 2；  ② （SP）+1,（SP）←CS ；<br>
③ SP←SP - 2；  ④ （SP）+1,（SP）←IP ；<br>
⑤  IP ←偏移地址（指令的第2、3字节）；<br>
⑥ CS ←段地址（指令的第4、5字节）；</p>
<p>段间间接调用<br>
格         式：CALL　DST<br>
执行操作：  ①  SP←SP - 2；      ② （SP）+1,（SP）←CS ；<br>
③ SP←SP - 2；      ④ （SP）+1,（SP）←IP ；<br>
⑤  IP ←（EA）；  ⑥ CS ←（EA+2）；<br>
此指令的执行步骤和段间直接调用大致相同，主要区别是子程序的入口地址DST的寻址方式不同而已。它可以是寄存器操作数和各种寻址方式的存储器操作数，也即由各种寻址方式形成的有效地址EA和EA+1两个单元内容送入IP，EA+2和EA+3两个单元内容送入CS。</p>
<h5 id="返回指令-ret">返回指令  RET</h5>
<p>(1) 段内近返回：RET<br>
执行操作： （IP ）← （SP）+1,（SP）<br>
（SP）← SP + 2<br>
(2) 段内带立即数近返回：RET  EXP<br>
RET可以带有一个立即数，堆栈指针SP将增加，即SP←SP+EXP。这个特点使得程序可以方便地废除若干执行CALL指令以前入栈参数。<br>
(3) 段间远返回：RET<br>
执行操作：    （IP） ← （SP）+1,（SP）<br>
（SP）←（SP） + 2<br>
（CS）← （SP）+1,（SP）<br>
（SP）←（SP） + 2<br>
(4) 段间带立即数远返回：RET  EXP（同段内带立即数返回）</p>
<h4 id="中断">中断</h4>
<p>中断就是CPU暂停当前程序的执行，转而执行处理紧急事务的程序，并在该事务处理完后能自动恢复执行原先程序的过程。在此，称引起紧急事务的事件为中断源，称处理紧急事务的程序为中断服务程序或中断处理程序。</p>
<p>中断处理程序基本上是系统程序员编写好的，是为操作系统或用户程序服务的。为了在应用程序中使用中断服务程序，程序员必须能够在程序中有目的地安排中断的发生。为此，指令系统提供了各种引起中断的指令。</p>
<h5 id="中断向量表和中断服务程序">中断向量表和中断服务程序</h5>
<p>中断向量表是一个特殊的线性表，它保存着系统所有中断服务程序的入口地址（偏移量和段地址）。在微机系统中，该向量表有256个元素（0~0FFH），每个元素占4个字节，总共1K字节。</p>
<h5 id="中断指令-int">中断指令 INT</h5>
<p>一般格式：INT    TYPE<br>
其中：立即数TYPE是一个0~0FFH范围内的整数。<br>
指令执行的步骤：<br>
1）把标志寄存器压栈，清除标志位IF和TF；<br>
2）把代码段寄存器CS和指令指针寄存器IP的内容压栈；<br>
3）（IP） ←（TYPEx4），（CS） ←（TYPEx4+2）</p>
<h5 id="溢出指令-into">溢出指令 INTO</h5>
<p>当标志位OF为1时，引起中断。<br>
该指令的格式如下： INTO<br>
该指令影响标志位：IF和TF。</p>
<h5 id="中断返回指令-iret">中断返回指令 IRET</h5>
<p>当一个中断服务程序执行完毕时，CPU将恢复被中断的现场，返回到引起中断的程序中。为了实现此项功能，指令系统提供了一条专用的中断返回指令。</p>
<p>指令格式：  IRET</p>
<p>该指令执行的过程基本上是INT指令的逆过程，具体如下：<br>
1）从栈顶弹出内容送入IP；<br>
2）再从新栈顶弹出内容送入CS；<br>
3）再从新栈顶弹出内容送入标志寄存器；</p>
<h5 id="中断和子程序的比较">中断和子程序的比较</h5>
<p>中断和子程序调用之间有其相似和不同之处。它们的工作过程非常相似，即：暂停当前程序的执行，转而执行另一程序段，当该程序段执行完时，CPU都自动恢复原程序的执行。它们的主要差异有：<br>
1）子程序调用一定是程序员在编写源程序时事先安排好的，是可知的，而中断是由中断源根据自身的需要产生的，是不可预见的（用指令INT引起的中断除外）；<br>
2）子程序调用是用CALL指令来实现的，但没有调用中断的指令，只有发出中断请求的事件（指令INT是发出内部中断信号，而不要理解为调用中断服务程序）；<br>
3）子程序的返回指令是RET，而中断服务程序的返回指令是IRET。<br>
4）在通常情况下，子程序是由应用系统的开发者编写的，而中断服务程序是由系统软件设计者编写的。</p>
<h3 id="处理机控制和杂项指令">处理机控制和杂项指令</h3>
<h4 id="标志处理指令">标志处理指令</h4>
<p>CLC     进位位置0指令                     ； CF ← 0<br>
CMC    进位位求反指令                   ； CF ←/CF<br>
STC      进位位置1指令                     ；CF ← 1<br>
CLD     方向标志位置0指令             ；DF ← 0<br>
STD      方向标志位置1指令             ；DF ← 1<br>
CLI      中断标志位置0指令             ；IF ← 0<br>
STI       中断标志位置1指令             ；IF ← 1</p>
<h4 id="cpu控制类指令">CPU控制类指令</h4>
<h5 id="空操作指令-nopno-operation-instruction">空操作指令   NOP（No Operation Instruction）</h5>
<p>该指令不执行任何操作，但占用一个字节存储单元，空耗一个指令执行周期，常用于程序调试。<br>
例如：在需要预留指令空间时用NOP填充，代码空间多余时也可以用NOP填充，还可以用NOP实现软件延时。<br>
事实上，NOP和   XCHG AL，AL    的指令代码一样。</p>
<h5 id="暂停指令-hltenter-halt-state-instruction">暂停指令   HLT（Enter Halt State Instruction）</h5>
<p>在等待中断信号时，该指令使CPU处于暂停工作状态，CS:IP指向下一条待执行的指令。当产生了中断信号，CPU把CS和IP压栈，并转入中断处理程序。在中断处理程序执行完后，中断返回指令IRET弹出IP和CS，并唤醒CPU执行下条指令。</p>
<h5 id="换码指令esc">换码指令ESC</h5>
<p>把浮点指令交给浮点处理器执行。提高系统浮点运算能力的协处理器8087指令是与8086的整数指令组合在一起的，8086主存中存储8087的操作码及其所需的操作数。当8086发现是一条浮点指令时，就利用ESC指令将浮点指令交给8087执行。实际编写程序时，一般采用易于理解的浮点指令助记符格式。</p>
<p>ESC 6，[SI]               ；实数除法指令：FDIV dword ptr [SI]<br>
ESC 20H，AL；整数加法指令：FADD ST(0),ST</p>
<h5 id="等待指令-waitput-processor-in-wait-state-instruction">等待指令  WAIT（Put Processor in Wait State Instruction）</h5>
<p>该指令使CPU处于等待状态，直到协处理器（Coprocessor）完成运算，并用一个重启信号唤醒CPU为止。该指令执行不影响任何标志位。<br>
8086就是利用WAIT指令和测试引脚实现与8087同步运行的。浮点指令经由8086CPU处理发往8087，并与8086本身的整数指令在同一个指令序列；而8087执行浮点指令较慢，所以8086必须与8087保持同步。</p>
<h5 id="封锁数据指令locklock-bus-instruction">封锁数据指令LOCK（Lock Bus Instruction）</h5>
<p>这是一个指令前缀，可放在任何指令前。这个前缀使得在这个指令执行时间内，8086 处理器的封锁输出引脚有效，即把总线封锁，使别的控制器不能控制总线；直到该指令执行完后，总线封锁解除。</p>
<h1 id="第四章-汇编语言及其程序设计">第四章 汇编语言及其程序设计</h1>
<h1 id="第五章-存储器">第五章 存储器</h1>
<h1 id="第六章-中断技术">第六章 中断技术</h1>
<h1 id="第七章-io接口技术">第七章 I/O接口技术</h1>
<h1 id="第八章-da与ad转换器接口">第八章 D/A与A/D转换器接口</h1>
<h1 id="第九章-微机总线">第九章 微机总线</h1>
<h1 id="第十章-人机交互接口">第十章 人机交互接口</h1>
<h1 id="a-target_blank-hrefhttpmailqqcomcgi-binqm_sharetqm_mailmeemailk_h88fzp0_livfd8-g-styletext-decorationnone-意见反馈a"><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=k_H88fzp0_LivfD8-g" style="text-decoration:none;">✉ 意见反馈</a></h1>

                        </div>
                        
                            <div class="post-toc">
                                <ul class="markdownIt-TOC">
<li><a href="#%E9%A2%84-%E5%A4%87-%E7%9F%A5-%E8%AF%86">预 备 知 识</a>
<ul>
<li><a href="#%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8">微处理器</a></li>
<li><a href="#%E5%BE%AE%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA">微型计算机</a></li>
<li><a href="#%E5%8D%95%E7%89%87%E6%9C%BA">单片机</a></li>
<li><a href="#%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8C%85%E6%8B%AC">嵌入式系统包括</a></li>
<li><a href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">程序设计语言</a></li>
<li><a href="#c%E8%AF%AD%E8%A8%80%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8C%BA%E5%88%AB">C语言与汇编语言的区别</a></li>
<li><a href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80">汇编语言</a></li>
<li><a href="#%E5%BE%AE%E6%9C%BA%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87">微机的性能指标</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BE%AE%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80">第一章 微型计算机基础</a>
<ul>
<li><a href="#11-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81%E5%8F%8A%E5%85%B6%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA">1.1  计算机中数制与编码及其数的表示</a>
<ul>
<li><a href="#%E8%BF%9B%E4%BD%8D%E8%AE%A1%E6%95%B0%E5%88%B6">进位计数制</a></li>
<li><a href="#%E6%95%B0%E5%88%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2">数制之间的转换</a>
<ul>
<li><a href="#%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2">十进制数与二进制数之间的转换</a></li>
<li><a href="#%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0%E4%B8%8E%E5%85%AB%E8%BF%9B%E5%88%B6%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2">十进制数与八进制数之间的转换</a></li>
<li><a href="#%E5%8D%81%E8%BF%9B%E5%88%B6%E4%B8%8E%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2">十进制与十六进制之间的转换</a></li>
<li><a href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8E%E5%85%AB%E8%BF%9B%E5%88%B6-%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2">二进制与八进制、十六进制数之间的转换</a></li>
</ul>
</li>
<li><a href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E6%B3%95">常用的编码方法</a>
<ul>
<li><a href="#%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E7%BC%96%E7%A0%81">十进制数的编码</a></li>
<li><a href="#%E9%9D%9E%E6%95%B0%E5%80%BC%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BC%96%E7%A0%81">非数值型数据的编码</a>
<ul>
<li><a href="#%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81">字符编码</a></li>
<li><a href="#%E6%B1%89%E5%AD%97%E7%9A%84%E7%BC%96%E7%A0%81">汉字的编码</a></li>
<li><a href="#%E9%80%BB%E8%BE%91%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BC%96%E7%A0%81">逻辑数据的编码</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA">计算机中数的表示</a>
<ul>
<li><a href="#%E7%9C%9F%E5%80%BC%E4%B8%8E%E6%9C%BA%E5%99%A8%E6%95%B0">真值与机器数</a></li>
<li><a href="#%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E4%B8%8E%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0">有符号数与无符号数</a></li>
<li><a href="#%E5%8E%9F%E7%A0%81-%E5%8F%8D%E7%A0%81-%E8%A1%A5%E7%A0%81"><strong>原码  反码  补码</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#12-%E5%BE%AE%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F">1.2 微型计算机系统</a>
<ul>
<li><a href="#%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8-2">微处理器</a></li>
<li><a href="#%E5%AD%98%E5%82%A8%E5%99%A8">存储器</a></li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF">系统总线</a></li>
<li><a href="#io%E6%8E%A5%E5%8F%A3%E7%94%B5%E8%B7%AF%E5%92%8Cio%E8%AE%BE%E5%A4%87">I/O接口电路和I/O设备</a>
<ul>
<li><a href="#io%E6%8E%A5%E5%8F%A3%E7%94%B5%E8%B7%AF%E4%B8%80%E8%88%AC%E7%94%B1%E4%B8%89%E7%A7%8D%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%84%E6%88%90">I/O接口电路一般由三种寄存器组成</a></li>
</ul>
</li>
<li><a href="#%E8%BD%AF%E4%BB%B6">软件</a>
<ul>
<li><a href="#%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6">系统软件</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#13-%E5%BE%AE%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E6%A6%82%E8%BF%B0">1.3  微型计算机发展概述</a>
<ul>
<li><a href="#%E5%8F%8C%E6%A0%B8%E6%8A%80%E6%9C%AF">双核技术</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84">第二章 微处理器的结构</a>
<ul>
<li><a href="#80868088cpu%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84">8086/8088CPU的内部结构</a>
<ul>
<li><a href="#80868088cpu%E5%8A%9F%E8%83%BD%E7%BB%93%E6%9E%84">8086/8088CPU功能结构</a>
<ul>
<li><a href="#%E6%80%BB%E7%BA%BF%E6%8E%A5%E5%8F%A3%E9%83%A8%E4%BB%B6biu">总线接口部件BIU</a>
<ul>
<li><a href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8">段寄存器</a></li>
<li><a href="#%E6%8C%87%E4%BB%A4%E6%8C%87%E9%92%88%E5%AF%84%E5%AD%98%E5%99%A8ip">指令指针寄存器（IP）</a></li>
<li><a href="#%E5%9C%B0%E5%9D%80%E5%8A%A0%E6%B3%95%E5%99%A8">地址加法器</a></li>
<li><a href="#%E6%8C%87%E4%BB%A4%E9%98%9F%E5%88%97">指令队列</a></li>
<li><a href="#%E6%80%BB%E7%BA%BF%E6%8E%A7%E5%88%B6%E7%94%B5%E8%B7%AF">总线控制电路</a></li>
</ul>
</li>
<li><a href="#%E6%89%A7%E8%A1%8C%E9%83%A8%E4%BB%B6eu">执行部件EU</a></li>
<li><a href="#%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8">通用寄存器</a>
<ul>
<li><a href="#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8fr">标志寄存器(FR)</a></li>
<li><a href="#%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E9%83%A8%E4%BB%B6alu">算术逻辑部件(ALU)</a></li>
<li><a href="#%E6%89%A7%E8%A1%8C%E9%83%A8%E4%BB%B6%E6%8E%A7%E5%88%B6%E7%94%B5%E8%B7%AF">执行部件控制电路</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#8086%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84">8086的寄存器结构</a>
<ul>
<li><a href="#%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8-2">通用寄存器</a></li>
<li><a href="#ax-%E7%B4%AF%E5%8A%A0%E5%99%A8">AX 累加器</a></li>
<li><a href="#bx-%E5%9F%BA%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8">BX 基址寄存器</a></li>
<li><a href="#cx-%E8%AE%A1%E6%95%B0%E5%99%A8">CX 计数器</a></li>
<li><a href="#dx-%E6%95%B0%E6%8D%AE%E5%AF%84%E5%AD%98%E5%99%A8">DX 数据寄存器</a></li>
<li><a href="#bp-%E5%9F%BA%E5%9D%80%E6%8C%87%E9%92%88%E5%AF%84%E5%AD%98%E5%99%A8">BP 基址指针寄存器</a></li>
<li><a href="#sp-%E5%A0%86%E6%A0%88%E6%8C%87%E9%92%88">SP 堆栈指针</a></li>
<li><a href="#si-%E6%BA%90%E5%8F%98%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8">SI 源变址寄存器</a></li>
<li><a href="#di-%E7%9B%AE%E7%9A%84%E5%8F%98%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8">DI 目的变址寄存器</a></li>
</ul>
</li>
<li><a href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8-2">段寄存器</a>
<ul>
<li><a href="#cs-%E4%BB%A3%E7%A0%81%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8">CS 代码段寄存器</a></li>
<li><a href="#ds-%E6%95%B0%E6%8D%AE%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8">DS 数据段寄存器</a></li>
<li><a href="#ss-%E5%A0%86%E6%A0%88%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8">SS 堆栈段寄存器</a></li>
<li><a href="#es-%E9%99%84%E5%8A%A0%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8">ES 附加段寄存器</a></li>
</ul>
</li>
<li><a href="#ip-%E6%8C%87%E4%BB%A4%E6%8C%87%E9%92%88%E5%AF%84%E5%AD%98%E5%99%A8">IP 指令指针寄存器</a></li>
<li><a href="#fr-%E6%A0%87%E8%AF%86%E5%AF%84%E5%AD%98%E5%99%A8">FR 标识寄存器</a>
<ul>
<li><a href="#%E7%8A%B6%E6%80%81%E6%A0%87%E5%BF%97">状态标志</a>
<ul>
<li><a href="#of-%E6%BA%A2%E5%87%BA%E6%A0%87%E5%BF%97">OF  溢出标志</a></li>
<li><a href="#sf-%E7%AC%A6%E5%8F%B7%E6%A0%87%E5%BF%97">SF  符号标志</a></li>
<li><a href="#zf-%E9%9B%B6%E6%A0%87%E5%BF%97">ZF  零标志</a></li>
<li><a href="#cf-%E8%BF%9B%E4%BD%8D%E6%A0%87%E5%BF%97">CF  进位标志</a></li>
<li><a href="#af-%E8%BE%85%E5%8A%A9%E8%BF%9B%E4%BD%8D%E6%A0%87%E5%BF%97">AF  辅助进位标志</a></li>
<li><a href="#pf-%E5%A5%87%E5%81%B6%E6%A0%87%E5%BF%97">PF  奇偶标志</a></li>
</ul>
</li>
<li><a href="#%E6%8E%A7%E5%88%B6%E6%A0%87%E5%BF%97">控制标志</a>
<ul>
<li><a href="#df-%E6%96%B9%E5%90%91%E6%A0%87%E5%BF%97">DF   方向标志</a></li>
<li><a href="#i-f-%E4%B8%AD%E6%96%AD%E5%85%81%E8%AE%B8%E6%A0%87%E5%BF%97">I F   中断允许标志</a></li>
<li><a href="#tf-%E5%8D%95%E6%AD%A5%E6%A0%87%E5%BF%97%E9%99%B7%E9%98%B1%E6%A0%87%E5%BF%97">TF   单步标志（陷阱标志）</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#8086%E7%9A%84%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%84%E7%BB%87">8086的存储器组织</a>
<ul>
<li><a href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%84%E7%BB%87%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F">存储器组织与数据存储格式</a>
<ul>
<li><a href="#%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83%E5%9C%B0%E5%9D%80">存储单元地址</a></li>
<li><a href="#%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83%E7%9A%84%E5%86%85%E5%AE%B9">存储单元的内容</a></li>
<li><a href="#%E5%A5%87%E5%9C%B0%E5%9D%80%E5%AD%98%E5%82%A8%E4%BD%93%E5%92%8C%E5%81%B6%E5%9C%B0%E5%9D%80%E5%AD%98%E5%82%A8%E4%BD%93">奇地址存储体和偶地址存储体</a></li>
<li><a href="#8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%AD%97%E8%8A%82%E5%92%8C%E5%AD%97%E4%B8%A4%E7%A7%8D%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4">8086指令系统中，字节和字两种操作指令。</a></li>
</ul>
</li>
<li><a href="#%E5%AD%98%E5%82%A8%E5%99%A8%E5%88%86%E6%AE%B5%E7%BB%93%E6%9E%84">存储器分段结构</a>
<ul>
<li><a href="#%E6%A0%B9%E6%8D%AE%E6%AE%B5%E5%86%85%E5%AD%98%E6%94%BE%E4%BF%A1%E6%81%AF%E7%9A%84%E4%B8%8D%E5%90%8C%E5%88%86%E4%B8%BA">根据段内存放信息的不同分为</a></li>
</ul>
</li>
<li><a href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E4%B8%8E%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BD%AC%E6%8D%A2">逻辑地址与物理地址的转换</a>
<ul>
<li><a href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80">物理地址</a></li>
<li><a href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80">逻辑地址</a></li>
<li><a href="#%E6%AE%B5%E5%9F%BA%E5%80%BC">段基值</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#8086%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%BC%95%E8%84%9A%E4%BF%A1%E5%8F%B7">8086的工作模式及引脚信号</a>
<ul>
<li><a href="#8086%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F">8086的工作模式</a>
<ul>
<li><a href="#%E6%9C%80%E5%B0%8F%E6%A8%A1%E5%BC%8F">最小模式</a></li>
<li><a href="#%E6%9C%80%E5%A4%A7%E6%A8%A1%E5%BC%8F">最大模式</a></li>
<li><a href="#8087">8087</a></li>
<li><a href="#8089%E5%8D%8F%E5%A4%84%E7%90%86%E5%99%A8">8089协处理器</a></li>
</ul>
</li>
<li><a href="#8086%E7%9A%84%E5%BC%95%E8%84%9A%E4%BF%A1%E5%8F%B7">8086的引脚信号</a>
<ul>
<li><a href="#ad15~ad0address-data-bus-2~16">AD15~AD0(Address Data Bus ，2~16)</a>
<ul>
<li><a href="#%E6%80%BB%E7%BA%BF%E5%88%86%E6%97%B6%E5%A4%8D%E7%94%A8">总线分时复用</a></li>
<li><a href="#%E4%B8%89%E6%80%81">三态</a></li>
</ul>
</li>
<li><a href="#a19s6~a16s3address-status-bus35~38">A19/S6~A16/S3(Address Status Bus，35~38)</a>
<ul>
<li><a href="#%E5%8F%AF%E5%B1%8F%E8%94%BD%E4%B8%AD%E6%96%AD">可屏蔽中断</a></li>
</ul>
</li>
<li><a href="#bhes7bus-high-enablestatus34">BHE/S7（Bus High Enable/Status，34）</a></li>
<li><a href="#mnmxminimummaximum-model-control33">MN/MX(Minimum/Maximum Model Control，33)</a></li>
<li><a href="#rdread32">RD(Read，32）</a></li>
<li><a href="#testtest23">TEST(Test，23)</a></li>
<li><a href="#readyready22">READY(Ready，22)</a></li>
<li><a href="#resetreset21">RESET(Reset，21)</a></li>
<li><a href="#clkclock19">CLK(Clock，19)</a></li>
<li><a href="#vcc40">VCC(40)</a></li>
<li><a href="#gnd1-20">GND(1、20)</a></li>
<li><a href="#nminon-maskable-interrupt17">NMI(Non-Maskable Interrupt，17)</a></li>
<li><a href="#intrinterrupt-request18">INTR(Interrupt Request，18)</a>
<ul>
<li><a href="#%E5%8F%AF%E5%B1%8F%E8%94%BD%E4%B8%AD%E6%96%AD%E5%92%8C%E9%9D%9E%E5%B1%8F%E8%94%BD%E4%B8%AD%E6%96%AD%E7%9A%84%E5%8C%BA%E5%88%AB">可屏蔽中断和非屏蔽中断的区别</a></li>
</ul>
</li>
<li><a href="#%E6%9C%80%E5%B0%8F%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%8424%E5%88%B031%E5%BC%95%E8%84%9A">最小模式下的24到31引脚</a>
<ul>
<li><a href="#intainterrupt-acknowledge24">INTA(Interrupt Acknowledge，24）</a></li>
<li><a href="#aleaddress-lock-enable25">ALE(Address Lock Enable，25)</a></li>
<li><a href="#dendata-enable26">DEN(Data Enable，26)</a></li>
<li><a href="#dtrdata-transmitreceive27">DT/R(Data Transmit/Receive，27)</a></li>
<li><a href="#miomemoryinput-output28">M/IO(Memory/Input &amp;Output，28)</a></li>
<li><a href="#wr-write29%E4%B8%89%E6%80%81">WR (Write，29，三态)</a></li>
<li><a href="#holdhold-reqest31">HOLD(Hold Reqest，31)</a></li>
<li><a href="#hlda-hold-acknowledge30">HLDA (Hold Acknowledge，30)</a></li>
</ul>
</li>
<li><a href="#%E6%9C%80%E5%A4%A7%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%BC%95%E8%84%9A%E4%BF%A1%E5%8F%B7">最大工作模式下的引脚信号</a>
<ul>
<li><a href="#rqgtrequestgrant30-31">RQ/GT(Request/Grant，30、31)</a></li>
<li><a href="#lock">LOCK</a></li>
<li><a href="#s2-s1-s0bus-cycles-status">S2、S1、S0(Bus Cycles Status)</a></li>
<li><a href="#qs1qs0-instruction-queue-status">QS1,QS0 (Instruction Queue Status)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#8086%E7%9A%84%E6%80%BB%E7%BA%BF%E6%93%8D%E4%BD%9C%E6%97%B6%E5%BA%8F">8086的总线操作时序</a>
<ul>
<li><a href="#%E6%97%B6%E9%92%9F%E5%91%A8%E6%9C%9Fclock-cycle">时钟周期（Clock Cycle）</a></li>
<li><a href="#%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9Finstruction-cyclefetch-decode-execute-cycle">指令周期（Instruction Cycle，fetch-decode-execute cycle）</a></li>
<li><a href="#%E6%80%BB%E7%BA%BF%E5%91%A8%E6%9C%9Fbus-cycle">总线周期（Bus Cycle）</a></li>
<li><a href="#%E6%80%BB%E7%BA%BF%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4">总线操作步骤</a>
<ul>
<li><a href="#%E6%80%BB%E7%BA%BF%E6%93%8D%E4%BD%9C">总线操作</a></li>
<li><a href="#%E4%B8%80%E4%B8%AA%E6%80%BB%E7%BA%BF%E5%91%A8%E6%9C%9F%E9%80%9A%E5%B8%B8%E5%88%86%E4%B8%BA%E5%9B%9B%E4%B8%AA%E9%98%B6%E6%AE%B5">一个总线周期通常分为四个阶段</a>
<ul>
<li><a href="#%E6%80%BB%E7%BA%BF%E8%AF%B7%E6%B1%82%E5%92%8C%E4%BB%B2%E8%A3%81%E9%98%B6%E6%AE%B5">总线请求和仲裁阶段</a></li>
<li><a href="#%E5%AF%BB%E5%9D%80%E9%98%B6%E6%AE%B5">寻址阶段</a></li>
<li><a href="#%E4%BC%A0%E9%80%81%E6%95%B0%E6%8D%AE%E9%98%B6%E6%AE%B5">传送数据阶段</a></li>
<li><a href="#%E7%BB%93%E6%9D%9F%E9%98%B6%E6%AE%B5">结束阶段</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#8086%E7%9A%84%E6%80%BB%E7%BA%BF%E6%93%8D%E4%BD%9C%E6%97%B6%E5%BA%8F-2">8086的总线操作时序</a>
<ul>
<li><a href="#%E6%80%BB%E7%BA%BF%E6%93%8D%E4%BD%9C-2">总线操作</a></li>
<li><a href="#%E6%80%BB%E7%BA%BF%E6%97%B6%E5%BA%8F">总线时序</a>
<ul>
<li><a href="#%E6%9C%80%E5%B0%8F%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E8%AF%BB%E6%80%BB%E7%BA%BF%E5%91%A8%E6%9C%9F">最小模式下的读总线周期</a></li>
<li><a href="#%E6%9C%80%E5%B0%8F%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%86%99%E6%80%BB%E7%BA%BF%E5%91%A8%E6%9C%9F">最小模式下的写总线周期</a></li>
<li><a href="#%E7%A9%BA%E9%97%B2%E5%91%A8%E6%9C%9F">空闲周期</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F">第三章 指令系统</a>
<ul>
<li><a href="#%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F">指令格式</a>
<ul>
<li><a href="#%E5%89%8D%E7%BC%80%E5%AD%97%E6%AE%B5">前缀字段</a></li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%A0%81%E5%AD%97%E6%AE%B51~2%E5%AD%97%E8%8A%82">操作码字段(1~2字节)</a></li>
<li><a href="#%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%AD%97%E6%AE%B52%E5%AD%97%E8%8A%82">寻址方式字段（2字节）</a></li>
<li><a href="#%E4%BD%8D%E7%A7%BB%E9%87%8F%E5%AD%97%E6%AE%B51-2%E6%88%964%E5%AD%97%E8%8A%82">位移量字段（1、2或4字节）</a></li>
<li><a href="#%E7%AB%8B%E5%8D%B3%E6%95%B0%E5%AD%97%E6%AE%B512%E6%88%964%E5%AD%97%E8%8A%82">立即数字段(1，2或4字节)</a></li>
</ul>
</li>
<li><a href="#%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F">寻址方式</a>
<ul>
<li><a href="#11%E7%A7%8D%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%AF%B9%E5%BA%94%E7%9A%84%E6%9C%89%E6%95%88%E5%9C%B0%E5%9D%80">11种寻址方式及对应的有效地址</a></li>
<li><a href="#%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB">寻址方式分类</a></li>
<li><a href="#%E7%AB%8B%E5%8D%B3%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F">立即寻址方式</a></li>
<li><a href="#%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F">直接寻址方式</a></li>
<li><a href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F">寄存器寻址方式</a></li>
<li><a href="#%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F">寄存器间接寻址方式</a></li>
<li><a href="#%E5%AF%84%E5%AD%98%E5%99%A8%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F">寄存器相对寻址方式</a></li>
<li><a href="#%E5%9F%BA%E5%9D%80%E5%8A%A0%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F">基址加变址寻址方式</a></li>
<li><a href="#%E5%B8%A6%E4%BD%8D%E7%A7%BB%E7%9A%84%E5%9F%BA%E5%9D%80%E5%8A%A0%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F">带位移的基址加变址寻址方式</a></li>
<li><a href="#%E6%AF%94%E4%BE%8B%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80">比例变址寻址</a></li>
<li><a href="#%E5%B8%A6%E4%BD%8D%E7%A7%BB%E7%9A%84%E6%AF%94%E4%BE%8B%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80">带位移的比例变址寻址</a></li>
<li><a href="#%E5%9F%BA%E5%9D%80%E5%8A%A0%E6%AF%94%E4%BE%8B%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%8032%E4%BD%8D%E5%AF%BB%E5%9D%80">基址加比例变址寻址（32位寻址）</a></li>
<li><a href="#%E5%B8%A6%E4%BD%8D%E7%A7%BB%E7%9A%84%E5%9F%BA%E5%9D%80%E5%8A%A0%E6%AF%94%E4%BE%8B%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80">带位移的基址加比例变址寻址</a></li>
<li><a href="#%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E7%9A%84%E9%BB%98%E8%AE%A4%E6%AE%B5">寄存器间接寻址的默认段</a></li>
</ul>
</li>
<li><a href="#%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F">指令系统</a>
<ul>
<li><a href="#%E6%8C%87%E4%BB%A4%E6%93%8D%E4%BD%9C%E6%95%B0%E7%AC%A6%E5%8F%B7%E8%AF%B4%E6%98%8E">指令操作数符号说明：</a></li>
<li><a href="#%E4%B8%8E%E8%BF%90%E7%AE%97%E6%9C%89%E5%85%B3%E7%9A%84%E6%A0%87%E5%BF%97">与运算有关的标志</a></li>
<li><a href="#%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%AF%B9%E6%A0%87%E5%BF%97%E4%BD%8D%E5%BD%B1%E5%93%8D%E7%9A%84%E7%AC%A6%E5%8F%B7%E8%AF%B4%E6%98%8E">指令执行对标志位影响的符号说明：</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4">数据传送指令</a></li>
<li><a href="#%E9%80%9A%E7%94%A8%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4">通用数据传送指令</a>
<ul>
<li><a href="#mov%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4">MOV传送指令</a></li>
<li><a href="#xchg%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2%E6%8C%87%E4%BB%A4">XCHG数据交换指令</a></li>
<li><a href="#%E5%A0%86%E6%A0%88%E6%8C%87%E4%BB%A4">堆栈指令</a>
<ul>
<li><a href="#%E5%85%A5%E6%A0%88%E6%8C%87%E4%BB%A4push">入栈指令PUSH</a></li>
<li><a href="#%E5%87%BA%E6%A0%88%E6%8C%87%E4%BB%A4pop">出栈指令POP</a></li>
</ul>
</li>
<li><a href="#%E5%85%B6%E4%BB%96%E5%A0%86%E6%A0%88%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4">其他堆栈操作指令</a>
<ul>
<li><a href="#%E6%89%80%E6%9C%89%E5%AF%84%E5%AD%98%E5%99%A8%E8%BF%9B%E6%A0%88%E6%8C%87%E4%BB%A4pusha">所有寄存器进栈指令PUSHA</a></li>
<li><a href="#%E6%89%80%E6%9C%89%E5%AF%84%E5%AD%98%E5%99%A8%E5%87%BA%E6%A0%88%E6%8C%87%E4%BB%A4popa">所有寄存器出栈指令POPA</a></li>
</ul>
</li>
<li><a href="#%E7%B4%AF%E5%8A%A0%E5%99%A8%E4%B8%93%E7%94%A8%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4">累加器专用传送指令</a>
<ul>
<li><a href="#xlat-%E6%9F%A5%E8%A1%A8%E8%BD%AC%E6%8D%A2%E6%8C%87%E4%BB%A4">XLAT   查表转换指令</a></li>
</ul>
</li>
<li><a href="#io%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4">I/O数据传送指令</a>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E6%8C%87%E4%BB%A4in%E5%B0%86%E7%AB%AF%E5%8F%A3%E7%9A%84%E6%95%B0%E6%8D%AE%E9%80%81%E5%85%A5cpu%E7%B4%AF%E5%8A%A0%E5%99%A8">输入指令IN（将端口的数据送入CPU累加器）</a></li>
<li><a href="#out%E8%BE%93%E5%87%BA%E6%8C%87%E4%BB%A4%E5%B0%86cpu%E7%B4%AF%E5%8A%A0%E5%99%A8%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E7%AB%AF%E5%8F%A3">OUT输出指令（将CPU累加器中数据写入端口）</a></li>
</ul>
</li>
<li><a href="#%E5%9C%B0%E5%9D%80%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4">地址传送指令</a>
<ul>
<li><a href="#%E6%9C%89%E6%95%88%E5%9C%B0%E5%9D%80%E9%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E6%8C%87%E4%BB%A4lea-load-effective-address">有效地址送寄存器指令LEA (Load Effective Address)</a></li>
<li><a href="#%E6%8C%87%E9%92%88%E9%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E5%8F%8A%E7%9B%B8%E5%BA%94%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E6%8C%87%E4%BB%A4lds%E5%92%8Cles">指针送寄存器及相应段寄存器指令LDS和LES</a>
<ul>
<li><a href="#lds-load-pointer-into-ds">LDS (Load pointer into DS)</a></li>
<li><a href="#les-load-pointer-into-es">LES (Load pointer into ES)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4">标志寄存器传送指令</a>
<ul>
<li><a href="#%E6%A0%87%E5%BF%97%E9%80%81ah%E6%8C%87%E4%BB%A4-lahf">标志送AH指令： LAHF</a></li>
<li><a href="#ah%E9%80%81%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8%E6%8C%87%E4%BB%A4sahf">AH送标志寄存器指令：SAHF</a></li>
<li><a href="#%E6%A0%87%E5%BF%97%E8%BF%9B%E6%A0%88%E6%8C%87%E4%BB%A4pushf">标志进栈指令：PUSHF</a></li>
<li><a href="#%E6%A0%87%E5%BF%97%E5%87%BA%E6%A0%88%E6%8C%87%E4%BB%A4popf">标志出栈指令：POPF</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4">算术运算指令</a>
<ul>
<li><a href="#%E5%8A%A0%E6%B3%95%E6%8C%87%E4%BB%A4">加法指令</a>
<ul>
<li><a href="#%E4%B8%8D%E5%B8%A6%E8%BF%9B%E4%BD%8D%E7%9A%84%E5%8A%A0%E6%B3%95%E6%8C%87%E4%BB%A4-add-dstsrc">不带进位的加法指令：    ADD  DST，SRC</a></li>
<li><a href="#%E5%B8%A6%E8%BF%9B%E4%BD%8D%E5%8A%A0%E6%B3%95%E6%8C%87%E4%BB%A4-adc-dstsrc">带进位加法指令：  ADC  DST，SRC</a></li>
<li><a href="#%E5%8A%A01%E6%8C%87%E4%BB%A4-inc-dst">加1指令：        INC  DST</a></li>
</ul>
</li>
<li><a href="#%E5%87%8F%E6%B3%95%E6%8C%87%E4%BB%A4">减法指令</a>
<ul>
<li><a href="#%E5%87%8F%E6%B3%95%E6%8C%87%E4%BB%A4-sub-dstsrc">减法指令： SUB  DST，SRC</a></li>
<li><a href="#%E5%B8%A6%E5%80%9F%E4%BD%8D%E5%87%8F%E6%B3%95%E6%8C%87%E4%BB%A4-sbb-dstsrc">带借位减法指令： SBB  DST，SRC</a></li>
<li><a href="#%E5%87%8F1%E6%8C%87%E4%BB%A4-dec-opr">减1指令： DEC  OPR</a></li>
<li><a href="#%E6%B1%82%E8%A1%A5%E6%8C%87%E4%BB%A4-neg-opr">求补指令： NEG  OPR</a></li>
<li><a href="#%E6%AF%94%E8%BE%83%E6%8C%87%E4%BB%A4-cmp-opr1-opr2">比较指令： CMP  OPR1, OPR2</a></li>
</ul>
</li>
<li><a href="#%E4%B9%98%E6%B3%95%E6%8C%87%E4%BB%A4">乘法指令</a>
<ul>
<li><a href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E4%B9%98%E6%B3%95%E6%8C%87%E4%BB%A4-mul-src">无符号数乘法指令：        MUL   SRC</a></li>
<li><a href="#%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E4%B9%98%E6%B3%95%E6%8C%87%E4%BB%A4-imul-src">有符号数乘法指令：        IMUL  SRC</a></li>
</ul>
</li>
<li><a href="#%E9%99%A4%E6%B3%95%E6%8C%87%E4%BB%A4">除法指令</a>
<ul>
<li><a href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E9%99%A4%E6%B3%95%E6%8C%87%E4%BB%A4-div-src">无符号数除法指令：   DIV  SRC</a></li>
<li><a href="#%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E9%99%A4%E6%B3%95%E6%8C%87%E4%BB%A4-idiv-src">带符号数除法指令：   IDIV  SRC</a></li>
</ul>
</li>
<li><a href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%8C%87%E4%BB%A4%E6%8C%87%E4%BB%A4">类型转换指令指令</a>
<ul>
<li><a href="#%E5%AD%97%E8%8A%82%E6%89%A9%E5%B1%95%E4%B8%BA%E5%AD%97%E6%8C%87%E4%BB%A4-cbw-al-ax">字节扩展为字指令  CBW          AL ← AX</a></li>
<li><a href="#%E5%AD%97%E6%89%A9%E5%B1%95%E6%88%90%E5%8F%8C%E5%AD%97%E6%8C%87%E4%BB%A4cwd-ax-dxax">字扩展成双字指令CWD         AX ← （DX,AX）</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81%E8%BF%9B%E5%88%B6%E8%B0%83%E6%95%B4%E6%8C%87%E4%BB%A4">十进制调整指令</a>
<ul>
<li><a href="#%E5%8E%8B%E7%BC%A9%E7%9A%84bcd%E7%A0%81%E8%B0%83%E6%95%B4%E6%8C%87%E4%BB%A4">压缩的BCD码调整指令</a></li>
<li><a href="#%E9%9D%9E%E5%8E%8B%E7%BC%A9%E7%9A%84bcd%E7%A0%81%E8%B0%83%E6%95%B4%E6%8C%87%E4%BB%A4">非压缩的BCD码调整指令</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E4%BD%8D%E6%A0%87%E5%BF%97cfcarry-flag">进位标志CF（Carry Flag）</a></li>
<li><a href="#%E9%9B%B6%E6%A0%87%E5%BF%97zfzero-flag">零标志ZF（Zero Flag）</a></li>
<li><a href="#%E7%AC%A6%E5%8F%B7%E6%A0%87%E5%BF%97sfsign-flag">符号标志SF（Sign Flag）</a></li>
<li><a href="#%E5%A5%87%E5%81%B6%E6%A0%87%E5%BF%97pfparity-flag">奇偶标志PF（Parity Flag）</a></li>
<li><a href="#%E8%BE%85%E5%8A%A9%E8%BF%9B%E4%BD%8D%E6%A0%87%E5%BF%97afauxiliary-carry-flag">辅助进位标志AF（Auxiliary Carry Flag）</a></li>
<li><a href="#%E6%BA%A2%E5%87%BA%E6%A0%87%E5%BF%97ofoverflow-flag">溢出标志OF（Overflow Flag）</a></li>
</ul>
</li>
<li><a href="#%E9%80%BB%E8%BE%91%E6%8C%87%E4%BB%A4">逻辑指令</a>
<ul>
<li><a href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4">逻辑运算指令</a>
<ul>
<li><a href="#%E9%80%BB%E8%BE%91%E4%B8%8E%E6%8C%87%E4%BB%A4and-dstregmem-srcregmemimm">逻辑与指令：AND  DST（reg/mem）, SRC（reg/mem/imm）</a></li>
<li><a href="#%E9%80%BB%E8%BE%91%E6%88%96%E6%8C%87%E4%BB%A4or-dstregmem-srcregmemimm">逻辑或指令：OR  DST（reg/mem）, SRC（reg/mem/imm）</a></li>
<li><a href="#%E5%BC%82%E6%88%96%E6%8C%87%E4%BB%A4-xor-dstregmem-srcregmemimm">异或指令：    XOR  DST（reg/mem）, SRC（reg/mem/imm）</a></li>
<li><a href="#%E9%80%BB%E8%BE%91%E9%9D%9E%E6%8C%87%E4%BB%A4-not-opr-regmem">逻辑非指令： NOT  OPR （reg/mem）</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95%E6%8C%87%E4%BB%A4-test-opr1regopr2regmemimm">测试指令：    TEST  OPR1（reg），OPR2(reg/mem/imm)</a></li>
</ul>
</li>
<li><a href="#%E7%A7%BB%E4%BD%8D%E6%8C%87%E4%BB%A4">移位指令</a>
<ul>
<li><a href="#%E7%A7%BB%E4%BD%8D%E6%8C%87%E4%BB%A4-2">移位指令</a></li>
<li><a href="#%E5%BE%AA%E7%8E%AF%E7%A7%BB%E4%BD%8D%E6%8C%87%E4%BB%A4">循环移位指令</a></li>
</ul>
</li>
<li><a href="#%E4%B8%B2%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4">串操作指令</a>
<ul>
<li><a href="#%E4%B8%8E-rep-%E9%85%8D%E5%90%88%E5%B7%A5%E4%BD%9C%E7%9A%84-movs-stos-lods%E7%9A%84%E6%8C%87%E4%BB%A4">与 REP 配合工作的 MOVS / STOS / LODS的指令</a>
<ul>
<li><a href="#%E9%87%8D%E5%A4%8D%E5%89%8D%E7%BC%80%E6%8C%87%E4%BB%A4rep">重复前缀指令REP</a></li>
<li><a href="#%E4%B8%B2%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4move-string-instruction">串传送指令（Move String Instruction）</a></li>
<li><a href="#%E4%B8%B2%E5%AD%98%E5%82%A8%E6%8C%87%E4%BB%A4store-string-instruction">串存储指令（Store String Instruction）</a></li>
<li><a href="#%E4%B8%B2%E8%A3%85%E5%85%A5%E6%8C%87%E4%BB%A4load-string-instruction">串装入指令（Load String Instruction）</a></li>
<li><a href="#%E4%B8%B2%E8%BE%93%E5%85%A5%E6%8C%87%E4%BB%A4ins">串输入指令INS</a></li>
<li><a href="#%E4%B8%B2%E8%BE%93%E5%87%BA%E6%8C%87%E4%BB%A4outs">串输出指令OUTS</a></li>
</ul>
</li>
<li><a href="#%E4%B8%8E-repzrepnz%E9%85%8D%E5%90%88%E5%B7%A5%E4%BD%9C%E7%9A%84cmps-%E5%92%8C-scas%E6%8C%87%E4%BB%A4">与 REPZ（REPNZ）配合工作的CMPS 和 SCAS指令</a>
<ul>
<li><a href="#%E7%9B%B8%E7%AD%89%E9%87%8D%E5%A4%8D%E5%89%8D%E7%BC%80%E6%8C%87%E4%BB%A4-reperepz">相等重复前缀指令 REPE/REPZ</a></li>
<li><a href="#%E4%B8%8D%E7%AD%89%E9%87%8D%E5%A4%8D%E5%89%8D%E7%BC%80%E6%8C%87%E4%BB%A4-repnerepnz">不等重复前缀指令 REPNE/REPNZ</a></li>
<li><a href="#%E4%B8%B2%E6%AF%94%E8%BE%83%E6%8C%87%E4%BB%A4-cmps">串比较指令 CMPS</a></li>
<li><a href="#%E4%B8%B2%E6%89%AB%E6%8F%8F%E6%8C%87%E4%BB%A4-scas">串扫描指令 SCAS</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%8E%A7%E5%88%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4">控制转移指令</a>
<ul>
<li><a href="#jmp%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F">JMP寻址方式：</a></li>
<li><a href="#%E6%97%A0%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4-jmp-op1regmem%E6%A0%87%E5%8F%B7">无条件转移指令    JMP   OP1（reg/mem/标号）</a></li>
<li><a href="#%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4">条件转移指令</a></li>
<li><a href="#%E5%BE%AA%E7%8E%AF%E6%8C%87%E4%BB%A4">循环指令</a>
<ul>
<li><a href="#%E5%BE%AA%E7%8E%AF%E6%8C%87%E4%BB%A4-loop">循环指令 LOOP</a></li>
<li><a href="#%E7%9B%B8%E7%AD%89%E4%B8%BA%E9%9B%B6%E5%BE%AA%E7%8E%AF%E6%8C%87%E4%BB%A4-loopeloopz">相等/为零循环指令  LOOPE/LOOPZ</a></li>
<li><a href="#%E4%B8%8D%E7%9B%B8%E7%AD%89%E4%B8%8D%E4%B8%BA%E9%9B%B6%E5%BE%AA%E7%8E%AF%E6%8C%87%E4%BB%A4loopneloopnz">不相等/不为零循环指令LOOPNE/LOOPNZ</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%AD%90%E7%A8%8B%E5%BA%8F">子程序</a>
<ul>
<li><a href="#%E5%AD%90%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%E6%8C%87%E4%BB%A4-call">子程序调用指令   CALL</a></li>
<li><a href="#%E8%BF%94%E5%9B%9E%E6%8C%87%E4%BB%A4-ret">返回指令  RET</a></li>
</ul>
</li>
<li><a href="#%E4%B8%AD%E6%96%AD">中断</a>
<ul>
<li><a href="#%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8%E5%92%8C%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F">中断向量表和中断服务程序</a></li>
<li><a href="#%E4%B8%AD%E6%96%AD%E6%8C%87%E4%BB%A4-int">中断指令 INT</a></li>
<li><a href="#%E6%BA%A2%E5%87%BA%E6%8C%87%E4%BB%A4-into">溢出指令 INTO</a></li>
<li><a href="#%E4%B8%AD%E6%96%AD%E8%BF%94%E5%9B%9E%E6%8C%87%E4%BB%A4-iret">中断返回指令 IRET</a></li>
<li><a href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E5%AD%90%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%AF%94%E8%BE%83">中断和子程序的比较</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%A4%84%E7%90%86%E6%9C%BA%E6%8E%A7%E5%88%B6%E5%92%8C%E6%9D%82%E9%A1%B9%E6%8C%87%E4%BB%A4">处理机控制和杂项指令</a>
<ul>
<li><a href="#%E6%A0%87%E5%BF%97%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4">标志处理指令</a></li>
<li><a href="#cpu%E6%8E%A7%E5%88%B6%E7%B1%BB%E6%8C%87%E4%BB%A4">CPU控制类指令</a>
<ul>
<li><a href="#%E7%A9%BA%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4-nopno-operation-instruction">空操作指令   NOP（No Operation Instruction）</a></li>
<li><a href="#%E6%9A%82%E5%81%9C%E6%8C%87%E4%BB%A4-hltenter-halt-state-instruction">暂停指令   HLT（Enter Halt State Instruction）</a></li>
<li><a href="#%E6%8D%A2%E7%A0%81%E6%8C%87%E4%BB%A4esc">换码指令ESC</a></li>
<li><a href="#%E7%AD%89%E5%BE%85%E6%8C%87%E4%BB%A4-waitput-processor-in-wait-state-instruction">等待指令  WAIT（Put Processor in Wait State Instruction）</a></li>
<li><a href="#%E5%B0%81%E9%94%81%E6%95%B0%E6%8D%AE%E6%8C%87%E4%BB%A4locklock-bus-instruction">封锁数据指令LOCK（Lock Bus Instruction）</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">第四章 汇编语言及其程序设计</a></li>
<li><a href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8">第五章 存储器</a></li>
<li><a href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E4%B8%AD%E6%96%AD%E6%8A%80%E6%9C%AF">第六章 中断技术</a></li>
<li><a href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-io%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF">第七章 I/O接口技术</a></li>
<li><a href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-da%E4%B8%8Ead%E8%BD%AC%E6%8D%A2%E5%99%A8%E6%8E%A5%E5%8F%A3">第八章 D/A与A/D转换器接口</a></li>
<li><a href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%BE%AE%E6%9C%BA%E6%80%BB%E7%BA%BF">第九章 微机总线</a></li>
<li><a href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92%E6%8E%A5%E5%8F%A3">第十章 人机交互接口</a></li>
<li><a href="#a-target_blank-hrefhttpmailqqcomcgi-binqm_sharetqm_mailmeemailk_h88fzp0_livfd8-g-styletext-decorationnone-%E6%84%8F%E8%A7%81%E5%8F%8D%E9%A6%88a"><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=k_H88fzp0_LivfD8-g" style="text-decoration:none;">✉ 意见反馈</a></a></li>
</ul>

                            </div>
                            
                                
                                    
                                            <!--zh-->
                                            <section class="post-copyright zh">
                                                <p class="copyright-item ">
                                                    <span>&#x4F5C;&#x8005;:</span>
                                                    <span>ROBOZ</span>
                                                </p>

                                                <p class="copyright-item">
                                                    <span>&#x6C38;&#x4E45;&#x94FE;&#x63A5;:</span>
                                                    <span><a href="https://roboz-up.github.io/post/bi-ji-wei-ji-yuan-li-ji-jie-kou-ji-zhu/">https://roboz-up.github.io/post/bi-ji-wei-ji-yuan-li-ji-jie-kou-ji-zhu/</a></span>
                                                </p>

                                                <p class="copyright-item">
                                                    <span>&#x534F;&#x8BAE;:</span>
                                                    <span>MIT License</span>
                                                </p>
                                            </section>
                                            
                                                
                                                    
                                                                    <!--Share-->
                                                                    <span style="margin-right:15px">
                        <i class="post-share"></i>
                        <span>&#x5206;&#x4EAB;:</span>
                                                                    <a title="QR 码" target="_blank" href="https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://roboz-up.github.io/post/bi-ji-wei-ji-yuan-li-ji-jie-kou-ji-zhu/"><i class="fa fa-qrcode"></i></a>
                                                                    <a title="QQ" target="_blank" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://roboz-up.github.io/post/bi-ji-wei-ji-yuan-li-ji-jie-kou-ji-zhu/&sharesource=qzone&title=笔记：微机原理及接口技术&pics=https://roboz-up.github.io/images/avatar.png?v=1589637852670&summary="><i class="fa fa-qq"></i></a>
                                                                    <a title="新浪微博" target="_blank" href="https://service.weibo.com/share/share.php?url=https://roboz-up.github.io/post/bi-ji-wei-ji-yuan-li-ji-jie-kou-ji-zhu/&sharesource=weibo&title=笔记：微机原理及接口技术 + " - " + &pic="https://roboz-up.github.io/images/avatar.png?v=1589637852670 "><i class="fa fa-weibo "></i></a>

                                                                    </span>
                                                                    
                                                                            <!--zh-->
                                                                            <section class="post-tags zh ">
                                                                                <div>
                                                                                    <span>&#x6807;&#x7B7E;:</span>
                                                                                    <span class="tag ">
                        
                        
                        <a href="https://roboz-up.github.io/tag/Y2pfBAN1G/">#
                    笔记
                        </a>
                        
                            
                                </span>
                                                                                </div>
                                                                                <div>
                                                                                    <a href="javascript:window.history.back();">
                        &#x8FD4;&#x56DE;</a>
                                                                                    <span>&dot;</span>
                                                                                    <a href="#">&#x4E3B;&#x9875;</a>
                                                                                </div>
                                                                            </section>

                                                                            
                                                                                <!---->
                                                                                <section class="post-nav">
                                                                                    
                                                                                        <a class="prev" rel="prev" href="https://roboz-up.github.io/post/shi-yong-wang-zhan-ji/">
                                                                                            网站收藏集
                                                                                        </a>
                                                                                        
                                                                                            
                                                                                                <a class="next" rel="next" href="https://roboz-up.github.io/post/ge-ren-wang-zhan-de-chuang-jian/">
                                                                                                    个人免费网站的创建
                                                                                                </a>
                                                                                                
                                                                                </section>
                    </article>
                </div>
                
                                            
            </div>
    </div>
    </div>
    </div>
    
        <footer id="footer" class="footer">
            <div class="copyright">
                
                        <a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=k_H88fzp0_LivfD8-g" style="text-decoration:none;">意见反馈  ✒</a>
                            
                                <b id="hitokoto"></b><br>
                                
                                        <svg viewBox="0 0 1024 1024" style="margin-left: 5px;margin-right: 5px;" version="1.0" width="8" height="8" class="my-face">
            <path
                d="M863.597631 513.574282l-271.33965-140.213484L729.783667 81.926656c3.583731-7.87141 7.167462-15.742819 7.167462-25.214109C736.887134 25.226908 708.345275 0.012799 672.635953 0.012799a63.611229 63.611229 0 0 0-39.293053 12.607055c-1.791866 1.59988-3.519736 3.19976-5.311602 3.19976L147.87531 418.925381a55.547834 55.547834 0 0 0-19.646527 47.356448c1.791866 17.278704 14.27093 33.021523 32.125591 42.492813l271.33965 141.749369L292.504463 945.221908c-12.479064 25.214109-1.791866 53.563983 23.166262 69.306802 10.751194 6.335525 23.230258 9.47129 35.709322 9.47129 16.062795 0 32.125591-4.735645 44.604655-15.742819l480.091993-403.297753a55.547834 55.547834 0 0 0 19.646526-47.228458 61.243407 61.243407 0 0 0-32.12559-44.156688z"
                fill="#93b5cf"></path>
        </svg>
                                        ROBOZ &copy;Copyright
                                            <script>
                                                var date = new Date();
                                                document.write("" + date.getFullYear());
                                            </script>
                                            | Powered by
                                            <a href="https://github.com/" target="_blank">
                                                Github
                                            </a>
            </div>
            <div id="update" style="display:none;">
                on
            </div>
            
                <div id="version" style="display:none;">
                    1.7.3
                </div>
                
                    <script>
                        var pat = '';
                        
                        document.write('<div id="home_path" style="display:none;">' + document.location.protocol + '//' + window.document.location.hostname + pat + '</div>')
                    </script>
        </footer>
        
                <script>
                    
                    
                    
                    hitokoto();
                    
                    getStar();
                    hljs.initHighlighting();
                    console.clear();
                    
                    CheckVersion();
                    
                    var newDate = new Date();
                    newDate.setTime(1589637852670);
                    console.log(" Blog Update Time: " + newDate.toLocaleDateString());
                    console.log("\n %c \u26a1Theme:Chic Author's Blog:https://blog.itjoker.cn  Write By ITJoker  \n\n", "color: #ffffff; background: rgba(49, 49, 49, 0.85); padding:5px 0;border-radius:5px;");
                </script>
                
        </div>
</body>
<script>
    scroll();
</script>

</html>